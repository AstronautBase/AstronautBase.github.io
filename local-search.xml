<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统-14持久化-文件系统</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14%E6%8C%81%E4%B9%85%E5%8C%96-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14%E6%8C%81%E4%B9%85%E5%8C%96-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>磁盘中存储的数据</p><ul><li>程序数据<ul><li>可执行文件、动态链接库、应用数据</li></ul></li><li>用户数据<ul><li>文档、下载、截图</li></ul></li><li>系统数据<ul><li>配置文件</li></ul></li></ul><h2 id="文件系统">文件系统</h2><p>存储和读取本身没有问题，磁盘驱动器就是做这个的<br>但让应⽤程序直接通过驱动访问存储设备 (1950s)？</p><ul><li>程序出 bug 了（不可避免），完全可能弄坏整块磁盘</li><li>连带着所有数据，包括操作系统都直接损坏</li></ul><p>因此应⽤程序应该“有限制”地访问数据</p><ul><li>提供合理的 API 使多个应⽤程序能共享数据</li><li>提供⼀定的隔离，使恶意/出错程序的伤害不能任意扩⼤</li><li>这就是⽂件系统</li></ul><p>⽂件系统是对持久性存储的抽象和接⼝。</p><ul><li>类⽐<ul><li>线程抽象：⼀个 CPU → 多个虚拟 CPU，在时间上共享</li><li>虚拟存储：⼀份内存 → 划分给多个虚拟地址空间</li><li>⽂件系统：⼀个物理磁盘 → 多个虚拟磁盘</li></ul></li></ul><p><img src="2025060899.png" alt=""></p><p><strong>文件系统</strong></p><ul><li>持久性和命名数据：⽂件和⽬录<ul><li>存储在系统中直到显式删除为⽌</li><li>可以通过⽂件系统关联的可读标识符访问</li></ul></li><li>访问和保护：提供打开、读取、写⼊和其他操作；调节不同⽤户对⽂件的访问。</li><li>磁盘管理：公平有效地利⽤磁盘空间<ul><li>分配空间给⽂件，并跟踪空闲空间</li><li>快速访问⽂件</li></ul></li><li>可靠性：不得丢失⽂件数据</li></ul><h3 id="文件">文件</h3><p>⽂件是操作系统创建的逻辑存储单元，⽤于存储信息</p><ul><li>可以是数据库、⾳频、视频、⽹⻚等内容。</li><li>它是⼀组数据集合（类型由⽤户定义）</li><li>可以创建、读取、写⼊和删除</li><li>提供了⼀种在磁盘上存储信息并随后读取的抽象机制。</li></ul><p><strong>文件命名</strong><br>⽂件的命名规则因系统⽽异</p><ul><li>⻓度和特殊字符</li><li>字⺟⼤⼩写</li></ul><p>⽂件扩展名：例如. txt，. c</p><ul><li>表示⽂件内容的某些类型</li><li>为应⽤程序或操作系统提供⽂件合理操作的提示</li></ul><p><strong>文件类型</strong><br>许多操作系统⽀持多种类型的⽂件</p><ul><li>普通⽂件 (‘-’)：包含⽤户信息的⽂件<ul><li>ASCII ⽂件，⼆进制⽂件</li></ul></li><li>⽬录 (‘d’)：⽤于维护⽂件系统结构的系统⽂件</li><li>符号链接⽂件（‘l’）</li><li>命名管道⽂件或简称管道⽂件（‘p’）</li><li>块⽂件（‘b’）</li><li>字符设备⽂件（‘c’）</li><li>套接字⽂件（‘s;）</li></ul><p><strong>文件元数据（属性）</strong><br>除了⽂件的名称和数据外，操作系统还会保留⽂件的额外信息：</p><ul><li>位置：⽂件在设备上的位置指针</li><li>⼤⼩：⽂件的⼤⼩（当前⼤⼩或最⼤⼤⼩）</li><li>时间：⽂件的创建时间、最近访问时间和最近修改时间</li><li>所有者：⽂件的当前所有者</li><li>保护信息</li></ul><p>⽂件系统应该将⽂件元数据保存在⼀个结构中（⽂件控制块）：</p><ul><li>存储在磁盘上，并且缓存在内存中以加快访问速度</li></ul><p>文件控制块-&gt;unix 中就是 <strong>inode</strong> (index node)</p><p><strong>文件访问</strong></p><p>顺序访问：按顺序读取或写⼊数据</p><ul><li>读取下⼀个/写⼊下⼀个</li><li>最常⻅的访问模式（例如，复制⽂件，编译器读取和写⼊⽂件）</li><li>速度快（可以达到磁盘的峰值传输速率）</li></ul><p>随机（直接）访问：随机寻址任意块</p><ul><li>读取 [n] 写⼊[n] 寻址[n]</li><li>⽂件操作包括块号作为参数</li><li>速度慢（寻址时间和旋转延迟）</li></ul><p><img src="2025060884.png" alt=""></p><p><strong>文件描述符</strong><br>⽂件描述符（句柄）：操作系统分配给⼀个进程打开的⽂件的⼀个唯⼀数字 （每个进程私有），⽤于引⽤该⽂件。</p><ul><li>持有该⽂件描述符，可以对对应的⽂件执⾏特定操作</li><li>避免在每次访问时解析⽂件名（在⽬录中搜索⽂件名）和检查权限</li><li>⼀个⽂件可以以不同⽅式多次打开</li></ul><p><img src="2025060809.png" alt=""></p><p><strong>文件偏移</strong><br>对于进程打开的每个⽂件，操作系统都会跟踪⼀个⽂件偏移量，该偏移量决定下⼀次读取或写⼊将从何处开始。</p><ul><li>隐式更新：当进⾏ N 字节的读取或写⼊时，N 会被添加到当前偏移量。</li><li>显式更新：使⽤ lseek () 函数。</li></ul><p><strong>打开文件表</strong><br>当进程打开⼀个⽂件时，操作系统应该创建⼀些额外的数据结构（在内存中），⽤于存储关于进程打开⽂件的信息。</p><p>每个进程都维护⼀个打开⽂件表</p><ul><li>⼀个由<em>⽂件描述符</em>索引的数组</li><li>表中的每个条⽬跟踪⽂件描述符所引⽤的底层⽂件，当前偏移量以及其他相关细节（例如⽂件⼤⼩、位置、权限等）</li></ul><p><img src="2025060864-1.png" alt=""></p><p>要打开⼀个⽂件，<em>搜索系统范围的打开⽂件表</em>，以查看⽂件当前是否正在使⽤</p><ul><li>如果没有，搜索⽬录以查找⽂件名，并在系统范围的打开⽂件表中添加⼀个条⽬</li></ul><p>在属于进程的打开⽂件表中创建⼀个打开⽂件的条⽬，并指向系统的打开⽂件表<br>增加系统的打开⽂件表中的打开计数</p><ul><li>只有当所有进程关闭⽂件（或退出）时，才可以删除表条⽬</li></ul><p>返回指向每个进程打开⽂件表中条⽬的指针（⽂件描述符）</p><p><strong>文件描述符表 &amp; 打开文件表 &amp; inode 表</strong><br><img src="2025060829.png" alt=""></p><p>两个进程打开相同文件<br><img src="2025060805.png" alt=""></p><ul><li>两个进程可以指向同⼀个全局的打开项（如 Fork）</li><li>⼀个进程可以有多个指向同⼀个打开项的⽂件描述符（Dup）</li></ul><h3 id="目录">目录</h3><p>⽂件系统通常有⽬录来跟踪⽂件</p><ul><li>通过将⽬录放在其他⽬录内，⽤户可以构建任意的⽬录树（或⽬录层次结构）<br>标识⽂件或⽬录的字符串称为路径</li><li>绝对路径：从根⽬录到⽂件的路径（使⽤ 某种分隔符）</li><li>相对路径：为每个进程提供⼀个当前（⼯ 作）⽬录<ul><li>在 Unix 中，每个⽬录中有两个特殊条 ⽬：“.” 和 “…”分别代表当前⽬录和上⼀ 层⽬录</li></ul></li></ul><p>⽬录存储了⽂件名与低级别结构（⽂件控制块 inode）之间的映射</p><ul><li>在 Unix 中，每个⽬录条⽬只是⼀个 <em>⟨⽂件名，inode 号⟩</em> 对</li><li>⽬录被存储为⼀个<em>⽂件</em></li><li>要查找⼀个⽂件，需要找到<em>包含该映射的⽬录</em></li><li>根⽬录是特别的：需要为根⽬录分配⼀个固定的 inode 号</li></ul><p><img src="2025060846.png" alt=""><br><em>目录的操作</em></p><p><img src="2025060814-1.png" alt=""></p><h3 id="共享文件">共享文件</h3><p>通过将⼀个新⽂件名链接到⼀个旧⽂件名，我们可以创建另⼀种引⽤同⼀⽂件的⽅式</p><ul><li>可以为同⼀个⽂件创建多个不同的名称</li><li>⽬录结构变成⼀个有向⽆环图</li><li>有两种链接<ul><li>硬链接（Hard link）</li><li>符号链接（Symbolic link）或软链接 (Soft link)</li></ul></li></ul><h4 id="硬链接">硬链接</h4><p>硬链接本质上是 <em>inode 号的别名</em><br>因此，当创建⼀个⽂件时，</p><ul><li>⾸先，创建⼀个结构（inode），该结构将跟踪关于⽂件的所有相关信息</li><li>其次，将⼀个⼈类可读的名称链接到该⽂件，并将该链接放⼊⽬录中</li></ul><p>但不能链接到另⼀个⽂件系统上的⽂件</p><ul><li>因为 inode 号只在⼀个⽂件系统内是唯⼀的</li></ul><p>不允许链接到⽬录（简化管理）</p><ul><li>这防⽌了在⽬录层次结构中创建循环</li><li>避免了⽗⽬录的不明确性 - ⽐如如果多个⽗⽬录有指向同⼀⼦⽬录的链接，那么该⽬录中的 “…” 指向什么？</li></ul><h4 id="软链接">软链接</h4><p>符号（软）链接：创建⼀种不同类型的⽂件（链接类型）<br><img src="2025060842.png" alt=""><br>符号（软）链接是路径名的别名</p><ul><li>可以链接到⽬录，或跨⽂件系统链接</li></ul><p>当需要解析路径名时符号链接被解析</p><ul><li>找到⽬标⽂件的名称，并使⽤新名称打开</li><li>⽬标可以是另⼀个符号链接（递归解析）</li><li>⽐硬链接效率低</li></ul><p>当删除符号链接时，⽬标⽂件保持不变</p><ul><li>当⽬标⽂件被删除时，产⽣引⽤悬空（ dangling reference）</li><li>该链接指向⼀个已不存在的路径名</li></ul><h3 id="文件保护">文件保护</h3><p>⽂件保护是为了防⽌意外和恶意破坏⾏为<br>⽂件所有者应该能够控制</p><ul><li>可以做什么？</li><li>谁可以做？</li></ul><p>访问权限的类型</p><ul><li>对于⽂件：read / write / execute</li><li>对于⽬录：list / modify / delete</li><li>对于访问权限本身：更改访问权限 / 给予某⼈访问权限 / 撤销某⼈的访问权限</li></ul><p>访问控制矩阵（Access Control Matrix）：系统访问控制的实现可以视为基于⼀个巨⼤表格，该表格编码了系统中每个⽤户或者⽤户组的所有访问权限<br><img src="2025060860.png" alt=""></p><h3 id="文件系统挂载-Mount">文件系统挂载 Mount</h3><p>⼀个⽂件系统在能被访问之前，必须先进⾏挂载</p><ul><li>从现有⽂件系统中的某个路径（挂载点）创建到挂载⽂件系统的根⽬录的映射<ul><li>将多个文件系统统一到一棵树中</li></ul></li><li>在 Linux 上，mkfs 命令可以在块设备上创建⼀个新的⽂件系统，mount 命令可以在当前⽂件系统中的某个⽬录下挂载⼀个⽂件系统。没有任何参数时，mount 命令会显示当前的挂载点.</li></ul><p><img src="2025060896.png" alt=""></p><p><em>两个关键的抽象</em><br><img src="2025060885-1.png" alt=""><br>文件系统 &amp; 虚拟内存<br><img src="2025060886-3.png" alt=""></p><h2 id="文件系统实现">文件系统实现</h2><p>我们需要回答如下⼏个问题：</p><ul><li>⽂件和⽬录是怎么存储和组织的？</li><li>磁盘空间如何管理？</li><li>⽂件系统的实现是否⾼效和可靠？</li></ul><h3 id="文件系统的布局">文件系统的布局</h3><p>⽂件系统需要为需要存储的数据维护⼀个其在磁盘上的数据结构</p><ul><li>数据区域 (数据块): 磁盘保留的⼀个固定数据块部分⽤来存储数据本身</li><li>inode 表：每个⽂件的元信息<ul><li>⽂件对应哪些数据块、⽂件的⼤⼩，拥有者，时间戳，访问权限…</li><li>⼀个数据块可以存储多个元信息（inodes），⼀个 4KB 的数据块可以包含 16 个 256 字节的 inode</li><li>⼀个 inode 在哪个数据块存储是容易查询的</li></ul></li><li>分配数据结构: 对于已分配和空闲的空间的信息 (空闲空间分配)<ul><li>决定⼀个 inode 或⼀个数据块是否是空闲的</li><li>有两个空闲数据结构（基于 bitmap），⼀个为了 inode，⼀个为了数据块</li></ul></li><li>超级块（Superblock）: ⽂件系统本身的信息<ul><li>⽂件系统的类型、inodes 数量、数据块数量、inode 表开始的块地址…</li><li>当挂载⼀个⽂件系统时会读取超级块的信息</li></ul></li><li>启动块：启动 OS 所需要的信息<ul><li>⼀般来说是⼀个分区的第⼀个数据块 (没有 OS 的话为空)</li></ul></li></ul><p><img src="2025060839.png" alt=""></p><p>⽂件系统还需要在内存中维护相应的数据结构⽤来⽅便的对磁盘数据进⾏访问 （⽤来反映和拓展磁盘中的结构）</p><ul><li>挂载表（Mount table）: 关于⽂件系统的挂载信息（挂载点、⽂件系统类型）</li><li>打开⽂件表: 系统范围的和每个进程的</li><li>⽬录结构：最近访问的⽬录信息</li><li>I/O 内存缓冲: 读写磁盘时需要处理主存和磁盘之间速度差异的“缓冲带</li></ul><h3 id="文件组织">文件组织</h3><p>文件需要磁盘给定相应的数据块进⾏存储，此外还需要有⼀些数据结构来反映该⽂件⽤的数据块在哪<br>很多种组织⽅式</p><ul><li>连续存储（Contiguous）</li><li>链表（Linked List）</li><li>⽂件分配表（File Allocation Table）</li><li>索引式配置（Indexed Allocation）</li></ul><p><strong>连续分配</strong></p><ul><li>只有⽂件的第⼀个数据块的地址和需要的数据块总数需要记录</li><li>线性的访问是⾼效的</li><li>随机访问的数据地址也是容易计算的</li></ul><p>但不够灵活</p><ul><li>在⽂件创建时就需要知道⽂件的⼤⼩，之后如何增加和减少⽂件的⼤⼩也是麻烦</li><li>有外部碎⽚：需要进⾏收缩操作（compaction）来减少这种碎⽚</li></ul><p><strong>基于链表的分配</strong><br>每个⽂件是⼀个数据块的链表</p><ul><li>每个数据块包含指向下⼀个块的指针</li></ul><p><img src="2025060852.png" alt=""></p><p><strong>文件分配表 File Allocation Table FAT</strong><br>⼀个基于链表分配的变种，其将所有的指针放到同⼀个表格中</p><ul><li>对于每个磁盘数据块都有⼀个 FAT 的项</li><li>每个 FAT 项包含⼀个指向下⼀个 FAT 项的指针，或者⽂件终⽌符号</li><li>对于随机访问的操作，只需要访问该 FAT 表即可，该表可以直接存储进主存从⽽减少需要 I/O 的次数</li></ul><p><img src="2025060816.png" alt=""></p><p><strong>索引式分配 Indexed Allocation</strong><br><img src="2025060841-1.png" alt=""></p><p><strong>多级索引</strong><br>使⽤间接指针：可以将索引块中的指针指向⼀个由指针组成的数据块，其中每个指针再指向数据块</p><ul><li>⼀个索引块中可以赋予固定数量的直接指针 （指向数据块）和固定数量的间接指针</li><li>此时索引的结构变成了⼀个树（⾮平衡）</li><li>对于⼩⽂件和⼤⽂件都能很好⽀持</li><li>⼀般有 2 级和 3 级的⾮间接指针</li></ul><p><img src="2025060878.png" alt=""><br><img src="2025060879-1.png" alt=""></p><h3 id="目录组织">目录组织</h3><p>⽬录提供了找到⽂件名和其在磁盘上的数据块的映射信息⟨ ⽂件名, ⽂件索引⟩</p><ul><li>当需要打开⼀个⽂件时，OS ⾸先找到路径名，并根据路径名找到磁盘上的⽬录项</li><li>⽬录项提供了该⽂件对应的磁盘数据块，可以是<ul><li>整个⽂件所在的磁盘地址</li><li>第⼀个数据块的编号</li><li>⽂件的元信息 inode 号</li></ul></li></ul><p>如果⽂件名的⻓度过于⻓？</p><ul><li>给⽂件名的⻓度设置⼀个上限，使其最多含有 N 个字符<ul><li>每个⽂件的⽂件名项都是⼀个固定⼤⼩的字符数组</li></ul></li><li>简单，但是问题是，不是每个⽂件名都很⻓<ul><li>对于那些⼤部分拥有短的名字的⽂件，会造成⼤量的浪费</li></ul></li></ul><p><img src="2025060869-1.png" alt=""><br><img src="2025060875.png" alt=""></p><p>给定⽬录实现下的⽂件查找：</p><ul><li>如果⽬录存储的是 ⟨ file name, inode number ⟩ 的列表<ul><li>从头到尾开始搜索列表中的项</li><li>如果⽬录中的项很少没问题（对于现实中的⼤部分情况都很好），但如果⼀个⽬录中出现⼤量的项， 这个做法就很低效了</li></ul></li><li>解决⽅案：增加⼀个额外的 hash 表 (以 filename 为 key)<ul><li>使⽤链表来处理碰撞</li><li>更快的查询，但也需要更为复杂的管理</li></ul></li><li>此外，⽆论哪种⽅案，都可以利⽤ cache 来进⼀步加快搜索</li></ul><h3 id="空闲空间管理">空闲空间管理</h3><p>如何管理空闲的 inode 块和数据块？</p><ul><li>每当⽂件和⽬录需要被创建的时候需要找到空闲的空间存储这些数据</li><li>两种常⻅的管理结构：Bitmap（位图） 和空闲列表</li><li>也有采⽤更复杂结构如 B 树</li></ul><p><strong>Bitmap</strong><br><img src="2025060809-1.png" alt=""></p><p><strong>空闲列表</strong><br><img src="2025060831.png" alt=""></p><p><em>块大小</em><br>磁盘的块到底多⼤合适？</p><ul><li>过于⼤: 由于⼤部分都是⼩⽂件，磁盘会产⽣⼤量的浪费（内部碎⽚）</li><li>过于⼩: 读⽂件时会产⽣⼤量的寻道和延迟 (每个⽂件都会包含⼤量的块)</li></ul><p>历史上⽂件系统基本都选择 1~4 KB 的块⼤⼩</p><ul><li>当磁盘超过 1TB（现在已经很普遍），块⼤⼩设置为 64 KB 更为合适</li><li>磁盘空间如今已经很少会出现不⾜的状</li></ul><p><img src="2025060847.png" alt=""></p><p><strong>读文件</strong><br>假设⼀个⽂件系统被挂载，其中超级块在内存中, 但其他 (inodes, directories) 都在磁盘上<br>读⼀个⽂件⾸先需要打开这个⽂件：</p><ul><li>⾸先需要循着路径名找到相应的 inode</li><li>读取这个 inode，做权限检验，合法就返回⽂件描述符（对应的操作会反映到打开⽂件表中）</li></ul><p>然后对每个发起的读操作：</p><ul><li>读相应的 inode</li><li>读相应的数据块</li><li>写 inode (更新上次访问时间)</li><li>更新内存中打开⽂件表中的 offset</li></ul><p><img src="2025060882.png" alt=""></p><p><strong>写文件</strong><br>⾸先打开⽂件（过程与读⽂件类似）<br>但与读⽂件不⼀样的地⽅在于，写⽂件可能需要<em>分配⼀个新的数据块</em> (除⾮ 覆写旧数据块)</p><ul><li>读和写空闲数据块结构⽐如 bitmap (找到⼀个空闲的数据块标记为占有)</li><li>读和写⽂件的 inode (更新 inode 表中这个新数据块的位置)</li><li>写这个新的数据块</li></ul><p>当<em>创建⼀个⽂件</em>时需要更多的操作</p><ul><li>读和写空闲数据块结构⽐如 bitmap (找到⼀个空闲的数据块标记为占有)</li><li>读和写⽂件的 inode (初始化)</li><li>读和写⽬录的数据 (将⽂件名和其对应 inode 项写⼊)</li><li>读和写⽬录的 inode (更新⽬录)</li><li>如果⽬录需要增加容量来添加这个新的项，需要更多的 I/O (访问空闲数据结构，增加新的⽬录的数据块)</li></ul><p><img src="2025060855.png" alt=""></p><h3 id="文件系统性能">文件系统性能</h3><p>⼀个⽂件系统如何减少 I/O 带来的开销?</p><ul><li>访问磁盘 (I/O 操作) ⽐访问主存慢得多</li><li>Read-Modify-Write 过程<ul><li>⼏乎所有的⽂件系统都将⽂件分割成固定⼤⼩的块</li><li>将磁盘块复制到主存以访问其内容，并只有发⽣修改才将其写回</li></ul></li></ul><p><strong>缓存和缓冲（Caching and Buffering）</strong><br>显然⽆法将磁盘的所有块都放进内存，应该只放⼊需要频繁访问的块（类似缓存机制），这样就可以读取该块就可以极⼤的减少 I/O 的操作了</p><ul><li>利⽤哈希表来记录⼀个给定块是否在主存⾥</li><li>如果 cache 满了就需要移除⼀些块 (类似⻚⾯替换机制，⽐如 LRU)</li></ul><p>现代系统将虚拟内存⻚和⽂件系统缓存⻚集成到统⼀的⻚缓存中</p><ul><li>这样，内存可以在虚拟内存和⽂件系统之间更灵活地分配</li></ul><p><em>预取</em>: 可以将需要的数据块提前存⼊缓存中来提⾼缓存击中率</p><ul><li>很多读⽂件操作是线性的，这时预取的效率很⾼</li><li>但如果是随机访问，预取则⽆效</li><li>因此可能会造成加载⽆⽤的数据块和替换需要⽤的数据块这样低效的操作</li><li>⽂件系统可以追踪每个打开⽂件的访问形式</li></ul><p>读的 I/O 可以通过的充分的缓存来避免，但还是需要写磁盘的 I/O 来达成⽂件数据的持久性</p><ul><li><em>写缓冲</em>（Buffering）<ul><li>可以延迟写操作：⽂件系统可以<em>批处理</em>⼀些 I/O 写的操作（避免多次频繁的少量的 I/O 的操作，⽐如可以合并 bitmap 的很多位运算）</li><li>缓冲写操作，⽂件系统还可以合理的调度 I/O 来提⾼性能（⽐如让相近的数据块⼀并写⼊）</li><li>有些写操作甚⾄可以完全避免 (创建了⼀个⽂件然后删除)</li><li>但更好的性能也会带来潜在的不⼀致性：⼀旦发⽣ crash, <em>没有提交到磁盘的写操作会丢失</em><ul><li>⼀般每隔⼀段时间会写缓冲，时间间隔⼤⼩是⼀个 trade-off</li></ul></li></ul></li></ul><p><strong>快速文件系统 Fast File System FFS</strong><br><img src="2025060873.png" alt=""><br>在 FFS 中实现数据局部性（data locality）：将相关内容放在⼀起（将不相关内容分开）<br>对于⽂件：</p><ul><li>将数据块分配到与其 inode 相同的组中</li><li>将同⼀⽬录中的所有⽂件放置在该⽬录所在的组中</li></ul><p>对于⽬录：</p><ul><li>找到已分配⽬录数量较少（以平衡各组间的⽬录）且空闲 inode 数量较多（以便能分配 ⼤量⽂件）的组。</li><li>将⽬录数据和 inode 放在该组中</li></ul><h2 id="文件系统可靠性">文件系统可靠性</h2><h3 id="一致性">一致性</h3><p>崩溃⼀致性问题（Crash-consistency problem）：崩溃故障可以在任何时刻发⽣（例如，电源故障），⽂件系统可能会受到这种崩溃的影响</p><ul><li>对⽂件系统的更新操作需要多次 I/O 操作（更新多个数据结构）<ul><li>崩溃时，某些操作可能完成，⽽某些操作可能丢失</li></ul></li><li>这会导致⽂件系统处于不⼀致的状态</li></ul><p>当需要为⼀个⽂件增加⼀个数据时</p><ul><li>需要写⼀个新的数据块</li><li>需要写这个⽂件的 inode</li><li>需要写数据的 bitmap</li></ul><p><img src="2025060896-1.png" alt=""><br><img src="2025060889.png" alt=""></p><p>理想的方案：</p><ul><li>⼀个⽂件系统原⼦的从⼀个⼀致的状态进⼊另⼀个⼀致的状态</li><li>但磁盘只能⽀持⼀个写操作是原⼦的（⽽两个状态之间的迁移往往涉及多个写操作）</li></ul><p>实际的⽅案</p><ul><li>进⾏⽂件⼀致性检查（File System Consistency Check, fsck）</li><li>⽇志化</li></ul><h3 id="进行文件一致性检查">进行文件一致性检查</h3><p>让不⼀致发⽣，并在事后修复（在重启期间）<br><strong>fsck</strong>：在挂载⽂件系统之前运⾏（fsck 运⾏期间需要没有相关的⽂件系统活动），确保⽂件系统元数据在内部⼀致</p><p>完整性检查超级块</p><ul><li>⽂件系统⼤⼩是否⼤于已分配的总块数？</li><li>发现不⼀致时，使⽤超级块的另⼀份副本</li></ul><p>检查空闲块和位图的有效性</p><ul><li>扫描 inode 以确定哪些块已分配<ul><li>⽣成数据位图的正确版本</li><li>发现不⼀致时，覆盖位图（信任 inode）</li></ul></li><li>进行类似的检查以更新 inode 位图</li></ul><p>检查 inode 是否未损坏</p><ul><li>例如，每个 inode 应该有⼀个有效的类型字段（普通⽂件、⽬录、符号链接等）</li><li>如果问题⽆法修复，清除 inode 并更新 inode 位图</li></ul><p>检查 inode 链接</p><ul><li>扫描整个⽬录树，计算每个⽂件和⽬录的硬链接数</li><li>发现不⼀致时，修正 inode 中的链接计数</li><li>如果没有⽬录引⽤已分配的 inode，将其移动到名为 lost+found 的⽬录中</li></ul><p>检查重复的指针和损坏的块</p><ul><li>两个 inode 如果指向同⼀个数据块<ul><li>清除⼀个 inode (如果其明显损坏), 或者复制那个数据块 (使的每个 inode 指向不同的数据块（内容拷⻉）)</li></ul></li><li>如果⼀个 inode 指向分区外的数据块<ul><li>直接移除这个 inode</li></ul></li></ul><p>检查⽬录</p><ul><li>检查 . 和 … 是否是第⼀和第⼆个项</li><li>检查其中的每个 inode 所指向的地⽅是否已经被分配</li></ul><p><img src="2025060883-1.png" alt=""></p><h3 id="日志">日志</h3><p>基本思路：预写⽇志（Write-ahead logging）或⽇志（Journaling），该思路借鉴⾃数据库系统</p><ul><li>在覆盖结构之前，先写⼀个⼩⽇志（存储在磁盘上），描述将要做的事情</li><li>如果在更新过程中发⽣故障，我们可以在重启时读取⽇志并重试<ul><li>在写⼊意图之前崩溃：没有操作</li><li>在写⼊意图之后崩溃：重做该操作</li></ul></li><li>在更新期间增加的⼀些⼯作量，可以⼤⼤减少恢复期间所需的⼯作量<ul><li>⽆需扫描整个磁盘，只需要查看奔溃前的⽇志中的记录即可</li></ul></li><li>被许多⽂件系统使⽤，包括 Linux 的 ext3、ext4 和 Windows 的 NTFS</li></ul><p>⽂件的更新被作为 <em>事务</em>（transaction）保存在⽇志中（⽇志写⼊）<br><img src="2025060811.png" alt=""></p><p>⼀旦事务安全地写⼊磁盘，将更新内容（元数据和数据）写⼊其最终的磁盘位置（checkpoint，检查点）</p><ul><li>将 I[v2]、B[v2] 和 Db 写⼊它们的磁盘位置</li></ul><p>问题：<br><img src="2025060872.png" alt=""><br>解决方案：<br><img src="2025060837.png" alt=""></p><p>当需要从崩溃中恢复时，⽂件系统会扫描⽇志并查找已提交到磁盘的事务：<br>如果在⽇志提交之前发⽣崩溃</p><ul><li>则忽略待处理的更新</li></ul><p>如果在⽇志提交之后但在检查点之前发⽣崩溃</p><ul><li>则按顺序重放已提交的事务（重做⽇志）</li><li>可能会有些写冗余（因为有些⽇志可能已经正确写⼊，会被重新再写⼀ 次），但问题不⼤，因为崩溃发⽣不频繁</li></ul><p>⽇志在提交之后其实就不需要保留了<br>有限⽇志：将⽇志视为循环数据结构（bounded buffer），反复重⽤（circular log）</p><ul><li>⼀旦事务<em>被检查点记录</em>，释放它在⽇志中占⽤的空间</li><li>⽤⼀个⽇志超级块记录哪些事务尚未被检查点记录</li></ul><p><img src="2025060886-4.png" alt=""></p><h2 id="日志结构文件系统">日志结构文件系统</h2><p>当数据发⽣变化时，不必回去编辑原始数据，只需将新副本存储在末尾（类似磁带）。</p><ul><li>在最简单的情况下，假设容量⽆限</li></ul><p>日志⽂件系统（LFS） 仍然有 inode 和数据块，只是将它们放置⽅式不同。<br>总是写到末尾：例如，当写⼊⼀个⼩⽂件时<br><img src="2025060876.png" alt=""></p><p>⼀如既往，我们先写⼊数据块，然后再写⼊ inode，以最⼩化中断/崩溃的影响。<br><img src="2025060839-1.png" alt=""><br><img src="2025060840.png" alt=""><br><img src="2025060859-1.png" alt=""><br><img src="2025060873-1.png" alt=""></p><p>指向新的版本</p><ul><li>旧数据仍然存在于磁盘上，但内存中的 i-map 和其磁盘上的持久副本不再引⽤它</li><li>如果磁盘空间是⽆限的，那就⾜够了</li><li>此外，如果我们保存旧版本的检查点区域，它还可以⽤来查看⽂件系统的旧快照<ul><li>能够保留旧快照的⽂件系统被称为版本化⽂件系统（a versioning file system）</li></ul></li></ul><p>磁盘容量是有上限的</p><ul><li>受限于磁盘容量，不可能永远顺序写⼊， 不能⽆限期地保留旧版本的数据。</li><li>最终需要对具有可⽤空间的段进⾏垃圾回收。<ul><li>实际上，最好是释放整个段（如果都是垃圾）</li><li>但如果遇到部分填充的段，那么可以先释放完整的段，并在⽇志末尾重新写⼊ ⼀个压缩版本的段（只写⼊垃圾收集器留下的“空洞”）</li><li>垃圾收集器定期扫描磁盘，可能在空闲时进⾏</li><li>但是垃圾收集器如何决定哪些块是活动的，哪些是⽆⽤的呢</li></ul></li></ul><p><img src="2025060822.png" alt=""></p><h2 id="总结">总结</h2><p>两个关键抽象：⽂件和⽬录</p><ul><li>元数据信息：inode</li><li>⽂件描述符 File Descriptor, 打开⽂件表</li><li>软/硬链接</li></ul><p>⽂件实现：</p><ul><li>布局（超级块、空闲位图、inode 块、数据块）</li><li>性能（FFS、缓存和缓冲）、⼀致性检查、⽇志</li><li>⽇志结构⽂件系统</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-13持久化-设备管理</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13%E6%8C%81%E4%B9%85%E5%8C%96-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13%E6%8C%81%E4%B9%85%E5%8C%96-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>I/O 设备分类</p><ul><li>块设备（Block devices）<ul><li>以固定⼤⼩的块存储信息</li><li>传输单位为整个块</li></ul></li><li>字符设备 (Character devices)<ul><li>传递或接受字符流</li><li>不可寻址，没有任何寻址操作</li></ul></li></ul><p><strong>一个典型设备</strong><br>一个设备有两个重要组成部分</p><ul><li>它向系统其余部分呈现的硬件接口（允许操作系统控制其运行）</li><li>它的内部结构（具体实现）</li></ul><p>设备接口由几个寄存器组成</p><ul><li>状态寄存器：读取以查看设备当前状态</li><li>命令寄存器：指示设备执行特定任务</li><li>数据寄存器：将数据传递给设备或从设备获取数据</li></ul><p><strong>CPU 和设备的通信</strong><br>CPU 与控制器交互</p><ul><li>除了⼀组可读写的寄存器外，可能包含⽤于请求队列等的内存</li></ul><p>处理器以两种方式访问寄存器</p><ul><li>端口映射 I/O</li><li>内存映射 I/O</li></ul><p><em>端口映射</em>：提供额外的 I/O 指令</p><ul><li>每个控制寄存器被分配一个 I/O 端口号</li><li>使用特殊的 I/O 指令</li><li>这些指令通常是特权指令</li></ul><p><em>内存映射</em>：</p><ul><li>将所有控制寄存器映射到内存空间中</li><li>每个控制寄存器被分配⼀个唯⼀的内存地址</li><li>为了访问特定的寄存器，操作系统发出⼀个 load 指令（读取）或 store 指令 （写⼊）该地址</li><li>然后硬件将 load/store 指令指向到设备⽽不是主存储器</li></ul><p><img src="2025060874.png" alt=""></p><p><em>获知设备通信状态</em><br>在发出与设备通信的指令后，操作系统需要知道以下情况：</p><ul><li>I/O 设备已完成⼀个操作</li><li>I/O 操作遇到了错误</li></ul><p>有两种获知状态的方法</p><ul><li>轮询 polling：操作系统定期检查设备特定的状态寄存器<ul><li>开销低（没有切换），但如果是低速的设备上会浪费 CPU 周期</li></ul></li><li>I/O 中断：设备在需要服务时生成中断<ul><li>不会浪费 CPU 周期，但开销高</li></ul></li><li>一般来说两种混合</li></ul><p><em>谁来控制数据传输命令</em></p><p>由 CPU 来控制，即 Programmed I/O</p><ul><li>直接通过处理器的 in/out 或 load/store 传输每个字节</li><li>优点：硬件简单，易于编程</li><li>消耗与数据⼤⼩成⽐例的处理器周期（因为每个数据的 in/out 都要⼀个指令）</li><li>此外，CPU 会⼀直接收到 interrupt，速度变慢</li></ul><p>由<em>直接内存访问</em>（Direct Memory Access, DMA）控制</p><ul><li>给控制器访问内存和总线的权限</li><li>要求它直接在内存和控制器之间传输数据块</li></ul><p><img src="2025060861.png" alt=""></p><p><em>关于专用和通用</em><br>计算机系统内部不只是有通⽤的 CPU</p><ul><li>“专⻔”负责 memcpy () 的 CPU：DMA</li><li>“专⻔”负责解析和显示图形的 CPU：GPU</li><li>很多设备都有⾃⼰的逻辑处理芯⽚（⽐如磁盘）</li><li>I/O 管理可以看成是中央芯⽚（CPU）和外部芯⽚的交流！</li></ul><p>为什么不是⼈⼿⼀个通⽤ CPU？</p><ul><li>因为代价！<ul><li>CPU 因为通⽤性增加了很多设计以及与之⽽来的功耗</li></ul></li><li>特定领域的任务不需要这么多通⽤性<ul><li>可以更加优化所需任务的指令（⽐如显卡中的并⾏计算部分）</li></ul></li></ul><h2 id="硬件抽象">硬件抽象</h2><p><em>设备抽象</em><br>设备驱动程序通常分为两部分：</p><ul><li>上半部分：在系统调⽤的调⽤路径中访问<ul><li>实现⼀组标准的、跨设备的调⽤，如 open ()、close ()、read ()、write ()、ioctl ()</li><li>这是内核与设备驱动程序的接⼝</li><li>上半部分将启动设备的 I/O 操作，可能会让线程休眠直到完成 (同步和异步 I/O!)</li></ul></li><li>下半部分：作为中断例程运行<ul><li>获取输⼊或传输下⼀块输出</li><li>如果 I/O 现在完成，可能会唤醒休眠的线程</li></ul></li></ul><h2 id="硬盘">硬盘</h2><p>将数据磁性地储存在与玻璃、陶瓷或铝等材料的旋转盘上粘合的薄⾦属膜上。<br><img src="2025060859.png" alt=""><br><img src="2025060812.png" alt=""></p><p><strong>磁盘读写</strong><br>磁道偏移（Track Skew）：确保在跨越磁道边界时能够正确处理顺序读取</p><ul><li>从⼀个磁道切换到另⼀个磁道时，磁盘需要时间重新定位磁头</li><li>如果没有这样的偏移，磁头会被移动到下⼀个磁道，但所需的下⼀个数据块已经旋转到磁头后⾯了（得重新转 ⼀圈才能读到）</li></ul><p>多区域（Multi-Zoned） 磁盘驱动器：</p><ul><li>外部磁道⽐内部磁道有更多的扇区</li><li>磁盘被组织成多个区域，每个区域是表⾯上⼀组连续的磁道</li><li>每个区域的每条磁道的扇区数相同</li></ul><p>现代磁盘⽀持逻辑块寻址（不考虑磁盘 ⼏何结构）<br><em>缓存（磁道缓冲区）</em>：⼀些⼩容量的内存（8 到 16 MB），⽤于存储从磁盘读取或写⼊到磁盘的数据。</p><ul><li>读取扇区时，会读取该磁道上的所有扇区。</li><li>写⼊时，有两种写⼊策略：当数据被放⼊缓存时（写回，write back）或数据实际写⼊磁盘后（直写, write through）才确认写⼊</li><li>缓冲区在磁盘的逻辑板上</li></ul><p><strong>磁头调度</strong></p><ul><li>由于 I/O 成本⾼，操作系统历来在决定发往磁盘的 I/O 顺序⽅⾯发挥了作 ⽤。</li><li>⾯对⼀组 I/O 请求，磁盘调度程序会检查这些请求并决定下⼀个调度哪个请求。<ul><li>⽬标：通过磁头调度来最⼩化磁头移动，从⽽最⼤化磁盘 I/O 吞吐量</li></ul></li></ul><p><em>FCFS</em><br>最简单的⽅法是先到先服务（FCFS），即按请求到达的顺序处理磁盘请求。</p><p>优点</p><ul><li>请求之间的公平性</li><li>按应⽤程序预期的顺序</li></ul><p>缺点</p><ul><li>到达的位置可能在磁盘上的随机点，导致较⻓的寻道时间。</li></ul><p><em>STF</em><br>Shortest Seek Time: 按磁道顺序排列 I/O 请求队列，优先处理最接近磁道的请求。</p><ul><li>最小化寻道时间<br>问题：饿死！ 如果有⼀连串持续不断的中间磁道请求， 那么最两端的磁道请求将得不到服务</li></ul><p><em>电梯算法 / 扫描算法 SCAN</em><br>简单地在磁盘上来回移动，按顺序跨磁道处理请求（像电梯⼀样运⾏）</p><ul><li>从磁盘的⼀端（从外轨到内轨或从内轨到外轨）的单次通过称为⼀次扫描。</li></ul><p>有多种变体可⽤：</p><ul><li>F-SCAN：在执⾏扫描时暂时冻结要处理的队列（避免远距离请求的饥饿）。</li><li>C-SCAN：只从外轨到内轨扫描，然后重置到外轨重新开始<ul><li>更平均的等待时间，即对内轨和外轨更公平</li></ul></li></ul><p><em>Shortest Positioning Time First (SPTF)</em><br><img src="2025060807.png" alt=""></p><p>过去的操作系统⾮常注重磁盘请求调度。<br>⽬前的做法是将许多请求发送到磁盘，让磁盘⾃⾏调度。如今的磁盘更智能，并且拥有较⼤的缓存。</p><ul><li>然⽽，操作系统⾄少可以假设相邻的扇区号在磁盘上也相邻，从⽽顺序访问会更快。</li></ul><p><strong>固态硬盘 Solid State Disks SSDs</strong></p><p>放电 (erase) 做不到 100% 放⼲净</p><ul><li>放电数千/数万次以后，就好像是 “充电” 状态了</li><li>Dead cell; “wear out”<ul><li>必须解决这个问题 SSD 才能实⽤</li></ul></li></ul><p><em>解决方案</em>：</p><ul><li>间接层<ul><li>在固态硬盘（SSD）中维护⼀个闪存转换层（FTL）。</li><li>将虚拟块编号（操作系统使⽤的）映射到物理⻚⾯编号（闪存存储控制器使⽤的）。<ul><li>现在可以⾃由重新定位数据，⽽⽆需操作系统知道。</li></ul></li></ul></li><li>写时复制<ul><li>当操作系统更新其数据时，不要覆盖⻚⾯（这样做很慢，需要先擦除⻚⾯，⽽擦除的效率很低，⽐写⼊低）。</li><li>相反，将新版本写⼊⼀个空闲⻚⾯。</li><li>更新 FTL 映射以指向新位置。</li></ul></li></ul><p>固态硬盘（SSD）控制器可以分配映射以在⻚⾯之间均衡⼯作负载</p><ul><li>均衡磨损（Wear Leveling）</li></ul><p>对旧版本⻚⾯应该怎么处理？</p><ul><li>在后台进⾏垃圾收集</li><li>擦除带有旧⻚⾯的块，将其添加到空闲列表</li></ul><p>新的问题：</p><ul><li>Copy-on-write 意味着旧的数据还在！<ul><li>logic block 被覆盖，physical block 依然存储了数据<ul><li>有研究发现实际的智能⼿机的⼀些被删除的数据之后仍然“存在”超过六个⽉</li></ul></li></ul></li><li>轻度格式化同样存在相同的问题</li></ul><h2 id="总结">总结</h2><p>操作系统同样利用抽象技术管理 I/O</p><ul><li>各种 drivers 就是为了实现统⼀的接⼝</li><li>另外⼀个视⻆：I/O 就是各个 CPU（通⽤和专⽤）的交流，drivers 就是解释器！</li></ul><p>硬盘</p><ul><li>磁盘和 SSD</li><li>各有优缺点</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-12虚拟化-内存管理(续)</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%BB%AD/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<p><strong>交换</strong><br>如果没有⾜够的空间来容纳所有进程怎么办？</p><ul><li>⼀个进程可以被暂时换出内存到后备存储</li><li>然后在需要继续执⾏时再换回内存</li><li>进程的总物理内存空间可以超过物理内存</li></ul><p>交换时间的主要部分是磁盘传输时间（与交换的内存量直接成正⽐）。</p><ul><li>系统维护⼀个就绪队列，⾥⾯是内存镜像在磁盘上的准备运⾏的进程。</li><li>如果要放到 CPU 上的下⼀个进程不在内存中，需要换出⼀个进程并换⼊⽬标进程, 这时上下⽂切换时间可能会⾮常⾼。<ul><li>⽐如⼀个 100MB 的进程交换到传输速率为 50MB/秒的硬盘上，那么交换出（或交换 ⼊）时间 = 2 秒</li></ul></li><li>如果进程正在等待 I/O 操作（I/O 缓冲区在进程的地址空间中）？<ul><li>交换会产⽣负⾯影响（I/O 失败或数据丢失）！⼀般涉及 I/O 操作的⻚需要被锁定在内存中，防⽌在操作完成前被换出。</li></ul></li></ul><p>标准交换在现代操作系统中不再使⽤，但变异版本很常⻅（例如，Linux 和 Windows）。</p><ul><li>交换通常是禁⽤的。</li><li>当分配的内存超过阈值（当可⽤内存极低时）才会启动交换。</li><li>⼀旦内存需求减少到低于阈值时，交换再次被禁⽤。</li></ul><p><img src="2025060871.png" alt=""></p><p>如果单个进程本身超过物理内存？</p><ul><li>计算机可以运⾏⾮常⼤的单个程序<ul><li>远远⼤于物理内存</li><li>只要“活跃”的占⽤内存量适合物理内存，就可以运行</li></ul></li><li>然⽽交换⽆法做到这⼀点<ul><li>⼀个想法：不是所有内容都需要同时加载进内存！</li></ul></li></ul><p><em>部分内存驻留</em></p><ul><li>程序中的错误处理代码不会在每次运⾏时都被使⽤<ul><li>因此不需要它在整个持续时间内占⽤内存</li></ul></li><li>数组可能分配得⽐所需要的⼤<ul><li><code>int players[MAX_INTEGER];</code></li></ul></li><li>程序地快速启动<ul><li>⽆需在运⾏之前加载整个程序</li></ul></li></ul><h2 id="虚拟内存">虚拟内存</h2><p>每个进程都有⼀个⼤地址空间的幻觉。<br>⽀持多个并发运⾏的进程使⽤⼤虚拟地址空间：只将常⽤的⻚⾯保留在内存中 （此时内存可以看成是所有 pages 的⼀个 cache）<br>具备“部分”加载程序的执⾏能⼒</p><ul><li>程序不再受物理内存限制（可以运⾏⽆法完全放⼊物理内存的程序）</li><li>每个程序在运⾏时占⽤更少的内存（可以同时运⾏更多的程序）</li><li>加载或交换程序到内存中所需的 I/O 更少（每个程序启动更快）</li></ul><p>⽤<em>存在/不存在位</em>（在⻚表项中）来跟踪哪些⻚⾯存在于物理内存中。</p><ul><li>当程序引⽤其地址空间的⼀部分时：<ul><li>如果⻚⾯在物理内存中，则直接进⾏地址转换</li><li>如果不在，则发⽣缺⻚异常（Page Fault），操作系统被调⽤来处理该异常：<ul><li>检测并将⻚⾯加载到内存中，然后重新执⾏指令 (引⽤该地址空间的指令)</li></ul></li></ul></li></ul><p><strong>缺页异常</strong></p><ul><li>CPU 控制流传递</li><li>提前注册缺⻚异常处理函数</li></ul><p><img src="2025060844.png" alt=""></p><p><em>具体流程</em></p><ol><li>硬件陷⼊内核，进⾏ Context-Switch（将程序计数器保存在栈上，保存通⽤寄存器和其他易失性信息。）</li><li>系统发现了这个事件是⼀个缺⻚异常，尝试确定所需的虚拟⻚⾯。</li><li>⼀旦知道引发缺⻚异常的虚拟地址，系统检查地址是否有效，并且保护是否与访问⼀致。</li><li>找到⼀个空闲（⼲净的）帧。<ol><li>如果没有空闲帧，则运⾏⻚⾯置换以选择⼀个 victim (受害者)。</li><li>如果所选帧是脏的，则将⻚⾯安排转移到磁盘，进⾏上下⽂切换，暂停引发异常的进程。</li></ol></li><li>⼀旦帧变为⼲净状态，系统查找所需⻚⾯的磁盘地址，并安排磁盘操作将其调⼊（引发缺⻚异常的进程仍处于暂停状态）</li><li>当磁盘中断指示⻚⾯已经到达时，更新⻚表，并将帧标记为正常状态</li><li>将引发缺⻚异常的指令恢复到其原始状态，并重置程序计数器</li><li>引发缺⻚异常的进程被调度，Context-Switch 回去</li></ol><p><em>性能</em>：</p><ul><li>处理缺⻚异常的三个主要活动：<ul><li>服务中断：⼀般只需要⼏百条指令</li><li>读取⻚⾯：需要⼤量时间</li><li>恢复进程：需要少量时间</li></ul></li><li>缺⻚错误率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>p</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 &lt;= p &lt;= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>：进程在内存中发现缺⻚异常的速率。</li><li>有效访问时间（Effective Access Time, EAT）:(1 − p) × 访存时间 + p × 缺⻚异常开销</li></ul><p><img src="2025060886-1.png" alt=""></p><p><img src="2025060823-1.png" alt=""></p><h2 id="页面置换">页面置换</h2><p><em>何时将页面调入内存</em></p><ul><li>按需分⻚（Demand Paging） - 出现缺⻚异常后进⾏调入⻚⾯<ul><li>最简单的⽅法</li><li>为了提⾼效率，调入是异步进⾏的：<ul><li>中断处理程序应快速响应 - 只需启动磁盘 I/O 并阻塞该进程，让其他进程运⾏。</li></ul></li></ul></li><li>预取 (Prefetching)<ul><li>猜测即将使⽤哪些⻚⾯，因此提前将其调⼊内存</li><li>往往是基于历史的缺⻚记录来预测</li></ul></li></ul><p><em>如果没有空闲的帧会发生什么</em></p><ul><li>⻚⾯置换：找到内存中的⼀个⻚⾯，但实际上并未使⽤，将其换出。<ul><li>选择⼀个受害者帧（victim frame）进⾏驱逐。</li><li>将所需的⻚⾯调⼊（新）空闲帧。</li></ul></li></ul><p><em>当一个页面必须被换出时</em></p><ul><li>更新⻚表：找到所有引⽤旧⻚⾯的⻚表项（因为帧可以共享），并将每个设置为不可⻅</li><li>移除任何 TLB 条⽬<ul><li>TLB 关机：在多处理器系统中，必须从所有处理器的 TLB 中消除 TLB 条⽬</li></ul></li><li>将⻚⾯写回磁盘（如果需要，⻚表项中的脏位）</li><li>重新启动引发陷阱的指令：（需要备份指令）</li></ul><p><em>如果不想将某些页面换出</em></p><ul><li>将⻚⾯固定到内存中以锁定</li><li>有时必须将⻚⾯锁定到内存中<ul><li>总是将（部分）内核⻚⾯放⼊物理内存中</li><li>⽤于从设备复制⽂件的⻚⾯必须锁定，以防⽌被选择⽤于驱逐（I/O）</li><li>⼀个低优先级的进程交换⼊⼀个⻚⾯，然后⼀个⾼优先级的进程抢占并请求⼀个新的帧？</li></ul></li><li>需要小心使用</li></ul><p><em>页面 buffering</em></p><ul><li>操作系统会等到内存完全满了吗？<ul><li>保留⼀组空闲帧（Buffering）以确保在需要时总有可⽤的帧在合适的时候</li></ul></li><li>此外有⼀个交换⻚⾯的守护进程（后台进程）定期运⾏（类似于调度程序）<ul><li>如果空闲物理帧的数量 &lt; “低⽔位标记”，则换出⼀些⻚⾯，直到数量达到&quot;⾼⽔位标记&quot;</li><li>系统会⼀次性换出许多⻚⾯，以从低⽔平达到⾼⽔平。<ul><li>这样做是因为将⼤块数据写⼊磁盘更有效（批量传输）</li><li>需要维护⼀个修改⻚⾯的列表，将⻚⾯写⼊其中并设置为⾮脏（Linux 中的 pdflush）</li></ul></li></ul></li></ul><p>⻚⾯交换的守护进程可以以低优先级调度</p><ul><li>利⽤空闲时间准备未来的⼯作</li></ul><p>Linux 交换守护进程是⼀个名为 kswapd 的进程</p><p><strong>页面置换策略</strong><br>哪个帧应该被替换？<br>⽬标是实现最低的缺⻚异常率（尽量减少从磁盘获取⻚⾯的次数）。</p><ul><li>如果选择⼀个不常被使⽤的⻚⾯，系统性能会更好。</li><li>如果删除⼀个频繁使⽤的⻚⾯，它可能很快就需要被重新调⼊。</li></ul><h3 id="First-In-First-Out-FIFO">First In First Out FIFO</h3><p><img src="2025060826.png" alt=""></p><p>Belady 异常：增加帧数反⽽可能会降低命中率（帧数越少，缺⻚异常越少）</p><p><img src="2025060877.png" alt=""></p><p>Belady’s Anomaly 会发⽣在任何⻚⾯替换算法中（⽐如随机替换），只要它不遵循“栈算法”属性（stack algorithm property）。</p><ul><li>之后的 LRU（最近最少使⽤）和 Optimal（最佳）算法始终遵循栈算法属性，因此它们永远不会受到 Belady’s Anomaly 的影响。</li></ul><p>栈算法属性确保当⻚⾯帧数量增加时，先前存在的⻚⾯集合始终是当⻚⾯帧更多时存在的⻚⾯集合的⼦集。换句话说，随着⻚⾯帧数的增加，先前存在的⻚ ⾯应始终保留在内存中。</p><ul><li>如果没有这个性质，则可能会导致先前存在于内存中但由于增加⻚⾯数反⽽ 被删除这个⻚⾯，如果正好这个⻚⾯是⼀个需要频繁使⽤的⻚⾯，那么…</li></ul><p><img src="2025060864.png" alt=""></p><h3 id="Least-Recently-Used-LRU">Least Recently Used LRU</h3><p>替换那些在最⻓时间内没有被使⽤的⻚⾯</p><ul><li>使⽤历史⽽不是未来：很⻓时间没有被使⽤的⻚⾯可能会保持⻓时间未使⽤</li><li>基于局部性原理</li></ul><p>为了跟踪哪些⻚⾯最近最少被使⽤（将每个⻚⾯的最后⼀次使⽤时间与之关联），操作系统必须在每次内存引⽤时进⾏⼀些计时⼯作。<br>计数器实现</p><ul><li>每个⻚⾯都有⼀个对应的计数器项。</li><li>每次⻚⾯被引⽤时，通过硬件将时钟寄存器的值复制到计数器中。</li><li>当需要更换⻚⾯时，查看计数器以找到最⼩的值</li></ul><p>-&gt;开销太大</p><h3 id="近似-LRU">近似 LRU</h3><p>通过引⽤位来近似 LRU（即⼆次机会算法，Second Chance）：寻找⼀个在最近的时钟周期内没有被引⽤的⽼⻚⾯。</p><ul><li>系统中每个⻚⾯有⼀个引⽤位（R）。</li><li>每当引⽤⻚⾯（即读取或写⼊），引⽤位被设置为 1（由硬件完成）。</li><li>如果要被替换的⻚⾯：<ul><li>R = 1：将引⽤位设置为 0；将其放在 FIFO 队列的末尾；并检查下⼀个⻚⾯。</li><li>R = 0：替换它。</li></ul></li><li>如果所有⻚⾯都被引⽤，那么第⼆次机会等于 FIFO。</li></ul><p><em>二次机会算法</em><br><img src="2025060886-2.png" alt=""></p><p><em>Not Recently Used NRU 算法</em><br><img src="2025060894.png" alt=""></p><p><strong>抖动</strong><br><img src="2025060810.png" alt=""><br><img src="2025060819.png" alt=""></p><p>抖动（也叫颠簸）：⼀个进程花费所有时间在⻚⾯间进⾏交换（⼤多数引⽤ 导致缺⻚异常）</p><p><strong>局部性原理</strong></p><ul><li>时间局部性（Temporal locality）：相同的内存位置在不久的将来会再次被访问。</li><li>空间局部性（Spatial locality）：未来将会访问附近的内存位置。</li><li>当⼀个进程执⾏时，它会从⼀个局部转移到另⼀个局部</li></ul><p><strong>工具集 Working Set 模型</strong><br>⼯作集（Working Set）：</p><ul><li>其在时间段 (t-x, t) 内使⽤的内存⻚集合也被视为其在未来 (下⼀个 x 时间内) 会访问的⻚集</li><li>如果整个⼯作集都在内存中，那么进程将运⾏⽽不会引起太多缺⻚异常，直到它进⼊另⼀个执⾏阶段。</li><li>如果可⽤内存太⼩，⽆法容纳整个⼯作集，则会发⽣抖动。</li></ul><p>All-or-nothing 模型</p><ul><li>进程⼯作集要不都在内存中，否则全都换出</li><li>需要跟踪每个进程的⼯作集，并确保在运⾏之前将其加载到内存中。</li><li>⼤⼤降低缺⻚异常率</li></ul><p><img src="2025060879.png" alt=""></p><p><em>本地和全局策略</em><br>替换页帧是从全局（所有进程中）还是本地（只挑自己的页帧）？<br>本地⻚⾯置换：每个进程从其分配的帧集中选择受害者</p><ul><li>每个进程的帧数固定分配</li><li>每个进程的性能更加⼀致</li><li>但可能导致内存利⽤不⾜</li></ul><p>全局⻚⾯置换：从分配给任何进程的帧中选择受害者</p><ul><li>每个进程的帧数可变</li><li>吞吐量更⼤，因此更为普遍</li></ul><p><strong>帧分配</strong><br>采⽤全局⻚⾯置换时，操作系统必须不断决定为每个进程分配的⻚⾯帧数：</p><ul><li>平均分配：为每个进程分配相等的份额。</li><li>⽐例分配：根据进程⼤⼩进⾏分配（需要为每个进程分配⼀定数量的帧）。</li><li>按照优先级分配（优先级⾼的）</li></ul><p>这些静态的帧数分配⽆法解决不断变化的动态需求<br><img src="2025060866-1.png" alt=""></p><h2 id="Put-it-all-together">Put it all together</h2><p><strong>操作系统对分页的支持</strong></p><ul><li>进程创建<ul><li>确定程序和数据的⼤⼩并创建⻚表</li><li>为⻚表分配空间并初始化</li><li>为磁盘上的交换区域分配空间并初始化</li><li>在进程表中记录有关⻚表和交换空间的信息</li></ul></li><li>进程执行<ul><li>为新进程重置内存管理单元（⻚表基址寄存器）</li><li>上下⽂切换：清除 TLB（除⾮它是带有标记的）</li><li>可选地，将进程的⼀些或所有⻚⾯调⼊</li></ul></li><li>⻚⾯守护进程（Page Daemon）<ul><li>⼤部分时间处于休眠状态，但定期唤醒以检查内存状态，并主动准备待驱逐的⻚⾯</li></ul></li><li>缺⻚异常<ul><li>找到所需的⻚，并在磁盘上定位该⻚</li><li>找到⼀个可⽤的物理⻚帧来放置新⻚帧（必要时替换旧⻚帧）</li><li>将所需的⻚⾯读⼊该物理⻚帧</li><li>备份程序计数器以再次执⾏指令</li></ul></li><li>进程终⽌<ul><li>释放⻚表、⻚帧和交换空间</li><li>共享⻚帧只能在使⽤它们的最后⼀个进程终⽌时释放</li></ul></li></ul><p>程序优化</p><ul><li>局部性取决于数据结构<ul><li>数字鼓励顺序访问<ul><li>多次引用同一页</li><li>可预测的访问下一个页面</li></ul></li></ul></li><li>编译器和链接器也能帮忙<ul><li>不要把一个函数分散到两页上</li></ul></li></ul><h2 id="总结">总结</h2><p>内存的抽象</p><ul><li>屏蔽物理的局限（无线空间、连续、独享）</li></ul><p>实现机制：地址翻译</p><ul><li>需要硬件和 OS 配合</li></ul><p>底层内存的管理：连续分配、分段、分页</p><ul><li>利用 TLB 缓存</li></ul><p>实现虚拟内存的工程问题</p><ul><li>换页、工具集</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-11虚拟化-内存管理</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11%E8%99%9A%E6%8B%9F%E5%8C%96-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>物理内存：没有其他意义，只是存储（易失）运⾏信息的⼀个物理介质</p><ul><li>连续字节/字（Byte）的数组，每⾏都有⾃⼰的地址（ 位地址总共有个字节）</li><li>通过地址可以写/读相应的字节</li><li>地址和数据分别通过地址总线和数据总线进⾏传播</li></ul><p><strong>保护</strong><br>有了进程抽象，内存就有了“语义”</p><ul><li>其代表了当前进程的“状态”！</li><li>⽽这个“状态”应该遵循状态机（即进程）的规约⽽改变<ul><li>违背规约就会出现“undefined state”， 从⽽导致“undefined behavior”, 因此作为状态机的管理者—操作系统，必须提供出现违背规约之后的保护</li></ul></li></ul><p>哪些“状态”的改变操作是⾮法的呢？</p><ul><li>修改别的状态机的状态！<ul><li>需要界定状态机的<em>边界</em>（哪些内存是⾃⼰的，哪些是别的状态机的）</li></ul></li><li>增加状态机的⼤⼩时，占⽤的额外空间还处于“有⽤”状态<ul><li>我们只能申请“空闲”的内存来增加状态机的⼤⼩，⽽不能使⽤尚被占⽤的空间 （⽆论是被别的进程还是⾃⼰占⽤），因此得维护什么是“<em>空闲</em>”内存</li></ul></li><li>不遵守状态机的内部状态的读、写权限<ul><li>需要标记内存块的<em>权限</em>，并且能 assert 相应的读写是否符合权限</li></ul></li></ul><p><em>使用物理地址的缺点</em></p><ul><li>物理地址对应⽤是可知的，导致：<ul><li>⼀个应⽤会因其他应⽤的加载⽽受到影响 (loader 加载器压⼒骤增)</li><li>⼀个应⽤可通过⾃身的内存地址，猜测出其他应⽤的加载位置</li></ul></li><li>是否可以让应⽤看不⻅物理地址？<ul><li>“看不⻅”，指应⽤对物理地址不可知</li><li>⼀个进程不⽤关⼼其他进程占了什么地址，不受其他进程的影响</li><li>看不⻅其他进程的信息，带来更强的隔离和保护能⼒</li></ul></li></ul><p>—&gt;</p><p><em>虚拟内存抽象</em></p><p>以虚拟内存抽象为核⼼的内存管理</p><ul><li>CPU:⽀持虚拟内存功能，新增了虚拟地址空间（通过 Memory Management Unit, MMU 单元）</li><li>操作系统: 配置并使能虚拟内存机制</li><li>所有软件: 均使⽤虚拟地址，⽆法直接访问物理地址</li></ul><p>虚拟/逻辑地址（ Virtual/Logical Address）</p><ul><li>虚拟内存抽象下，程序使⽤虚拟地址访问主存<ul><li>虚拟地址会被硬件&quot;⾃动地&quot;翻译成物理地址</li></ul></li><li>每个应⽤程序拥有独⽴的虚拟地址空间<ul><li>应⽤程序认为⾃⼰独占整个内存 (透明性)</li><li>应⽤程序不再看到物理地址</li><li>应⽤加载时不⽤再为地址增加⼀个偏移量</li></ul></li></ul><p><strong>地址翻译</strong><br>翻译就是⼀个函数 : 其将 ⟨pid, virtual address⟩ 映射到 physical address</p><p>优点，可以很⾃然地提供：</p><ul><li>保护：让不同的进程映射到不同的区域即可（即两个进程的映射函数的值域不相交）</li><li>重定位：进程被映射到的物理地址可以在运⾏时不断变化（运⾏时，不是编译时，因此是动态重定位</li><li>数据共享：将不同进程的不同虚拟地址映射到同⼀个物理地址</li><li>连续空间假象：虚拟地址中的连续地址空间（编程友好），映射到物理内存可以不必连续</li></ul><h2 id="连续内存分配">连续内存分配</h2><p>最简单的内存分配⽅式，进程（包括操作系统内核）被分配⼀个连续的物理内存地址<br>利⽤基址和界限机制隔离⽤户进程之间的地址空间，以及防⽌⽤户进程修改操作系统的代码和数据<br>多个进程时需要将物理内存进⾏分割，每个进程占据⼀个连续的物理内存分区，有两种<em>分割⽅式</em></p><ul><li><em>固定分区</em>：物理内存⼀开始就被分为“固定”⼤⼩的区域，各个区域的⼤⼩可以相同，也可以不同，⼀个进程选择⼀个空闲区域进⾏分配</li><li><em>可变分区</em>：物理内存区域⼤⼩和数量是可变的，根据进程的具体需要分配相应的空间<ul><li>需要维护⼀个空闲的内存集合，开始是整个巨⼤的空间，但随着进程的分配和回收，内存会存在很多⼤⼩不⼀的空闲的“孔”</li></ul></li></ul><p>固定分区的问题：如果⼀个进程所需要的空间⾮常⼤，这种固定分区就不适⽤了</p><ul><li>此外，进程的 size 各种各样，但只能选择⼀个分区存放，这个分区⼤于进程的部分就是⼀个内部碎⽚（internal fragmentation），其⽆法被其他进程占 ⽤，⾃⼰也不⽤</li><li>此外，固定的分区数也限制了可以同时放⼊内存的进程数</li></ul><p>可变分区：可以⽀持<em>动态的按需分配</em>空间</p><ul><li>当⼀个进程需要加载到内存时，操作系统从⼀个⾜够⼤的空闲块分配内存（多了的部分进⾏分割（splitting）为剩余的空闲块）</li><li>当进程终⽌时释放其分区，并且与相邻的空闲分区合并（合并， coalescing）</li></ul><p>鉴于⼤多数进程在运⾏时会增⻓，在加载进程时会分配⼀些<em>额外的内存</em>。<br>此外，如果给进程所分配的区域⽤完，那么该进程将可能：</p><ul><li>被移动到⼀个有⾜够空间的空闲区域中</li><li>被交换（Swap）出内存（⾄磁盘），直到能够创建⼀个⾜ 够⼤的空洞</li><li>或者直接被终⽌</li></ul><h3 id="碎片">碎片</h3><p>指⽆法被分配的未使 ⽤内存</p><ul><li>外部碎⽚（空洞）：由于分散的⼩的不连续的空闲空间导致的内存浪费，发⽣在分区之间， 通常是由于进程的不断加载和释放造成</li><li>内部碎⽚：由于分区⼤⼩和加载的进程⼤⼩之间的差异（即进程⼩于分配的分区）导致的内存浪费，发⽣在分区内</li></ul><p>外部碎片的处理方法：</p><ul><li>进程终⽌或暂时交换出磁盘，可以释放内存，可能会合并⼀些碎⽚形成⼤的可分配区域</li><li>通过紧缩（compaction）减少外部碎⽚化<ul><li>重排内存内容以将所有空闲内存放在⼀起</li><li>时间复杂度较⾼（⼀般在系统实在没有内存的情况下才会做，内存分配 slow path 的⼀部分）</li></ul></li></ul><h3 id="空闲内存管理">空闲内存管理</h3><p>为了实现动态可变分区内存分配，操作系统应维护以下信息：</p><ul><li>已分配的分区</li><li>空闲的分区（空洞）</li></ul><p>⼀种简单的办法：Bitmap</p><ul><li>内存被划分为分配单元（⼏字节到⼏千字节）</li><li>每个分配单元对应位图中的⼀位，如果该单元空闲则该位为 0，如果被占⽤则该位为 1（或反过来）</li></ul><p>⼀个更加常⽤的做法：空闲内存链表<br>我们还需要<em>跟踪已分配区域的⼤⼩</em> ‣ 这样 <code>free (*p)</code> 时才能正确的返回⼀个正确的空闲结点</p><ul><li>⽅法：每次多 malloc ⼀点空间记录元信息</li></ul><h3 id="基本分配策略">基本分配策略</h3><p>不同的策略会影响分配和回收的性能和有效性（⽐如碎⽚数量）</p><ul><li>Best-fit：分配最⼩的⾜够⼤的空闲区域（尽可能物尽其⽤）, 需要遍历整个列表<ul><li>但可能导致产⽣微⼩且⽆⽤的外部碎⽚</li></ul></li><li>Worst-fit：分配最⼤的空闲区域<ul><li>剩余的部分最⼤，可以为其他进程所占⽤，⽽不是形成碎⽚，但同样遍历整个列表</li></ul></li><li>First-fit：分配第⼀个⾜够⼤的空闲区域（尽可能少搜索）</li><li>Next-fit：跟踪上次适配的位置，并从上次搜索结束的地⽅开始搜索 （尽可能均匀的搜索整个空间）</li></ul><p><img src="2025060823.png" alt=""></p><p><em>性能还是问题</em></p><ul><li>链表找还是太费⼒了<ul><li>其搜索的算法复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul></li><li>更好的数据结构<ul><li>⽐如：红⿊树，结点存放的空闲内存的⼤⼩，这样就可以以的复杂度搜索相应的内存</li></ul></li><li>但还有⼀个问题，当 free 之后，如何合并？<ul><li>在地址上，相邻的空闲块才能合并，因此空闲的结点链表应该按照地址进⾏链接，然后 free 的时候扫描整个链表</li><li>有没有更加⽅便的合并？</li></ul></li></ul><h3 id="伙伴系统-Buddy-System">伙伴系统 Buddy System</h3><p><img src="2025060866.png" alt=""><br><img src="2025060886.png" alt=""></p><p>伙伴系统的好处在于<em>合并效率⾼</em>：</p><ul><li>⽐如如果将这个 21KB 的块归还给空闲列表<ul><li>分配程序会检查“伙伴”32KB 是否空闲。</li><li>如果是，就合⼆为⼀，变成 64KB 的块。然后会检查这个 64KB 块的伙伴是否空闲，如果是，就合并这两块。</li><li>这个递归合并过程继续上溯，直到合并整个内存区域，或者某⼀个块的伙伴还没有被释放</li></ul></li></ul><p>伙伴的位置⾮常容易得到（其地址和伙伴只有⼀位不同，⽽正是这⼀位决定了它们在整个伙伴树中的层次）</p><p>Buddy System 已经是 linux 内部分配“⼤”粒度的连续的物理⻚⾯的⽅法了<br>但还是存在⼀些问题：</p><ul><li>内部碎⽚<ul><li>只允许分配 2 的整数次幂⼤⼩的空闲块（实际上，伙伴系统分配的最⼩单位是 4K，即⼀个物理⻚），因此如果不是 2 的整数次幂的⼤⼩，会有内部碎⽚ -</li><li>⽐如刚刚的例⼦中有 32K-21K ⽆法使⽤（属于该进程，但该进程没有使⽤ 他们，也不能被其他进程使⽤）</li></ul></li></ul><h3 id="Segregated-List-Slab-分配器">Segregated List (Slab) 分配器</h3><p>操作系统⾥⾯的结构体⼤⼩常为⼏⼗、⼏百字节</p><ul><li>Buddy System 来分配的话会产⽣⼤量的碎⽚</li></ul><p>经验观察：</p><ul><li>系统频繁分配的对象⼤⼩相对⽐较较⼩且固定<ul><li>⼩对象分配/回收的 scalability 是 System 内存分配的主要瓶颈</li></ul></li></ul><p>Slab 分配器</p><ul><li>目标：快速分配小内存对象</li><li>解决方案：<ul><li>从伙伴系统获得大块内存</li><li>进一步细分成固定大小的小块内存进行管理</li><li>块大小通常是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个字节（可额外增加特殊大小）</li></ul></li></ul><p><img src="2025060808.png" alt=""><br><img src="2025060821.png" alt=""></p><p>Fast path</p><ul><li>Per CPU 从当前 slab 中取出⼀个适合⼤⼩的块（快速，没有和其他 CPU 的竞争）</li></ul><p>low path</p><ul><li>需要从⼀个全局的 partial ⾥去找⼀个作为当前的 slab，不巧的话（paritial ⾥也没空闲内存），甚⾄需要从 buddy system ⾥重新分配连续空间，再次分割为可⽤的 slab</li></ul><p><em>连续内存分配的问题</em></p><ul><li>如果直接分配给进程内存的话，stack 和 heap 中间的部分都被浪费了<ul><li>内部碎片无法避免</li></ul></li><li>⽆法和其他进程共享内存（⽐如代码和 glibc）<ul><li>主要是保护机制粗糙，整体空间的保护，没有精细到具体的部分内存</li></ul></li></ul><h2 id="分段-Segment">分段 Segment</h2><p>⽤户视⻆的内存管理</p><ul><li>将程序视为⼀组段（segments）</li><li>段是虚拟内存空间的连续区域，是⼀个逻辑单元<ul><li>例如代码段、栈、堆等</li><li>按照这样的段分配内存</li></ul></li></ul><p>每个段独⽴映射到物理内存中的⼀组连续地址</p><ul><li>没有特定的顺序</li><li>不需要映射未使用的虚拟地址<ul><li>可以消除内部碎片</li></ul></li><li>不同的段可以独立增长或缩减</li></ul><p><em>分段底层机制</em><br>虚拟地址空间分成若干个不同大小的段</p><ul><li>段表（每个进程对应⼀个）存储着每个分段的信息（由段号索引），可供 MMU 查询表<ul><li>段基址（Segment Base）：段在内存中所在的起始物理地址</li><li>段界限（Segment Bound）：段的⼤⼩</li></ul></li><li>虚拟地址分为：段号 + 段内偏移地址</li></ul><p>物理内存也是以段为单位进行分配</p><ul><li>虚拟地址空间中相邻的段，对应的物理内存可以不相邻</li></ul><p><img src="2025060806.png" alt=""></p><p><em>支持共享</em></p><ul><li>多个虚拟地址空间可以映射到内存中的同一个段<ul><li>比如：只读代码的一个副本在进程间共享，一个可执行文件被加载多次</li><li>也可以用作进程间通信</li></ul></li><li>段表需要增加保护位<ul><li>指示程序是否具有相应段的读/写/执行权限</li></ul></li><li>每个进程仍然任务它在访问自己的私有内存（透明性）</li></ul><p>OS 对段表机制的支持</p><ul><li>操作系统应在上下⽂切换时保存和恢复段表（指向段表的寄存器）</li><li>当段增⻓或缩⼩时，操作系统应进⾏交互（更新段表）</li><li>创建新的地址空间时，操作系统应在物理内存中为其段找到空间<ul><li>操作系统维护着空闲内存块</li></ul></li><li>由于段的长度各不相同，内存分配是一个动态内存分配问题<ul><li>需要分配和合并</li></ul></li></ul><p><em>分段机制的问题</em></p><ul><li>分配的粒度太粗，随着时间的推移会产⽣外部碎⽚</li><li>如果是⼀个⼤但使⽤稀疏的堆?</li><li>如果地址空间的使⽤模型与段设计不匹配怎么办？</li></ul><h2 id="分页-Paging">分页 Paging</h2><p>更细粒度的内存管理</p><ul><li>物理内存被划分成连续的、等⻓的物理⻚（也叫帧 frame）<ul><li>⼤⼩⼀般为 2 的幂，⽐如默认是 4KB</li></ul></li><li>虚拟内存也被划分为相同⼤⼩虚拟块—虚拟⻚（Page）</li><li>任意虚拟⻚可以映射到任意物理⻚<ul><li>⾮常灵活，不需要是连续的空间</li></ul></li><li>由于都是按照⻚为单位分配内存<ul><li>没有外部碎⽚</li></ul></li></ul><p>虚拟地址分为：</p><ul><li>虚拟页号 + 页内偏移</li></ul><p>每个进程都有一个页表 Page Table，每个页表项包含一个物理页号，也叫物理帧号，指示每个页在物理内存中的基地址</p><p><img src="2025060870.png" alt=""></p><p><strong>页表</strong><br>⻚表最简单的形式称为线性⻚表（⼀个数组），存储在物理内存中<br>⻚表项（PTE）的具体布局⾼度依赖于机器</p><ul><li>需要足够的位来标识</li><li>应包括一些控制位</li></ul><p><em>页表项中常见的控制位</em></p><ul><li>有效位（Valid bit）：转换是否有效（⽀持稀疏空间）</li><li>存在位（Present bit）：⻚⾯是否实际存储在内存中</li><li>保护位（Protection bits）：⻚⾯是否可以被读取、写⼊或执⾏</li><li>引⽤位（Reference bit）：⻚⾯是否已被访问</li><li>脏（修改）位（Dirty/modified bit）：⻚⾯⾃被载⼊内存以来是否已被修改</li></ul><p><img src="2025060834.png" alt=""></p><p><img src="2025060827.png" alt=""></p><p><em>单级页表的问题</em><br><img src="2025060814.png" alt=""></p><p>解决方案 -&gt; 多级页表<br><img src="2025060848.png" alt=""></p><p>页表页</p><ul><li>每级⻚表有若⼲离散的⻚表⻚<ul><li>每个页表页占用一个物理页</li></ul></li><li>第 0 级（顶层）页表有且仅有一个页表页<ul><li>页表基地址寄存器存储的是该页的物理地址</li></ul></li><li>每项为 8 个字节<ul><li>总共 4096/8 = 512 项，⽤于存储物理地址和权限</li></ul></li><li>可以不只是两级的⻚表</li></ul><p>问题：太多虚拟页了，而物理页是少的</p><p><strong>倒排页表</strong></p><p>不再为每个进程分别维护多个⻚表，⽽是保留⼀个单⼀的⻚表，每个物理⻚对应⼀个条目<br>每个⻚表条⽬包括：</p><ul><li>使⽤该物理⻚的进程 (Pid)</li><li>该进程的哪个虚拟⻚映射到该物理⻚</li></ul><p>减少了存储⻚表所需的内存，但增加了在发⽣⻚引⽤时查找表所需的时间</p><ul><li>使用哈希表来加速查找</li></ul><p>此外一个问题是无法共享<br><img src="2025060820.png" alt=""></p><p><em>地址翻译比较</em><br><img src="2025060827-1.png" alt=""></p><p>段页<br><img src="2025060883.png" alt=""></p><p>多级页表不是完美的</p><ul><li>多级⻚表的设计是典型的⽤时间换空间的设计<ul><li>能够减⼩⻚表所占空间</li><li>但是增加了访存次数 (逐级查询，级数越多越慢)<ul><li>即使是单极页表，也需要访存两次才能真正得到物理内存上的数据</li></ul></li></ul></li></ul><h2 id="Translation-Look-aside-Buffers-TLB-地址转换旁路缓冲">Translation Look-aside Buffers TLB 地址转换旁路缓冲</h2><p>如何加速分⻚的地址转换？</p><ul><li>观察：⼤多数程序倾向于对少量⻚⾯进⾏⼤量引⽤</li><li>使⽤⼀种特殊的快速查找硬件缓存，称为翻译后备缓冲器（TLB）或联想存储器（在内存管理单元中）</li></ul><p>缓存最近地址转换</p><ul><li>如果 TLB 命中，直接应⽤转换（fast path）</li><li>否则，如果 TLB 未命中，则在⻚表中查找映射（⻚表遍历），并更新 TLB (slow path)</li></ul><p><img src="2025060895.png" alt=""></p><p><img src="2025060841.png" alt=""></p><p><strong>局部性原理</strong><br>TLB 背后的理念是利⽤指令和数据引⽤的局部性</p><ul><li>时间局部性：如果某个数据被访问过，那么在不久的将来它可能会再次被访问</li><li>空间局部性：如果某个数据被访问过，那么它附近的数据在不久的将来也可能会被访问。</li></ul><p>TLB 通常很⼩，包含 64 到 1024 个条⽬</p><ul><li>存储最可能被多的选中的地址翻译才能⾼效发挥 TLB</li><li>⽀持某些条⽬可以固定下来以便永久快速访问</li></ul><p><img src="2025060869.png" alt=""></p><p><strong>处理 TLB Miss</strong><br>在 TLB 缺失时，值被加载到 TLB 中，以便下次更快地访问。<br>但如果 TLB 已满，应该替换谁呢？</p><ul><li>先进先出</li><li>最近最少引用 LRU</li><li>随机</li></ul><p>谁来处理？</p><ul><li>硬件处理（如 x86 这样的 CISC 架构）<ul><li>当 TLB 缺失时，硬件进⾏⻚⾯遍历，获取⻚表项，并将其插⼊ TLB</li><li>硬件必须确切地知道⻚表在内存中的位置（通过 PTBR 寄存器），以及它们的确切格式</li><li>更加迅速，对系统软件透明地完成</li></ul></li><li>软件处理的 TLB Miss（如 MIPS 这样的 RISC 架构）<ul><li>当 TLB 缺失时，硬件会引发异常（TLB 故障）</li><li>操作系统内部的代码处理 TLB 缺失（返回指令与系统调⽤返回不同）</li><li>更加灵活（如可以定制替换策略等）</li></ul></li></ul><p><em>TLB 一致性</em></p><ul><li>上下⽂切换时，旧进程的虚拟到物理地址的转换应该不再有效，否则就会出现同样的虚拟地址映射到不同物理地址的问题，解决⽅案有两种：<ul><li>清空 TLB：简单地将所有有效位设置为 0</li><li>带标记的 TLB：在每个 TLB 条⽬中添加⼀个地址空间标识符（ASID）字段， 该字段唯⼀地标识每个进程，为该进程提供地址空间保护</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-10虚拟化-调度</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10%E8%99%9A%E6%8B%9F%E5%8C%96-%E8%B0%83%E5%BA%A6/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10%E8%99%9A%E6%8B%9F%E5%8C%96-%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>调度：为了满足既定目标，对计算任务进行资源分配的行为。<br>调度指标：</p><ul><li>CPU 利用率 公平 吞吐量 周转时间 等待时间 响应时间</li></ul><p>调度的时机</p><ul><li>CPU 回到操作系统的掌控之中<ul><li>发生系统调用：比如 fork () exit ()</li><li>某个运行的进程阻塞了（⽐如 wait ⼦进程或者等待⼀个 I/O 完成）</li><li>发生中断，⽐如 I/O interrupt，clock interrupt</li></ul></li><li>这些事件的发⽣都意味着系统的状态发⽣了变化，可能和既定的⽬标发⽣了偏离，需要调整（调度）来让系统往既定的⽬标靠近</li></ul><p><em>机制与策略</em></p><ul><li>操作系统中的⼀个重要设计思想：机制与策略的分离（Separation of mechanism and policy），这种设计是⼀个典型的模块化思想，可以有效降低系统的复杂度<ul><li>策略：“可以做什么”</li><li>机制：“怎么做”</li></ul></li><li>在⼀个已有的机制上，可以考虑的问题是，有哪些策略？有没有“最优”的策略？</li><li>在给定⼀个策略的基础上，可以考虑的问题是，实现这个策略需要什么样的机制？ 已有机制是否具备这个能⼒？实现效果是否⾼效？</li></ul><p>调度策略</p><ul><li>批处理任务的调度</li><li>交互性任务的调度</li><li>实时任务的调度</li></ul><h2 id="批处理任务的调度">批处理任务的调度</h2><h3 id="先来先服务-First-Come-First-Serve-FCFS">先来先服务 First Come First Serve FCFS</h3><p>按照到达系统（就绪）的先后顺序进行调度，也叫先进先出<br>护航效应：短运⾏时间的进程排在⻓运⾏时间的后⾯，导致平均等待时间过⻓的现象。</p><h3 id="最短任务优先-Shortest-Job-First-SJF">最短任务优先 Shortest Job First SJF</h3><ul><li>将每个任务与其需要运行时间关联</li><li>需要运行时间最短的优先被调度</li></ul><p>命题：就平均等待时间而言，SJF 是最优的<br>给定：有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span> 个进程， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">t_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是进程 k 的执行时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">W_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是进程 k 的等待时间<br>证明思路</p><ul><li>给定⼀任意进程排列顺序的平均等待时间</li><li>给出⼀个给出将该序列变为按执⾏时间降序排列的过程</li><li>证明该过程是单调的，即每⼀步都会导致平均等待时间变⻓</li></ul><p><img src="2025060749-1.png" alt=""></p><p>冒泡排序：<br><img src="2025060708.png" alt=""></p><p>调换顺序，将用时短的前移：<br><img src="2025060702.png" alt=""></p><p>平均等待时间变短：<br><img src="2025060797.png" alt=""></p><h3 id="最短剩余时间优先-Shortest-Remaing-Time-First-SRTF">最短剩余时间优先 Shortest Remaing Time First SRTF</h3><p>⼀个<em>⾮抢占式</em>调度算法选择⼀个进程来运⾏，然后就让它⼀直运⾏，直到它被阻塞（⽆论是在 I/O 操作上还是等待另⼀个进程），或者⾃愿释放 CPU。</p><p>⼀个<em>抢占式</em>调度算法选择⼀个进程，并允许其运⾏⼀段固定的最⻓时间。如果在时间间隔结束时它仍在运⾏，则被挂起，调度器选择另⼀个进程来运 ⾏。（需要时间中断的机制⽀持）</p><p>最短任务优先的可抢占（Preemptive）版本</p><ul><li>始终选择<em>剩下需要时间最短的进程</em>进⾏运⾏！</li></ul><p><img src="2025060773.png" alt=""></p><p>0：只有 p1 到达，剩余 8ms，执行 p1 1ms<br>1：p2 到达，剩余 4ms，小于 p1 的 7ms，执行 p2 1ms<br>2：p3 到达，剩余 9ms，最小的是 p2 的 剩余 3ms，执行 p2 1ms</p><h3 id="时间预测算法">时间预测算法</h3><p><img src="2025060702-1.png" alt=""><br><img src="2025060789.png" alt=""><br><img src="2025060793.png" alt=""><br><img src="2025060739.png" alt=""></p><p>可以尝试愚弄 gaming 调度</p><ul><li>将⾃⼰切割成很多份“⾮常”短执⾏时间的⼩任务，然后再批量运⾏这些⼩任务</li></ul><h2 id="交互性任务的调度">交互性任务的调度</h2><p><strong>计算密集型&amp;I/O 密集型</strong><br>在调度策略中，有两类进程会被区别对待：计算密集型和 I/O 密集型 （当然也有混合型）</p><ul><li>CPU 密集型程序主要消耗 CPU 计算资源，例如数学运算、图形处理或数据分析等任务。这些程序通常会在 CPU 上执⾏⼤部分时间的计算和逻辑判断等操作，⽽不需要等待外部资源（如磁盘读写或⽹络通信）完成。</li><li>I/O 密集型指的是系统⼤部分的时间在等待 I/O（硬盘/内存/键盘）的读取/写⼊操作（即和外界进⾏频繁交互的进程），此时 CPU 负载并不⾼，需要消耗 CPU 计算的时间很少</li></ul><h3 id="时间片轮转调度-Round-Robin-RR">时间片轮转调度 Round-Robin RR</h3><p>每个任务都会获得一段固定时间的资源（时间片，time-slicing）</p><ul><li>如果任务没有完成，它将重新回到队列中</li></ul><p>时间片应该相对上下文切换时间较大，否则开销会太高；当然时间⽚也不能过⼤，否则就蜕变为 FCFS 调度了</p><ul><li>⼀般来说时间⽚⼤概设置为 10ms 到 100ms ( context switch ⼀般⼩于 10 microseconds)</li></ul><p><img src="2025060750.png" alt=""></p><p>问题：<br><img src="2025060793-1.png" alt=""></p><p>另一个问题：<br>在运⾏既有 I/O 密集型任务⼜有计算密集型任务的情况下，当 I/O 密集型任务执⾏ I/O 操作时，它会让出处理器（由于需要的 CPU 计算很短，没有⽤完时间⽚就让出 CPU 了）。</p><ul><li>这时即使 I/O 操作很快完成（⽐如你正在⽤ VIM 打字），也必须<em>等待重新分配</em>处理器，直到其他计算密集型任务<em>⽤完他们完整的 CPU 切⽚</em></li></ul><h3 id="基于优先级的调度-Priority-Scheduling">基于优先级的调度 Priority Scheduling</h3><p>I/O-bound 和 CPU-bound 的优先级不同，我们需要基于优先级的调度：</p><ul><li>每个进程都关联有⼀个优先级数（整数）。</li><li>每次发⽣调度时，CPU 被分配给具有最⾼优先级的进程。</li></ul><p>SJF（Shortest Job First）就可以看成是⼀种优先级调度算法，其中每个进程的优先级与预测其下⼀个 CPU 执⾏时间的倒数成正⽐。</p><p>问题：</p><ul><li>饿死 - 低优先级的进程可能永远不会执行<ul><li>解决方案：老化 Aging- 随着时间的推移增加进程的优先级</li></ul></li></ul><h3 id="多级反馈队列-Multilevel-Feedback-Queue-MFQ">多级反馈队列 Multilevel Feedback Queue MFQ</h3><p>⼀个进程可以在各个队列（代表不同优先级）之间移动。</p><p>多级反馈队列调度器由以下参数定义：</p><ul><li>队列的数量</li><li>每个队列的调度算法</li><li>确定何时将进程提升优先级的⽅法</li><li>确定何时将进程降优先级的⽅法</li><li>确定当某个进程需要服务时该将进⼊哪个队列的⽅法</li></ul><p>一个典型的多级反馈队列：</p><ul><li>一组轮转队列：<ul><li>每个队列都有单独的优先级</li></ul></li><li>高优先级队列拥有短的时间片<ul><li>低优先级队列拥有长的时间片</li></ul></li><li>调度器选择最高优先级队列中的第一个进程</li><li>进程加载到内存中时初始在最⾼优先级队列中。</li><li>如果时间⽚到期，任务会降低⼀个级别。</li></ul><p><img src="2025060739-1.png" alt=""></p><p>当使用多级反馈队列 MFQ 时：</p><ul><li>CPU 密集型进程将下沉到⻓时间⽚的优先级队列。</li><li>如果使⽤完时间⽚，进程会下降⼀个优先级。</li><li>较⼤的时间⽚可以减少上下⽂切换的开销。</li></ul><p>I/O 密集型进程将保持在⾼优先级队列中。</p><ul><li>如果⼀个进程<em>没有完成其时间⽚</em>（即，它在 I/O 操作上被阻塞），那么它将保持在相同的优先级⽔平。</li></ul><p>多级反馈队列仍然存在饥饿问题：</p><ul><li>如果有⼤量交互式进程或者频繁创建新进程，则⾼优先级队列中始终有可⽤任务。此时，低优先级队列中的 CPU 密集型进程将永远不会被调度。</li></ul><p>⼀个相关的问题是，⼀个交互式进程可能最终会处于低优先级⽔平。</p><ul><li>如果⼀个进程的某个时期变得 CPU 密集型，它就会降到低优先级⽔平，⽽且注定会永远留在那⾥。⼀个例⼦是⼀个游戏需要花费⼤量 CPU 时间来初始化，但随着初始化完成，就变为了等待玩家输⼊的交互式进程 （此调度下的游戏体验可想⽽知）</li></ul><p>因此，MFQ 需要⼀个策略（<em>老化</em>）来定期增加进程的优先级，以确保它会被调度运⾏。⼀个简单的⽅法是定期将所有进程提升到最⾼优先级队列，即<em>重置</em></p><p><strong>愚弄 （Game） 系统</strong><br><img src="2025060785.png" alt=""></p><p>解决方案——追踪</p><ul><li>不仅仅是简单地检查进程是否使⽤完了它的时间⽚，调度器会跟踪<em>进程在较⻓时间间隔（⼏个时间⽚）内运⾏的总时间。</em></li><li>每个优先级队列将有⼀个与之关联的最⼤ CPU 时间分配。<ul><li>超出使⽤的分配则降低优先级</li></ul></li></ul><p><em>乐透 Lottery 调度</em></p><p>有的时候不能简单的优先级⾼的⼀定先执⾏，优先级低的⼀定等优先级⾼的执⾏完再执⾏</p><ul><li>更加希望的是：两者获得的 CPU 时间上呈⼀定精确的⽐例！⾼优先级的占⽐⾼⼀点，低优先级的占⽐低⼀点</li></ul><p>⼀个灵活的调度算法：乐透算法</p><ul><li>给每个作业分配⼀定数量的彩票票数</li><li>然后随机选择⼀个中奖票（拥有更多票数的作业有更⼤的中奖机会）。</li><li>为了避免饥饿，⾄少给每个作业分配⼀张彩票。</li></ul><h2 id="实时任务的调度">实时任务的调度</h2><p>实时系统中时间扮演着⾄关重要的⻆⾊</p><ul><li>必须在截⽌⽇期（deadline）之前得到服务；</li><li>截⽌⽇期过期后才得到服务与根本没有服务⼀样。</li></ul><p>周期性（Periodic）</p><ul><li>截⽌⽇期以规律的间隔发⽣。</li></ul><p><img src="2025060761.png" alt=""></p><h3 id="单调速率-Rate-Monotonic-调度">单调速率 Rate Monotonic 调度</h3><p>根据其速率（即周期的倒数）分配优先级。</p><ul><li>周期较短的任务具有较⾼的优先级，</li><li>⽽周期较⻓的任务具有较低的优先级</li></ul><p>这种策略背后的理念是为需要更频繁占⽤ CPU 的任务分配更⾼的优先级。</p><p><img src="2025060716.png" alt=""><br><img src="2025060740.png" alt=""></p><h3 id="最早截止日期优先">最早截止日期优先</h3><p>根据截⽌期限分配优先级：</p><ul><li>截⽌期限越早，优先级越⾼。</li><li>截⽌期限越晚，优先级越低。</li></ul><p>——会根据任务的截⽌期限调整优先级。<br><img src="2025060728.png" alt=""></p><h2 id="真实操作系统调度器">真实操作系统调度器</h2><p>调度类别： 每个类别都有特定的优先级。<br>调度器选择最⾼调度类别中的最⾼优先级任务。<br>包括两个调度类别，可以添加其他类别：</p><ul><li>实时类别：FCFS，RR，EDF (在 Linux 3.14 中合并)</li><li>普通类别：完全公平调度器（CFS）, IDLE</li></ul><p><strong>完全公平调度策略 CFS</strong><br>⽬标：每个进程获得相等份额的 CPU 时间（公平性）</p><ul><li>N 个线程下，每个线程在任意时刻获得等份的 CPU 时间 t/N</li><li>⽆法在实际硬件上实现这⼀点</li></ul><p>更加实际的做法：不断跟踪到⽬前为⽌给予进程的 CPU 时间。<br>动态的根据每个进程当前已经给予的时间来进⾏调度决策：</p><ul><li>每次选择 CPU 使⽤时间最少的线程执⾏</li><li>如果线程进⼊睡眠状态然后重新唤醒，则重置 CPU 使⽤时间为当前就绪的红⿊树中“最⼩”的时间<ul><li>不然其使⽤时间会远远⼩于其他进程，那么调度器就会疯狂的给这个进程找补</li></ul></li></ul><p>与之前版本的 Linux 调度器不同，CFS 不是维护任务的运⾏队列，⽽是维护⼀ 个按时间排序的红⿊树。</p><h2 id="调度的一些其它问题">调度的一些其它问题</h2><p><strong>多核 CPU 的调度</strong><br>在多处理器系统中，CPU 调度的⼀种⽅法是由单个处理器——主服务器处理所有调度决策，其他处理器仅执⾏⽤户代码。</p><ul><li>这种不对称多处理是简单的，因为只有⼀个核⼼访问系统数据结构，减少了数据共享的需求。</li><li>这种⽅法的缺点是主服务器成为潜在的瓶颈，可能降低整个系统的性能。</li></ul><p>相反，对称多处理（ symmetric multiprocessing, SMP）是指每个处理器都进⾏⾃我调度, 不需要 ⼀个中央的调度服务器 CPU。</p><p>⼏乎所有现代操作系统都⽀持 SMP，包括 Windows、Linux 和 macOS，以及包括 Android 和 iOS 在内的移动系统。<br><img src="2025060757.png" alt=""></p><p>如果选择第⼀种选项，我们在共享的就绪队列上存在竞争条件，需要加⼀把 ⼤锁，这显然低效。<br>第⼆种选项允许每个处理器从其私有的运⾏队列中调度线程，因此 CPU 之间不会受到可能的竞争条件问题的影响。</p><ul><li>此外，每个处理器都有私有的运⾏队列，实际上可能会导致对缓存内存的更有效利⽤（不然会存在多个 CPU 有重复的缓存，浪费资源）。</li><li>因此，在⽀持 SMP 的系统中，这是最常⻅的⽅法。</li></ul><p><strong>负载均衡</strong><br>SMP 下需要保持所有 CPU 负载均衡以提⾼效率。<br>负载平衡尝试保持⼯作负载均匀分布，有两种⽅式：</p><ul><li>推迁移（Push migration）：周期性任务检查每个处理器的负载，如果发现过载，则将任务从过载的 CPU 推送到其他 CPU 上。</li><li>拉迁移（Pull migration）：空闲处理器从繁忙处理器中拉取等待的任务</li></ul><p><strong>处理器亲和性 Affinity</strong><br>当⼀个线程在⼀个处理器上运⾏时，该处理器的缓存内容存储了该线程的内存访问。</p><ul><li>我们将这称为线程对处理器具有亲和⼒，即“处理器亲和性”“processor affinity”）。</li></ul><p>负载平衡可能会破坏处理器亲和性：</p><ul><li>因为线程可能会从⼀个处理器移动到另⼀个处理器以平衡负载，但该线程将丢失在移出的处理器的缓存中所拥有的内容。</li></ul><p>因此想要保持很好的性能，操作系统需要⼀个保持亲和性的机制, 尝试让线程在同 ⼀个处理器上运⾏(往往不能保证)</p><p><strong>调度和并发的“组合”bug</strong></p><h3 id="优先级反转问题-：">优先级反转问题 ：</h3><ul><li>假设系统中有两个线程：T1（低优先级）和 T2（⾼优先级）。如果两者都是可运⾏的，调度器将始终优先运⾏ T2。</li><li>现在假设 T1 ⾸先运⾏（T2 此时还不可运⾏），并获得了⼀个⾃旋锁，并进⼊其临界区。</li><li>然后 T2 开始运⾏，调度器⽴即调度 T2 取代 T1 运⾏；</li><li>但 T2 尝试获取锁，并开始忙等待。由于 T2 运⾏时永远不会调度 T1，因此 T1 没有机会离开临界区，⽽ T2 则永远循环下去。</li></ul><p><img src="2025060709.png" alt=""></p><p>然⽽，即使避免使⽤⾃旋锁，⽽是使⽤ futex wait 的阻塞也并不能避免优先级反转问题。<br><img src="2025060761-1.png" alt=""><br><img src="2025060727.png" alt=""></p><p>优先级权限 priority ceiling protocol</p><ul><li>每当⼀个任务获取⼀个锁时，该任务的优先级被提升到<em>与该锁关联的优先级上限相同的优先级</em>。</li></ul><p>优先级继承</p><ul><li>当⼀个任务持有⼀个锁时，如果其他（更⾼优先级的）任务试图获取该锁，那么持有锁的任务的优先级将被提升到那个更⾼优先级的任务的优先级。</li></ul><h2 id="总结">总结</h2><p>机制与策略</p><ul><li>调度的机制是 context-switch + queue</li><li>策略有 FCFS、SJF、RR、优先级、MFQ、CFS</li></ul><p>实时任务调度对截止日期敏感</p><ul><li>（静态优先级最优）单调速率</li><li>（动态优先级最优）EDF</li></ul><p>如何评价一个调度策略</p><ul><li>评价的指标：CPU 利⽤率、吞吐量、周转时间、等待时间、公平、相应时间</li><li>评价模型：排队论*</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-09虚拟化-进程管理</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09%E8%99%9A%E6%8B%9F%E5%8C%96-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-09%E8%99%9A%E6%8B%9F%E5%8C%96-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>进程的概念</p><ul><li>拥有独立地址空间的运行实体，可以包含一个或多个线程</li></ul><p>进程控制块：类似线程控制块 TCB，进程也需要一些元信息，用来描述（抽象）进程，方便操作系统管理，即进程控制块（Process Control Block）</p><p><strong>进程树</strong>：</p><ul><li>⼀个进程是被某个进程所创建的，⼀个进程也可以创建多个进程</li><li>因此操作系统的进程可以构成⼀个进程树（Process Tree），其中⽗进程节点指向其所创建的⼦进程</li><li>linux 下可以通过命令 <code>pstree</code> 得到当前进程树</li></ul><p>第一个进程 init</p><ul><li>CPU reset -&gt; Firmware 代码执⾏ -&gt; 加载操作系统并初始化 -&gt; 加载第⼀个进程</li><li>init 进程加载完之后，操作系统已经完成了所需要资源的管理，并“躺”在后台等待用户命令 syscall 或者中断的发生</li></ul><p>进程的生命周期：<br><img src="2025060762.png" alt=""></p><p>终⽌之后的进程的“资源”会被操作系统回收，并通知其⽗进程其终⽌状态</p><ul><li>通知？<ul><li>PCB 中⽗进程含有指针指向⼦进程 PCB，如果进程终⽌之后连 PCB 也都被回收，那么该指针就会指向⼀个“已经”被释放的内存 （Dangling pointers）</li><li>已终⽌但其 PCB 信息还没被回收的进程被称为“僵⼫进程”（Zombie process）</li><li>⽗进程调⽤ wait 系统调⽤会得到⼦进程的退出通知（⼦进程退出前会阻塞⽗进程）和其退出状态，同时移除该⼦进程的 PCB</li></ul></li></ul><p>但并不是每个⽗进程都⽼⽼实实的 wait ⼦进程的，其完全可能在⼦进程终⽌ 前就终⽌了：这时的⼦进程是没有⽗进程的！</p><ul><li>该状态下（没有⽗进程）的进程被称为“孤⼉进程”（Orphan Process）</li><li>linux 会让 init 进程重新接管这些孤⼉进程，从⽽能够在这些孤⼉进程终⽌ 时回收 PCB 资源</li></ul><p>进程最重要的三类系统调用</p><ul><li>fork - 进程的创建</li><li>execve - 进程的改变</li><li>exit - 进程的删除</li></ul><h2 id="fork">fork</h2><p><strong>fork 系统调用</strong><br>创建一个新的（子）进程</p><ul><li>通过做一份当前进程完整的复制（内存、寄存器现场）</li><li>子进程和⽗进程会各⾃独⽴地继续执⾏ fork 之后的指令</li></ul><p>如何区分父子进程</p><ul><li>fork 的返回值不同: ⼦进程返回 0, ⽗进程返回⼦进程的 process ID</li><li>fork 出错会返回 -1</li></ul><p><strong>fork 的行为</strong></p><ul><li>立即复制状态机：包括所有信息的完整拷贝<ul><li>每一个字节的内存</li><li>PCB 里的信息</li></ul></li><li>注意，不只是地址空间的对象被复制了，PCB ⾥的对象，如打开的⽂件描述符号也被⼀并复制</li></ul><p>文件描述符</p><ul><li>⼀个指向操作系统内对象的 “指针“<ul><li>对象只能通过操作系统允许的方法访问</li><li>从 0 开始编号 (0, 1, 2 分别是 stdin, stdout, stderr)</li><li>可以通过 open 取得；close 释放； dup 复制；</li><li>对于数据⽂件，⽂件描述符会 “记住” 上次访问⽂件的位置</li></ul></li></ul><p>事实上，由于存在⽗⼦进程存在⼤量的共享，会造成很多不确定性，真实系统的 fork 的背后的实现是复杂的</p><ul><li>⽐如⽗⼦进程之间的 process id 是不同的，进程的 parent process id 也是不同的</li><li>⽐如，多线程的进程进⾏ fork 时，只有⼀个线程被复制，就是那个调⽤ fork 的线程</li></ul><p>fork 应用：</p><ul><li>给进程创建“快照”</li><li>主进程 crash 了，启动快照重新执⾏： 有些 bug 可能调整⼀下环境就消失了 (⽐如并发)</li></ul><h2 id="execve">execve</h2><p>很多时候，⽗⼦进程并不是同样的逻辑，⼦进程有⾃⼰的逻辑，⽐如 shell 创建进程并不是为了⼦进程也是⼀个 shell，⽽是“加载”某个可执⾏⽂件进⾏运⾏</p><ul><li>execve 就是这样的系统调⽤</li><li><code>int execve(const char *pathname, char *const argv[], char *const envp[])</code></li><li>其参数中，pathname 是要加载的可执⾏⽂件具体的路径，argv 进程执⾏ 所需要的参数（main 函数同款参数）， envp 是环境变量</li></ul><p><strong>execve 行为</strong><br>语义：将当前进程重置成⼀个可执⾏⽂件描述状态机的初始状态</p><ul><li>加载 pathname 指定的可执⾏⽂件（数据段、代码段）</li><li>重新初始化堆和栈</li><li>PCB 中相应的 memory mappings 也会改变</li><li>将 PC 寄存器设置到可执⾏⽂件代码段定义的⼊⼝点，该⼊⼝点最终会调⽤ main 函数</li></ul><p>demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ; <span class="hljs-comment">//environment variables of current process</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>type_prompt(); <span class="hljs-comment">// display prompt on the screen</span><br>read_command(&amp;filename, &amp;parameters); <span class="hljs-comment">//read the input command</span><br><span class="hljs-type">int</span> pid = fork();<br><span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Child</span><br>execve(filename, parameters, environ);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> status; <span class="hljs-comment">// Parent</span><br>waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PCB 中的文件描述符呢？<br><img src="2025060790.png" alt=""></p><p>普通文件：</p><ul><li>在地址空间⾥有⼀个相应的 file 变量索引，但你的⼦进程重置了整个地址空间，因此那个⽂件描述符对应的 file 变量也没有了，此时你⽆法 close 这个⽂件了</li><li>这会造成资源的泄漏，当然这些资源（PCB）都会随着进程的终⽌⽽最终被回收，但在运⾏期间还是有⼀些资源的损耗</li><li>可以在创建⽂件时增加⼀个选项 FD_CLOEXEC：close on exec</li></ul><p><em>环境变量</em><br><img src="2025060767-1.png" alt=""></p><p><strong>写时复制 COW</strong><br>fork 后⾯往往跟着 execve 来加载⼦进程，那么 fork 的过程还必要吗？</p><ul><li>事实上，早期的 fork 就是这么⽆脑的复制⽗进程的⼀切，但⼈们发现这个过程是低效的：<ul><li>有些内存是只读的 (read-only)，⽐如代码段、共享代码库 (libc)，这些没必要复制</li><li>此外，⽴即执⾏ execve 会加载新的可执⾏⽂件，重置地址空间，因此，之前的内存拷⻉完全没有意义</li></ul></li></ul><p>-&gt; 写时拷⻉</p><ul><li>即两个进程共享同⼀份物理内存</li><li>只有当⼀个进程<em>尝试去写</em>这个物理内存时才会真正在物理内存中<em>复制⼀份副本</em>⽤来给这个进程去写</li><li>问题是，写⾃⼰的内存是⼀个“⽤户态”事件，内核⼜怎么知道呢？<ul><li>标记这个共享的内存为“只读”，⼀旦发⽣“写”操作会发⽣<em>权限错误陷入内核</em>，操作系统获知这是⼀个 COW 事件，复制内存</li></ul></li></ul><p><img src="2025060714.png" alt=""></p><p>posix_spawn 接口</p><ul><li>创建进程的 API，结合了 fork+execve</li></ul><p><img src="2025060749.png" alt=""></p><h2 id="exit">exit</h2><p>除了创建进程外，进程也需要能够终⽌：清理其所占内存空间（包括代码区、堆、栈），这个过程需要系统调⽤来做</p><ul><li>因为进程这个“实体”就是操作系统抽象出来的，没有操作系统，进程就是⼀ 连串的指令流，没有终⽌的概念（CPU 只会不断的进⾏取指-执⾏的循环)</li></ul><p>Linux 中，进程⼀般有 5 种退出机制</p><ul><li>正常退出： 从 main 函数返回，调⽤库函数 exit，调⽤_exit</li><li>异常退出：调⽤ abort，由信号终⽌</li></ul><p><code>void exit(int status)</code> C 标准库函数，最常用的进程退出函数</p><ul><li>调⽤ atexit () 注册的函数；使得我们可以指定在程序终⽌时执⾏⾃⼰的清理动作。(atexit () 最多可以注册 32 个函数，调⽤顺序与注册顺序相反)</li><li>关闭所有打开的流 (stdio)，这将导致写所有被缓冲的输出</li><li>移除所有的临时⽂件</li><li>最后调⽤_exit () 函数终⽌进程</li></ul><p>return from <code>main()</code></p><ul><li>从 main 函数返回是最常⻅的终⽌⽅式</li><li>main 函数的返回值和调⽤ exit () 的传⼊参数 int status 是同样的语义</li><li>0 是函数是符合预期终⽌，⾮ 0 是函数出现了错误终⽌</li></ul><p><code>_exit()</code></p><ul><li>所有属于这个进程的⽂件描述符都会被关闭</li><li>所有该进程的⼦进程都会被 init 进程接管</li><li>向该进程的⽗进程发送 SIGCHLD 信号，通知该⽗进程其已经终⽌</li><li>注意：_exit () 只会终⽌当前的线程，但 libc 做了⼀层 wrapper，其实真实调⽤ exit_group ()，关闭所有线程</li></ul><p><em>异常退出</em><br><code>abort()</code> 系统调⽤会导致系统异常终⽌</p><ul><li>atexit 注册的函数不会调⽤</li><li>io 流不会关闭</li><li>其⾏为就是产⽣⼀个 SIGABRT 信号发送给调⽤ abort () 的进程，然后改进程就会异常终⽌<ul><li>不会被 ignore 掉</li></ul></li></ul><p><strong>信号 Signal</strong><br>Linux 操作系统提供了⼀种可以通知进程发⽣了某个事件的机制：信号（Signal），注：不要和并发的 singal 原语混淆，也不要和“信号量”（Semaphore）混淆<br>其本质上是对中断的模拟, 命令 kill -l 可以查看有多少信号， man 7 signal 查看信号的具体信息</p><ul><li>发生某个中断事件后，⽤户程序也想获知并处理（⽽不只是在内核态由操作系统透明的处理）</li></ul><p>signal 函数可以注册信号处理函数，只要传⼊相应的信号和函数名即可</p><ul><li>handler 设为 SIG_IGN 时表示忽略这个信号，⽐如 signal (SIGCHLD, SIG_IGN) 就表示忽略掉⼦进程的终⽌信号，此时⼦进程结束会直接被内核完全清除（⽽不必先变为僵⼫进程，然后再被回收</li><li>handler 设为 SIG_DFL 时表示采⽤ linux 默认的处理函数</li></ul><p>有了信号机制，可以完成很多异步的操作：</p><ul><li>⽐如 signal (SIGCHLD， handler)，可以在 handler ⾥进⾏ wait，⽽不是在 main 函数⾥ wait/waitpid 从⽽阻塞⽗进程</li><li>⽐如 signal (SIGIO, handler) 可以不⽤等待 I/O 完成，可以先做其他事情，如果 ⽂件描述符所指向的数据传输完成，会产⽣ SIGIO 的事件，就可以通过回调函数 handler 来处理</li><li>信号也是⼀种进程间通信（Inter-Process Communication, IPC）的机制之⼀</li><li>此外还有消息传递、共享内存、管道等</li></ul><h2 id="总结">总结</h2><p>进程的概念、生命周期<br>三个重要的系统调用 fork exec exit</p>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-08并发-并发bugs</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91bugs/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-08%E5%B9%B6%E5%8F%91-%E5%B9%B6%E5%8F%91bugs/</url>
    
    <content type="html"><![CDATA[<h2 id="原子性和顺序性-bug">原子性和顺序性 bug</h2><p>并发控制机制的前提是正确使用</p><ul><li>原⼦性违背 (Atomicity Violation, AV)<ul><li>⽐如忘记上锁</li></ul></li><li>顺序性违背 (Order Violation, OV)<ul><li>忘记同步，或者同步条件写错</li></ul></li></ul><h2 id="死锁">死锁</h2><h3 id="死锁类型">死锁类型</h3><p><strong>A-A 型死锁</strong></p><ul><li>⼀个线程在已经持有⼀把锁的情况下再次尝试获得这把锁</li></ul><p><strong>ABBA 型死锁</strong></p><ul><li>线程 1 拿到了锁 A，需要锁 B，线程 2 拿到了锁 B，需要锁 A，这时两个线程都⽆法⾏进</li></ul><h3 id="死锁产生的必要条件">死锁产生的必要条件</h3><ul><li>所需要的资源是互斥的<ul><li>互斥也可改为资源有限（Bounded resources），即能够共享的线程数有限</li></ul></li><li>持有某个资源并等待更多资源</li><li>不可直接“抢”别人持有的资源，只有等待有的人主动释放</li><li>形成循环等待的环</li></ul><p>处理死锁</p><ul><li>忽略问题：在问题的发⽣频率很低且发⽣后代价很⼩（重启⼤法）直接忽略 (Ostrich Algorithm).</li><li>从源头避免死锁发生</li><li>检测并恢复</li></ul><h3 id="死锁避免：必要条件的破坏">死锁避免：必要条件的破坏</h3><p>互斥的破坏：不太容易</p><p>持有并等待的破坏：</p><ul><li>要么能⼀次得到所有锁，要么什么锁也不获取<ul><li>不现实，因为这需要线程提前就知道需要哪些锁，如果是后⾯系统根据需要才新建⼀些锁，那么其难以提前获知</li><li>此外，这也减少了⼀些并发度，因为如果程序很⻓时间运⾏中其实不太需要某些锁（只有在中间某段很短的时间内才需要某个锁），那么 ⼀开始就持有这把锁会限制其他线程得到这把锁并运行</li></ul></li><li>如果此刻⽆法获得想要的锁，就释放其所有持有的锁<ul><li>但如果锁是被封装在某个地⽅（不是显式地调⽤ lock 所得），便很难察觉需要释放这个锁</li></ul></li></ul><p>非抢占性的破坏</p><ul><li>允许系统直接去“抢”别的线程所持有的资源</li><li>问题是不是每种资源都可以直接“抢”的<ul><li>⼀个合理的“抢”需要被抢⾛资源的线程能够恢复到被抢前的状态</li></ul></li></ul><p>环形等待条件的破坏</p><ul><li>强制在锁在申请时按照规定的顺序来（Lock ordering）</li></ul><p><em>为什么按照⼀个全局的顺序就不会产⽣死锁？</em><br><img src="2025060770.png" alt=""></p><h3 id="死锁避免：避免陷入不可挽回状态">死锁避免：避免陷入不可挽回状态</h3><p>假设我们能够知道每个线程在其整个执⾏期间（⽽不是具体到哪个指令段）需要哪些互斥资源</p><ul><li>更⼀般的，假设资源数不只为 1（信号量），我们假设能够知道每个线程在其执⾏期间<em>需要哪些互斥资源的最⼤数量</em>, 即每个线程有⼀个最⼤需求向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>所有线程的最⼤需求向量形成⼀个<em>最⼤需求矩阵</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span><br>此外相应的，我们也可以刻画当前系统状态的互斥资源的线程持有状态</li><li>每个线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 有⼀个当前持有资源 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 所有线程的<em>当前持有资源为矩阵</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></li></ul><p>系统初始每个<em>资源数向量</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span></p><p>系统的行进伴随着线程对互斥资源的申请和释放，释放资源是平凡的事件，因为释放资源不会让系统进入“不可挽回状态”，但申请资源会</p><ul><li>每个线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 有一个当前<em>资源申请向量</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">R_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，所有线程的当前申请资源为矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li></ul><p>什么样的资源申请矩阵会导致系统进入“不可挽回状态”？</p><ul><li>如果接受了这个申请，导致⽆法满⾜未来的“最⼤”申请，即不可挽回<ul><li>即⽬前虽然没有死锁，可以满⾜，但既定的未来不可满⾜</li><li>这个“不可挽回”状态也有⼈称为“不安全”状态</li></ul></li></ul><p>正确的决策：如果当前申请矩阵会导致系统进⼊“不可挽回”状态，拒绝，否则接受申请，更新系统状态<br>——<strong>银行家算法</strong></p><ol><li>找⼀个线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，看看其<em>未来还需要的最⼤资源数</em>（最⼤资源需求数-⽬前持有资源数）是否能够被⽬前系统<em>尚存的资源数所满⾜</em>（系统初始资源数-被所有线程所持有的资源数），如果所有线程都不能被满⾜，就是⼀个“不可挽回”的不安全状态，最终会进⼊死锁状态</li><li>对满⾜需求的线程 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> ，标记其为<em>未来可满⾜状态</em>，即其可以在⽬前状态下<em>存在 ⼀个分配⽅式</em>（⽴即全部分配其所有资源）终⽌. 那么也就存在这样的⼀个好的局⾯： 我们可以将其资源都回收</li><li>在步骤 2 的更好的局⾯上，重复之前的步骤，⼀直到所有线程都可以终⽌，那么该系统状态就是“可挽回”的状态，否则就是“不可挽回”</li></ol><p>然而，这个算法是不实用的</p><ul><li>我们⼀般没法知道“最⼤”需求矩阵</li><li>系统的资源是动态变化的<ul><li>线程数会变化</li><li>资源数可能会变化（线程可以⾃⼰释放所持有的锁）</li></ul></li></ul><h3 id="死锁的检测并处理：让他发生吧">死锁的检测并处理：让他发生吧</h3><p>如何检测出现了死锁？</p><ul><li>死锁是由于多个线程形成⼀个等待环，⼀个线程的⾏进需要环内的另外⼀个线程所持有的锁，从⽽所有线程都⽆法⾏进</li><li>因此，核⼼就是检测锁申请环</li></ul><p><strong>死锁的动态检测</strong><br>如何检测环？</p><ul><li>锁的持有和申请就是一个有向图</li><li>有向图的环检测<ul><li>深度优先，出现回边</li></ul></li></ul><p><img src="2025060743.png" alt=""></p><p>如果是一类的互斥资源有多个资源数呢？单纯的环已不足来检测死锁<br><img src="2025060712.png" alt=""></p><h2 id="并发-bugs-的动态分析方法">并发 bugs 的动态分析方法</h2><p>什么是动态分析</p><ul><li>给定⼀次状态机（程序）的执⾏历史信息 （⽐如⽇志 log、covering lines、 memory access…）<ul><li>当然这种记录往往需要额外的运⾏成本（⽐如插桩）</li></ul></li><li>动态分析即为根据这个信息的分析函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>τ</mi><mo stretchy="false">)</mo><mo>:</mo><mi>τ</mi><mo>→</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">f(\tau):\tau \rightarrow\{0,1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.1132em;">τ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> , 0 代表关⼼问题的答案为否（⽐如没有 bug），1 代表关⼼问题的答案为是（⽐如有 bug），当然答案还可以有更多可能，那么这个值域会增⼤</li></ul><p>AddressSanitizer: 非法内存访问</p><ul><li>通过编译器⾃动插⼊和内存相关的断⾔（⽐如每次分配内存时，额外分配⼀写不可写的内存（投毒），⼀旦访问到这些被投毒的内存，就知道越界了），实现代码正确性的检查。</li></ul><p>ThreadSanitizer: 运行时的竞态条件检测</p><ul><li>回顾竞态条件 (数据竞争)：不同的线程同时访问同⼀内存，且⾄少有⼀个是写<ul><li>基于这个定义，就能动态的检测出竞态条件</li><li>这些条件中，不同线程是容易观察到的（记录 thread id 即可）， 同⼀内存也是容易观察到的（内存的地址），⾄少⼀个是写是容易观察到的（load 和 store 指令）</li><li>关键问题是，什么是同时？ happens-before 关系！<ul><li>让我们问⼀个反向的问题：什么不是同时</li><li>happens-before 关系</li></ul></li></ul></li></ul><p><img src="2025060795.png" alt=""></p><p>Canary</p><ul><li>&quot;牺牲” 内存单元，预警 memory error</li></ul><p>低配版 lockdep：</p><ul><li>统计当前的 spin count</li><li>如果超过某个明显不正常的数值 (e.g., 100,000,000) 就报告<ul><li>来代替你对于当前系统发⽣死锁直觉</li></ul></li></ul><p>低配版 AddressSanitizer</p><ul><li>实验 L1 内存分配器的 specification</li></ul><p>低配版 ThreadSanitizer</p><ul><li>竞态条件会产⽣什么后果？<ul><li>线程的读写⼀个共享数据不是原⼦的，即在中间可能被其他线程插⼊<ul><li>但是这个错误⼀般很难观测，因为指令的读写太快了</li></ul></li><li>想法：通过拖慢线程读写速度，放⼤原⼦性破坏的可能性（执⾏时间越⻓，被其他线程⼲涉的可能性越⼤）</li></ul></li></ul><p><em>低配版的意义</em></p><ul><li>给定⼀个程序正确运⾏的 specification，原则上我们能够写出动态分析的⽅法验证程序运⾏时有没有破坏这个 specification</li><li>但有时候验证⼀个完整的 specification 过于复杂或者条件不允许（⽐如我们的实验，⽐如计算资源受限）</li><li>但此时如果能够从这个 full specification 推出⼀些弱化的 specification，从⽽更加容易的实现⼀些 Sanitizer，那么即使精度可能没那么⾼，但实际中会有很好的效果！</li></ul><h2 id="总结">总结</h2><p>即使已经学了很多并发控制的⼯具，⼈类依然会犯错<br>死锁就是其中⼀⼤类</p><ul><li>死锁可以通过破坏其必要条件来避免</li><li>也可以通过动态的合理分配来避免</li><li>也可以通过动态分析来检测</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-07并发-同步(进阶)</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5-%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-07%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="读者-写者问题">读者-写者问题</h2><p>多个线程想要读取某个数据，有⼀个或多个线程需要写某个数据</p><ul><li>任何数量的读者都可以同时进行“读”操作（读-读不需要互斥）</li><li>但⼀次只能有⼀个写者进⾏“写”操作 （写-写互斥）</li><li>如果有⼀个写者在写，那么此刻没有读者（写-读互斥）</li></ul><p>实现“读写锁”（readers/writers lock）来保护共享数据</p><ul><li>其可以允许多个“读者”同时访问共享数据，只要他们中没有⼀个修改该数据</li><li>⼀次只能有⼀个“写者”可以持有读写锁进⼊临界区，因此可以安全的读和写数据</li></ul><p>分别给当前读者和写者是否可以进入临界区的条件</p><ul><li>对读者：如果临界区为空 or 临界区有其它读者，可进入</li><li>对写着：只有临界区为空才可进入</li></ul><p>实现 1：读者优先</p><ul><li>如果⼀直有读者反复进⼊临界区，那么写者就会进⼊不了临界区，从⽽饿死 (starvation)</li></ul><p><img src="2025060794.png" alt=""></p><p>实现 2：写者优先</p><ul><li>如果有写者想要进⼊临界区，那么其应该阻⽌后来的读者尝试进⼊临界区</li><li>如果⼀直有写者想要进⼊临界区，那么读者就会进⼊不了临界区，从⽽饿死 (starvation)</li></ul><p>实现 3：给线程排队</p><p>排队：ticket lock<br><img src="2025060798.png" alt=""></p><p>实现<br><img src="2025060705.png" alt=""></p><h2 id="哲学家就餐问题">哲学家就餐问题</h2><p><strong>背景</strong><br>五位哲学家围坐在⼀张圆形餐桌旁，做以下两件事情之⼀：吃饭或者思考。<br>每位哲学家之间各有⼀只筷⼦。哲学家必须同时得到左右⼿的筷⼦才能吃东⻄。<br>哲学家们怎么办才能⽐较合理的吃到饭？</p><ul><li>不会死锁、没有饿死、并发度⾼？</li></ul><p><strong>死锁和饿死</strong></p><ul><li>死锁 (Deadlock) 和饿死 (starvation) 都关乎活性 (liveness) — 死锁和饿死并没有违背安全性</li><li>饿死即为⼀个线程在有限时间内⽆法⾏进</li><li><strong>死锁</strong>是⼀类特殊的“饿死”，其达成的条件是多个线程形成⼀个等待环，⼀个线程的⾏进需要环内的另外⼀个线程做某个动作：显然环状意味着这个等待条件永远⽆法发⽣</li><li>死锁⼀定饿死，饿死并不⼀定死锁（⽐如运⽓不好，⼀直被其他线程抢占临界区）</li></ul><p><img src="2025060796.png" alt=""><br><img src="2025060767.png" alt=""></p><h2 id="总结">总结</h2><ul><li>除了互斥这种简单的控制外，我们还需要控制线程的顺序、相对关系等</li><li>条件变量可以帮助实现适⽤于任何同步条件（注意使⽤⽅法，需要配合互斥锁）<ul><li>基于 wait、signal 原语可以实现算法的并发</li></ul></li><li>信号量是更加容易使⽤的同步⼯具<ul><li>其具有状态记忆，可以看成初始资源</li></ul></li><li>同步经典问题：⽣产者-消费者问题、读者-写者问题（公平性问题）、哲学家进餐问题 （死锁、饿死问题）</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-06并发-同步</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-06%E5%B9%B6%E5%8F%91-%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>同步 Synchronization：控制并发，使得 “两个或两个以上随时间变化的量在变化过程中保持⼀定的相对关系”</p><h2 id="生产者-消费者问题">生产者-消费者问题</h2><p>背景：⼀个或多个线程共享⼀个数据缓冲区问题，该缓冲区容量有上限（有界缓冲区）</p><p>线程分为两类：⼀类⽣产数据（⽣产者），⼀类消费数据（消费者）</p><p>简化：</p><ul><li>生产=打印左括号</li><li>消费=打印右括号</li><li>缓冲区：括号的嵌套深度</li></ul><p>——要实现同步，其实就是需要⽣产者和消费者不能不受控制的打印括号， ⽽是在某些“条件”满⾜的情况下才能允许打印：受控的线程！</p><p><strong>条件变量</strong><br>用于标记某个用于同步条件的变量，两个相关操作</p><ul><li><code>cond_wait(cond_t *cv, mutex_t *lk)</code></li><li><code>cond_signal(cond_t *cv)</code><ul><li>唤醒一个等在条件变量 cv 上的一个阻塞线程</li></ul></li></ul><p>实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">conditional_variable</span> &#123;</span><br>usigned value;<br>&#125; <span class="hljs-type">cond_t</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cond_wait</span><span class="hljs-params">(<span class="hljs-type">cond_t</span> *cv, <span class="hljs-type">mutex_t</span> *lk)</span>&#123;<br><span class="hljs-type">int</span> val = <span class="hljs-type">atomic_load</span>(&amp;cv-&gt;value);<br>mutex_unlock(lk);<br>futex_wait(&amp;cv-&gt;value, val);<br>mutex_lock(lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cond_signal</span><span class="hljs-params">(<span class="hljs-type">cond_t</span> *cv)</span> &#123;<br>atomic_fetch_add(&amp;cv-&gt;value, <span class="hljs-number">1</span>);<br>futex_wake(&amp;cv-&gt;value);<br>&#125;<br></code></pre></td></tr></table></figure><p>条件覆盖：<code>cond_broadcast(cond_t *cv)</code></p><ul><li>⼀次唤醒所有线程即可，那些需要被正确唤醒的⾃然会醒来做相应的事情，⽽那些不该唤醒的，反正需要 while 循环⼀次在此判定是否符合条件，不符合条件就再“睡”即可，因此不会影响正确性</li></ul><p>条件覆盖下的生产者消费者问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">T_produce</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>mutex_lock(&amp;lk);<br><span class="hljs-keyword">while</span> (!CAN_PRODUCE) &#123;<br>cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 进入时释放锁 返回时获取锁</span><br>&#125;<br>assert(CAN_PRODUCE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>depth++;<br>cond_broadcast(&amp;cv); <span class="hljs-comment">// 唤醒所有 都会进入while重新判断</span><br>mutex_unlock(&amp;lk);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T_consume</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>mutex_lock(&amp;lk);<br><span class="hljs-keyword">while</span> (!CAN_CONSUME) &#123;<br>  cond_wait(&amp;cv, &amp;lk); <span class="hljs-comment">// 进入时释放锁 返回时获取锁</span><br>  &#125;<br>  assert(CAN_CONSUME);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>  depth--;<br>  cond_broadcast(&amp;cv); <span class="hljs-comment">// 唤醒所有 都会进入while重新判断</span><br>  mutex_unlock(&amp;lk);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量运用">条件变量运用</h2><p>有向无环图 e.g. Edit Distance 问题</p><ul><li>一个生产者：遍历图找到可以执行的任务放入 buffer</li><li>多个消费者：从 buffer 中取出任务执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">T_worker</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>consume().run();<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">T_scheduler</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span> (!jobs.empty()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j : jobs.find_ready()) &#123;<br>produce(j);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印 fish</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> A = <span class="hljs-number">1</span>, B, C, D, E, F, &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rule</span> &#123;</span><br>  <span class="hljs-type">int</span> from, ch, to;<br>&#125; rules[] = &#123;<br>    &#123;A, <span class="hljs-string">&#x27;&lt;&#x27;</span>, B&#125;,<br>    &#123;B, <span class="hljs-string">&#x27;&gt;&#x27;</span>, C&#125;,<br>    &#123;C, <span class="hljs-string">&#x27;&lt;&#x27;</span>, D&#125;,<br>    &#123;A, <span class="hljs-string">&#x27;&gt;&#x27;</span>, E&#125;,<br>    &#123;E, <span class="hljs-string">&#x27;&lt;&#x27;</span>, F&#125;,<br>    &#123;F, <span class="hljs-string">&#x27;&gt;&#x27;</span>, D&#125;,<br>    &#123;D, <span class="hljs-string">&#x27;_&#x27;</span>, A&#125;,<br>&#125;;<br><br><span class="hljs-type">int</span> current = A, quota = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">mutex_t</span> lk = MUTEX_INIT();<br><span class="hljs-type">cond_t</span> cv = COND_INIT();<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(rules); i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rule</span> *<span class="hljs-title">rule</span> =</span> &amp;rules[i];<br>        <span class="hljs-keyword">if</span> (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;<br>          <span class="hljs-keyword">return</span> rule-&gt;to;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">can_print</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>    <span class="hljs-keyword">return</span> next(ch) != <span class="hljs-number">0</span> &amp;&amp; quota &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fish_before</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">while</span> (!can_print(ch)) &#123;<br>        cond_wait(&amp;cv, &amp;lk);<br>    &#125;<br>    quota--;<br>    mutex_unlock(&amp;lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fish_after</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>    mutex_lock(&amp;lk);<br>    quota++;<br>    current = next(ch);<br>    assert(current);<br>    cond_broadcast(&amp;cv);<br>    mutex_unlock(&amp;lk);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> roles[] = <span class="hljs-string">&quot;.&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fish_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>    <span class="hljs-type">char</span> role = roles[id];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        fish_before(role);<br>        <span class="hljs-built_in">putchar</span>(role); <span class="hljs-comment">// Not lock-protected</span><br>        fish_after(role);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(roles); i++)<br>        create(fish_thread);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="信号量">信号量</h2><ul><li>条件变量是⽆记忆的，因此需要程序员⼿动进⾏额外的条件判定</li><li>⼀个很⾃然的需求就是能否有⼀个同步原语能够⾃带“状态”，然后根据预设好的约定，“状态”不满⾜就阻塞，否则就唤醒？<ul><li>⼀个⾃带“整数”状态的同步原语就是信号量！</li></ul></li></ul><p>信号量代表着一个整数值变量，只能通过两个原子操作能够改变这个变量</p><ul><li><code>P(sem_t *sem)</code> 如果 sem 的值不是正数就阻塞⾃⼰，否则将 sem 的值减⼀后返回运⾏</li><li><code>V(sem_t *sem)</code> 将信号量 sem 的值加 1，如果有⼀个或多个线程阻塞在这个信号量上，选择⼀个唤醒</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span> </span>&#123;<br>atomic&#123;<br><span class="hljs-built_in">wait_until</span>(sem-&gt;count &gt; <span class="hljs-number">0</span>) &#123;<br>sem-&gt;count--;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">V</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span> </span>&#123;<br>atomic&#123;<br>sem-&gt;count++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对信号量的“整数”理解</p><ul><li>初始“资源数”为 1，意味着互斥，只有⼀个能够获得这个资源，其释放这个资源，其他线程才能获取这个资源</li><li>初始“资源数”为 0 意味着阻塞，当前线程必须等待，只有未来某个线程增加⼀个资源，该阻塞线程才能继续⾏进，因此实现了“happens-before”的顺序控制</li><li>更多的“资源”意味着当前有很多资源可以⽤来“获取”，只有资源被获取完为 0，才会阻⽌下⼀ 个想要获取“资源”的线程。⽽只要已经获得资源的线程释放“资源”，下⼀个才能获取这个释放的“资源</li></ul><p><em>使用 P 获取资源，V 释放/增加 资源</em></p><p>利用信号量解决生产者-消费者问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">sem_t</span> empty; <span class="hljs-comment">// 缓冲区有多少空</span><br><span class="hljs-built_in">sem_init</span>(<span class="hljs-type">sem_t</span> &amp;empty, <span class="hljs-number">0</span>, MAX);<br><span class="hljs-type">sem_t</span> full; <span class="hljs-comment">// 缓冲区有多少资源</span><br><span class="hljs-built_in">sem_init</span>(<span class="hljs-type">sem_t</span> &amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">T_produce</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">P</span>(&amp;empty);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br><span class="hljs-built_in">V</span>(&amp;full);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">T_consume</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">P</span>(&amp;full);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br><span class="hljs-built_in">V</span>(&amp;empty);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-05并发-互斥(进阶)</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05%E5%B9%B6%E5%8F%91-%E4%BA%92%E6%96%A5-%E8%BF%9B%E9%98%B6/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-05%E5%B9%B6%E5%8F%91-%E4%BA%92%E6%96%A5-%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="自旋锁的改进">自旋锁的改进</h2><h3 id="排队">排队</h3><p>当一个线程在自旋等待（也叫忙等待，busy waiting）时，它一定能够最终进入临界区吗？</p><ul><li>不一定，如果一直有其它线程要进入临界区，并且这些其他线程⼀直被优先调度进入临界区（我们不能假定调度策略），那这个线程就可能会⼀直等在那里（违背了有界等待）</li><li>解决方法——<strong>排队</strong></li></ul><p>方法：每次尝试进入临界区就拿一个“号”（下一个尝试的“号”加一），等待“叫号”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">lock_ticket</span> &#123;<br><span class="hljs-type">int</span> ticket; <span class="hljs-comment">//当前发放的最大票号</span><br><span class="hljs-type">int</span> turn; <span class="hljs-comment">// 当前应进入的票号</span><br>&#125; <span class="hljs-type">lock_t</span>;<br><span class="hljs-type">lock_t</span> flag;<br></code></pre></td></tr></table></figure><p><img src="2025032170.png" alt=""></p><h3 id="更细粒度的锁">更细粒度的锁</h3><p>并不是所有线程都“彼此”需要互斥，我们应该给需要彼此互斥的线程池他们独有的“锁”，更加“细粒度”的锁可以提高并发性能。</p><p><img src="2025032190.png" alt=""></p><p>unlock 前应保证持有锁，否则可能会打开别人的锁</p><h2 id="在内核中实现自旋锁的问题">在内核中实现自旋锁的问题</h2><p>问题：某个线程持有了一个共享变量的 lock，发生中断，但该变量已被持有，中断优先级又很高（必须先完成），就会该中断导致不断等待<br><img src="2025032172.png" alt=""></p><p>xv6 中自旋锁的实现<br><img src="2025032169.png" alt=""></p><h2 id="应用程序里使用互斥锁问题">应用程序里使用互斥锁问题</h2><p><em>自旋锁本身存在的问题：</em></p><p>性能问题：除了进⼊临界区的线程，其他处理器上的线程都在空转</p><ul><li>如果临界区执⾏时间过⻓（⽤户线程的常态），其他线程浪费的 CPU 越多</li><li>此外，如果发⽣中断将临界区的线程切出去了，计算资源浪费更加严重</li></ul><p><strong>解决方案：yield</strong><br>直接 yield：利⽤系统调⽤ sched_yield () 直接让出 cpu，让其他线程获得 CPU 使⽤</p><ul><li>问题：<ul><li>yield 只是暂时让出 CPU，该线程还处在“ready”的阶段，随时可以被再次调度。</li><li>在获得锁之前，反复的“被调度—&gt;让出 CPU”会带来⼤量不必要的 contextswitches</li></ul></li></ul><p>解决方案：</p><ul><li>⽤户使⽤和释放锁应该和 OS 调度程序配合：<ul><li>mutex_lock (&amp;lk): 试图获得 lk，如果失败 (lk 已被持有)，利⽤系统调⽤<em>阻塞</em>该线程（此时不是就绪态，⽆法被调度了），让出 CPU 并将其加⼊<em>等待锁的队列</em>之中。否则，成功获得锁进⼊临界区。</li><li>mutex_unlock (&amp;lk): 释放锁，如果等待该锁的队列⾥有线程就利⽤系统调⽤ <em>选择⼀个唤醒</em>，使其变成就绪态（ready），从这个等待队列删除，并进⼊ 就绪的队列，可以被再次调度。</li></ul></li><li>操作系统需要对⼀个锁维持⼀个与其相关的队列<ul><li>当然，队列操作（如增加⼀个等待线程）需要内核的⾃旋锁保护</li></ul></li></ul><p>Linux 提供两个系统调用</p><ul><li><code>futex_wait (int *address, int expected)</code><ul><li>⾸先原⼦的 test 此时 address 指向的值和期待的值是否相等，相等才会将线程阻塞，否则⽴即返回给⽤户线程，使其可以⽴⻢再次尝试 lock！</li></ul></li><li><code>futex_wake(int *address)</code><ul><li>唤醒一个等待 address 指向的锁的线程</li></ul></li></ul><p><em>利用系统调用进行加锁的问题</em></p><ul><li>虽然避免了⾃旋浪费 CPU，但每次进⾏ Lock/Unlock 都要<em>陷⼊内核</em>（这当然需要额外的开销，⽐如上下⽂切换）<ul><li>只有内核才能让线程“阻塞”、“yield”，线程⽆法独⽴完成这样的操作</li></ul></li><li>但是其实真实的 workload 中，多个线程抢⼀个锁的事件发⽣的频率并不⼤， 很多时候往往是⼀个线程加⼀个锁进⾏保护<ul><li>这个时候使⽤之前的 spinlock 会更加快速！因为其不⽤陷⼊内核，也不会空转</li></ul></li></ul><p>Linux 的 Futex 是这样的<em>两阶段</em>锁</p><ul><li>Fast Path：自旋一次：一次原子指令，成功直接进入临界区</li><li>Slow Path：自旋失败：按照情况利用系统调用 futex_wait，阻塞自己</li></ul><h2 id="并发数据结构">并发数据结构</h2><p>并发数据结构：线程安全的数据结构指的⼀个数据结构可以被多个线程并发的访问</p><ul><li>要达成这样的数据结构⼀般我们需要在访问和更新该数据结构时上锁（⼀把或多把）</li></ul><p>最简单的做法：⼀把⼤锁（One Big Lock）！所有访问都串⾏化。但在多处理器时代，可能会造成性能瓶颈</p><p>层级化的并发解决方案</p><ul><li>并不是所有并发都是硬件提供的，也不是都是软件</li><li>⽽是，硬件提供了基本的原⼦指令（如 cmpxchg），操作系统提供了⼀些并发 (同步) 的原语（如 futex_wait, futex_wake），库函数包裹⼀些好⽤的 APIs (如 pthread_mutex_lock, pthread_mutex_unlock)，最后⽤户使⽤这些原语来构建正确和⾼效的并发程序</li></ul><h2 id="总结">总结</h2><ul><li>软件上实现“互斥”很难，⽽且在现代计算机系统下也不正确</li><li>通过硬件⽀持的原⼦指令可以实现⾃旋锁，从⽽正确实现互斥</li><li>然⽽实际的互斥锁有更多的考量：<ul><li>在内核中的互斥锁要考虑中断带来的麻烦</li><li>⽽在⽤户态由于临界区过⻓，⾃旋出现性能问题，⽽解决这个问题需要操作系统和⽤户态共同完成⼀个 wait-wakeup 的原语，正确的实现同样不简单！</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-04并发-互斥</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04%E5%B9%B6%E5%8F%91-%E4%BA%92%E6%96%A5/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-04%E5%B9%B6%E5%8F%91-%E4%BA%92%E6%96%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="临界区">临界区</h2><p><strong>临界区</strong> critical section：访问共享资源的一段代码，资源通常是一个变量或数据结构</p><p><strong>竞态条件</strong> race condition：出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致非预期的结果</p><ul><li>当程序含有一个或多个竞态条件，程序的输出会因运行而异，具体取决于哪些线程在何时运行，因此结果是不确定的 non-derministic</li></ul><blockquote><p>如何设计机制使得临界区避免出现竞态条件是“并发”的重要主题！</p></blockquote><p>对于⼀个<em>运行</em>程序 (尤其是并发程序) 的两个重要属性：</p><ul><li><strong>安全性</strong>：“没有坏事发生”<ul><li>要求执行中的<em>任何</em>有限步骤内都保持这个性质</li></ul></li><li><strong>活性</strong>：“好事终将发生”<ul><li>要求只要在<em>最终</em>能满足要求即可，一个隐含的要求是执行中不能发生“不可挽回的步骤”</li></ul></li></ul><p>临界区的解决方案需满足的条件：</p><ol><li><strong>互斥</strong> Mutual Exclusion：临界区中最多只能有一个线程 Safety</li><li><strong>行进</strong> Progress：如果当前临界区内没有线程，并且有线程想要进⼊临界区，那么最终某个想要进⼊临界区的线程会进⼊该临界区 (liveness)</li><li><strong>有界等待</strong> bounded waiting：如果某个线程想要进⼊临界区，那么其等待的期限有限（期间其他线程进⼊该临界区次数有上限），不可⼀直排队等待 (Fairness/No starvation)</li></ol><p>除此之外，还应关心<strong>性能</strong> performance:</p><ul><li><em>进入</em>和<em>退出</em>该临界区的两个操作应该相对于在该临界区内做的计算而言尽可能的小</li></ul><blockquote><p>经验法则 (Rule of thumb)<br>当设计并发算法时，优先考虑安全性！(but don’t forget liveness and performance).</p></blockquote><h2 id="锁-Locks">锁 Locks</h2><p>锁是⼀个变量，其保存了锁在某⼀时刻的状态。</p><ul><li>要么是可用的（available，或 unlocked，或 free），表示没有线程持有锁</li><li>要么是被占用的（acquired，或 locked，或 held），表示有⼀个线程持有锁，正处于临界区。</li></ul><p>其提供两个配对操作：</p><ul><li><code>lock()/acquire()</code>: 调用 lock() 或 acquire() 尝试获取锁，如果没有其他线程持有锁， 该线程会获得锁，进入临界区，否则 (该锁已经被持有了) 不会返回 (该线程会卡在那里)</li><li><code>unlock()/release()</code>: 调用 unlock() 或 release()，锁就变成可用了（可被获得）, 之前如果有因获得锁操作没成功卡在那的线程，那么其中⼀个会进入临界区</li></ul><blockquote><p>锁为程序员提供了最⼩程度的调度控制，通过给临界区加锁，保证临界区内只有⼀个活跃变量（互斥）。</p></blockquote><h3 id="尝试-1：关中断">尝试 1：关中断</h3><p>题外话：NMI (Non-Maskable Interrupts)<br>不是所有中断都是可以被屏蔽的，处理器有<em>不可屏蔽中断</em> (Non-Maskable Interrupts)</p><ul><li>主要是为了一些不可处理或通知一些不可恢复的错误<ul><li>如内部芯片系统错误、系统数据损坏等</li></ul></li><li>如果操作系统的中断处理程序崩掉了（死循环），然后此时又在关中断，那么利用 NMI 可以监控这个错误，并给出处理（如重启计算机）<ul><li>可行方法：设置硬件定时触发 NMI，操作系统（正常运行下）定时复位定时器以使得 NMI 不被触发，但操作系统⼀旦不正常了，timeout 会触发 NMI</li></ul></li></ul><p><strong>问题：</strong></p><ol><li>临界区的代码死循环了-&gt;整个系统也卡死了</li><li>中断关闭时间过长会导致很多其他重要的外界响应丢失（比如错过了磁盘 I/O 的完成事件）</li><li>关中断是特权指令，用户态的应用是无法执行的，只有操作系统有这个权限</li><li>多处理器无效（单处理器是可行的）<ol><li>每个处理器有独立的寄存器组</li><li>中断是每个处理器内部状态</li></ol></li></ol><h3 id="尝试-2：通过软件-Lock-标志">尝试 2：通过软件 (Lock 标志)</h3><p>使用⼀个标志来表达此时锁的状态，比如：为 1 就是已被占用，为 0 就是可用的。对应的 lock() 和 unlock()</p><p>——完全存在两个线程同时发现 flag 为 0，然后都进入临界区的可能 (not safe)</p><h3 id="尝试-3：互斥的-test">尝试 3：互斥的 test</h3><p><img src="2025031418.png" alt=""></p><ul><li>在内存顺序一致性模型下成立</li><li>该方法让每个线程“严格轮转”</li></ul><p><strong>问题</strong>：一个线程能否得到一个锁完全依赖于另外一个线程是否先进入了临界区，违背了 liveness 性质</p><h3 id="Peterson-算法">Peterson 算法</h3><p><img src="2025031400.png" alt=""><br>在标记后就将 flag 轮转到下一位，可以保证 flag==self 两个线程结果不一样<br>证明：</p><p><em>Peterson 算法能够保持互斥性</em></p><p><img src="2025031497.png" alt=""></p><p>最后进入的一定是 T2，所以前一个状态是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,4,3,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><br><img src="2025031498.png" alt=""></p><p>两种前驱假设都不成立</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,3,3,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">0==i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">==</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 也为 True，无法进入临界区</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">?</mo><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[?,4,2,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mclose">?</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>：T2 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>g</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">flag=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 会将 flag 置为 1，不满足下一步的 flag=0</li></ul><p><img src="2025031474.png" alt=""></p><p><em>保持“行进”</em><br><img src="2025031425.png" alt=""></p><p><em>保持“有界等待”</em><br><img src="2025031439.png" alt=""></p><blockquote><p>模型检测 Model checking</p><p>Model checking is a method for formally verifying finite-state systems</p></blockquote><p>现实的 load 和 store 都不是原子的，甚至两个线程同⼀刻读的 flag 都不⼀致。 因此现实架构上的 peterson 算法其实是错误的。</p><blockquote><p>刚刚的证明都基于 SC 的情况。</p></blockquote><h2 id="硬件支持的锁">硬件支持的锁</h2><p><img src="2025031486.png" alt=""></p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// cmpxchg做的事：</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">flag</span>==expected:<br><span class="hljs-built_in">flag</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br>expected = <span class="hljs-built_in">flag</span><br></code></pre></td></tr></table></figure><p><strong>自旋锁的实现</strong> Spin Lock<br><img src="2025031464.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-03并发-多处理器编程</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03%E5%B9%B6%E5%8F%91-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-03%E5%B9%B6%E5%8F%91-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>操作系统本身就是世界上第一个并发程序<br>并发就是操作系统的核心之一</p><ul><li>操作系统的很多内部数据结构（如进程列表、页表、文件系统结构）都得考虑数据竞争的可能。</li></ul><p>并发的很多技术都是源⾃于操作系统的设计需求和其相应的解决方案</p></blockquote><h2 id="多线程编程入门">多线程编程入门</h2><h3 id="并发的基本单位是线程-Thread">并发的基本单位是线程 Thread</h3><p>什么是线程：共享内存的执行流</p><ul><li>拥有<strong>独立</strong>的“上下文”和栈帧列表</li><li><strong>共享</strong>全局变量、堆空间</li></ul><p><img src="2025031969.png" alt=""></p><p>多线程编程模型<br><img src="2025031914.png" alt=""></p><p>线程的生存周期：</p><ul><li>线程的一生经历初始化、就绪、运行、等待和结束的周期</li><li>只有在运行阶段，其 Context 才会在 CPU 上，其余都在内核栈上，当线程处于就绪阶段时其 TCB 在 OS 维护的 ready 列表上等待调度，当线程处于等待阶段时，其 TCB 在 OS 维护的同步等待列表上等待同步事件发生</li></ul><p><img src="2025032070.png" alt=""></p><h2 id="原子性丧失">原子性丧失</h2><p><strong>原子性</strong>：一个原子性的操作即一个在其“更高”的层面上无法感知到它的实现是由多个部分组成的，一般来说，其具有两个属性：</p><ul><li>All or nothing: 一个原子性操作要么会按照预想那样一次全部执行完毕，要么一点也不做，不会给外界暴露中间态</li><li>Isolation: 一个原子性的操作共享变量时中途不会被其它操作干扰，其它所有关于这个共享变量的操作要么在这个原子性操作之前，要么在其之后</li></ul><p>原子性的丧失</p><p><img src="2025032027.png" alt=""><br><img src="2025032011.png" alt=""></p><p>单处理器多线程</p><ul><li>线程在运行时可能被中断，切换到另一个线程执行（All or nothing 无法保证）</li></ul><p>多处理器多线程</p><ul><li>线程根本就是并行执行的（All or nothing 和 Isolate 都无法保证）</li></ul><h2 id="顺序性丧失">顺序性丧失</h2><p><strong>顺序性</strong>：程序语句按照既定的顺序执行<br>然而，只要不影响语义，其实指令是否按顺序执行并不重要</p><ul><li>编译器会通过 reorder instruction 来优化程序</li><li>这些优化在单线程下往往没有问题，但一旦到了多线程，很多逻辑就错了</li></ul><p><img src="2025032089-1.png" alt=""><br><strong>控制执行顺序</strong></p><ul><li>方法一：在代码中插入“优化不能穿越”的 barrier</li><li>方法二：使用 volatile 变量，标记每次 load/store 为不可优化</li></ul><h2 id="全局一致性丧失">全局一致性丧失</h2><p><strong>顺序一致性模型</strong>提供了以下保证：</p><ul><li>不同核心看到的访存操作顺序完全一致，这个顺序称为<em>全局顺序</em></li><li>在这个全局顺序中，每个核心自己的读写操作可见顺序必须与其程序程序保持一致</li></ul><p><img src="2025032040.png" alt=""></p><ul><li>x86 系列的 CPU 不支持顺序一致性</li><li>要支持顺序一致性在架构和性能上要付出很多</li></ul><p><strong>TSO 内存模型</strong></p><p><img src="2025032051.png" alt=""></p><p><strong>宽松内存模型</strong> Relaxed Memory Model</p><p><img src="2025032086.png" alt=""></p><h2 id="总结">总结</h2><ul><li>并发的基本单位是线程<ul><li>即共享部分内存的状态机（有自己的私有状态）</li><li>其状态的变化可以随着另外的进程的“步进”而被动改变</li></ul></li><li>Posix 提供的标准多线程编程库 Pthread</li><li>多处理器编程充满挑战，数据竞争下难以保障正确<ul><li>原子性、顺序性和全局一致性都会丧失</li></ul></li></ul><hr><p><em>Thread 哪些东西是独有的和哪些东西是共享的?</em></p><ul><li>独享：寄存器、栈空间、堆空间</li><li>共享：全局变量</li></ul><p>虽然栈空间是每个线程独享的，但这个独享只是一种线程间的“默契”约定而已</p><ul><li>操作系统并没有强制其它线程不能访问这个线程的栈空间</li><li>对线程而言，是没有地址空间“保护”这个概念的<ul><li>地址空间“保护”针对的对象是：<em>进程</em>！</li></ul></li><li>在操作系统眼⾥，线程本来都是隶属于⼀个进程，他们是“协作”的关系，而不应该存有相互的“恶意”行为</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-02绪论-操作系统的各种视角</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02%E7%BB%AA%E8%AE%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E8%A7%86%E8%A7%92/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-02%E7%BB%AA%E8%AE%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%84%E7%A7%8D%E8%A7%86%E8%A7%92/</url>
    
    <content type="html"><![CDATA[<h2 id="应用视角下的操作系统">应用视角下的操作系统</h2><h3 id="什么是程序">什么是程序</h3><blockquote><p>一个理论模型：程序就是状态机</p></blockquote><p>对（二进制）程序而言：</p><ul><li>状态 = M (内存) + E (寄存器)</li><li>初始状态 = 程序启动时操作系统给安排的状态</li><li>状态转移 = 执行一条指令</li></ul><h3 id="程序的状态机模型">程序的状态机模型</h3><p>特殊的指令 —— <strong>syscall</strong></p><ul><li>把 (M, R) 完全交给操作系统，任其修改</li><li>实现与操作系统中的其它对象交互<ul><li>读写文件/操作系统状态（例如把文件内容写入 M）</li><li>改变进程（运行中状态机）的状态，例如创建进程/销毁自己</li></ul></li></ul><p><img src="2025031915.png" alt=""></p><p>从这个角度看，程序=计算+syscall，而操作系统就像是 syscall 的解释器</p><ul><li>普通的指令有 cpu 解释</li><li>syscall 则由操作系统解释（当然，最终操作系统还是要借助 cpu 解释）</li></ul><h3 id="理解高级语言程序">理解高级语言程序</h3><p>C 程序的状态机模型（简化语义，semantics）</p><ul><li>状态 = 堆 + 栈 + 全局变量</li><li>初始状态 = 仅有一个 frame <code>main(argc, argv)</code>；全局变量为初始值</li><li>迁移 = 执行一条简单语句<ul><li>执行当前调用栈栈顶的那个栈指针(frames.top.PC 处)的简单语句</li><li>如果是函数调用的话，本质就是压入一个新的栈帧 (stack frame)，并设置这个新的 frame.PC = 所调用函数的入口</li><li>函数返回 = pop frame</li></ul></li></ul><h3 id="为什么能“追踪”进程">为什么能“追踪”进程</h3><p>因为所有进程都在“操作系统”的监控之下！</p><ul><li>进程某种意义上是运行在“操作系统”这样的⼀个虚拟机中，而不是直面硬件，所以操作系统清楚进程的⼀切，也能修改其⼀切</li></ul><p>操作系统为进程提供了 <code>ptrace</code> 系统调用，其可以帮助⼀个进程去查看另外一个进程，甚至是修改另外进程的运行时的寄存器，以至于代码植入</p><ul><li>Strace(允许我们观测状态机的执行过程)、GDB 背后都是 ptrace 系统调用</li></ul><h3 id="操作系统中-“任何程序”-的一生">操作系统中 “任何程序” 的一生</h3><p><img src="2025031999.png" alt=""></p><p>所有的这些程序都是在操作系统 API (syscall) 和操作系统中的对象上构建</p><ul><li>本质都是调用 syscall 的状态机</li><li>对于这些应用而言，操作系统就是⼀个帮助解释这些 syscall 的存在而已，其和能够帮他们解释普通计算指令的 CPU 无异</li></ul><blockquote><p>简而言之，在应用眼中，操作系统就是 syscall 的解释器</p></blockquote><h2 id="硬件视角下的操作系统">硬件视角下的操作系统</h2><p><em>数字电路</em>与状态机</p><ul><li>状态 = 寄存器保存的值</li><li>初始状态 = REST</li><li>迁移 = 组合逻辑电路计算寄存器下一个时钟周期的值</li></ul><h3 id="计算机硬件的状态机模型">计算机硬件的状态机模型</h3><p>整个计算机系统也是一个状态机</p><ul><li>状态：内存和寄存器数值</li><li>初始状态：CPU Reset</li><li>状态迁移：<ul><li>任意选择一个处理器 CPU</li><li>响应处理器外部中断</li><li>从 CPU 的 PC 取指令执行</li></ul></li></ul><p>为了让“操作系统”这个程序能正确启动，计算机硬件系统必定和程序员之间存在<em>约定</em>：</p><ul><li>首先是 Reset 的状态</li><li>然后是 Reset 以后执行的程序应该做什么</li></ul><p><img src="2025031999-1.png" alt=""></p><h3 id="两种执行流">两种执行流</h3><ul><li>普通控制流 normal control flow<ul><li>即遵循冯诺依曼结构的指令循环</li></ul></li><li>异常控制流 Exceptional Control Flow<ul><li>不是线性的正常的指令流（PC 的转移不受正常的自增、或者 branch instructions 控制）</li><li>由“外界”强制转移到另一块指令入口（强制赋予 PC）</li></ul></li></ul><h3 id="上下文切换-Context-Switch">上下文切换 Context Switch</h3><ul><li>进入另外入口前，CPU 还要做“<strong>现场保护</strong>”</li><li>所谓的现场就是当前 CPU 的⼀些寄存器的值（因为这些不像是栈、堆保存在内存中，⼀旦由于为了执行另外的指令流而赋予了其他值，旧的值就“消失”了）</li><li>这就是上下文<ul><li>不同的指令架构上下文会有些区别（AM 统⼀抽象为 Context 结构体），大体上包含<ul><li>PC 寄存器（CS、IP）、栈指针（SP、SS）、控制寄存器、 virtual address translation 入口寄存器、其他一些数据寄存器</li></ul></li><li>这个“现场”将会保存在内核栈中（安全可靠），等异常控制流处理完毕时，并再次调度这个执行流时，这个“现场”将会被弹出到 CPU 上，恢复之前的执行</li></ul></li></ul><hr><p>计算机系统的一切行为都是可观测、可理解的。</p><ul><li>处理器的任务就是重复着进行着取指令和执行指令</li><li>厂商配置好处理器 Reset 后的行为：先运行 Firmware，再加载操作系统</li><li>操作系统就是一个 C 程序<ul><li>只不过其拥有完整计算机的控制权限，包括中断和 I/O 设备</li></ul></li></ul><blockquote><p>简而言之，在硬件眼中，操作系统就是个 C 程序，只是能直接访问计算机硬件</p></blockquote><h2 id="抽象视角下的操作系统">抽象视角下的操作系统</h2><p>操作系统本身就是状态机</p><ul><li>内部状态为用户进程的元信息、内核栈、内核堆、操作系统代码区</li><li>操作系统在硬件加载完毕和初始化之后就成为了 Interrupt/trap/fault handler</li><li>操作系统的状态是<strong>被动</strong>迁移的，用户程序执行 syscall 才会改变操作系统状态、硬件中断事件发生后（如时钟中断）才会改变操作系统状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-01绪论-操作系统概述</title>
    <link href="/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01%E7%BB%AA%E8%AE%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2025/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01%E7%BB%AA%E8%AE%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>课程大纲</p><ul><li>绪论：概论、硬件/应用/抽象视角下的操作系统</li><li>并发：多处理器编程、互斥、同步、真实世界的并发编程</li><li>虚拟化：进程、线程、调度、地址空间</li><li>持久化：输入输出设备、驱动程序与文件系统、数据可靠性</li></ul></blockquote><h2 id="什么是操作系统">什么是操作系统</h2><p>三个重用的线索：</p><ul><li>硬件-计算机</li><li>软件-程序</li><li>操作系统-管理硬件和软件的软件</li></ul><p><strong>软硬件的接口</strong>：若没有操作系统，程序将直面底层硬件</p><ul><li>非统一接口，含有大量细节</li><li>有限制</li><li>不安全</li></ul><h2 id="操作系统的功能">操作系统的功能</h2><h3 id="提供简洁-、易用的物理层抽象">提供简洁 、易用的物理层抽象</h3><ul><li>拥有无限的内存，专属的机器</li><li>高级的对象：文件、进程、信号</li><li>屏蔽限制</li></ul><p>对<strong>程序</strong>来说：程序的“机器”就是操作系统提供的<em>进程</em>这个抽象，每个程序运行在自己的进程上，进程提供了比原始硬件更优美的接口。<br><img src="2025031967.png" alt=""></p><p>对<strong>操作系统</strong>而言：把“难看”的硬件接口翻译成了友好易用的接口，为每个程序提供它们的进程。<br><img src="2025031905.png" alt=""></p><h3 id="资源的管理">资源的管理</h3><ul><li>分配</li><li>保护</li><li>分享</li></ul><p><img src="2025031991.png" alt=""></p><h3 id="操作系统的底线是支持应用程序的运行">操作系统的底线是支持应用程序的运行</h3><ul><li>自身反而次要</li><li>理想情况下操作系统自身的资源开支应该不大</li><li>应用程序运行应该尽可能快</li></ul><h3 id="其它">其它</h3><ul><li>可靠性：尽可能不崩溃，即使崩溃，尽可能不损坏业务逻辑</li><li>安全：对抗恶意的程序</li><li>能源：尽可能省电</li><li>…</li></ul><h2 id="总结">总结</h2><p>操作系统</p><ul><li>提供了方便的抽象来处理各种硬件<ul><li>易用、受保护</li></ul></li><li>协调资源</li><li>给应用提供了方便的系统服务，优化性能</li><li>计算机硬件发展和操作系统协同进化</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算2-记忆</title>
    <link href="/2025/08/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972-%E8%AE%B0%E5%BF%86/"/>
    <url>/2025/08/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972-%E8%AE%B0%E5%BF%86/</url>
    
    <content type="html"><![CDATA[<p>软件工程：应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件</p><p>管理团队方法：建立团队章程、持续成功、和谐沟通、不断总结、避免团队杀手<br>质量保障措施：需求/体系结构/详细设计/构造/测试 + 评审/度量/测试<br>配置管理：标识配置项 版本管理 变更控制 配置审计 状态报告 软件发布管理</p><p>需求：</p><ol><li>用户为了解决问题或达到某些目标所需要的条件或能力</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力</li><li>对 1 或 2 中的一个条件或一种能力的一种文档化表述</li></ol><p>需求规格说明</p><ul><li>方便交流；软件需求需要进行广泛交流，所以要把需求文档化</li><li>方便任务分配，制定工作计划，进行跟踪和度量</li><li>在书写需求规格过程中，才把问题分析的结果转化为系统级需求，方便明确需求</li></ul><p>软件设计：关于软件对象的设计，是一种设计活动。既指软件对象实现的规格说明，又指这个规格说明产生的过程。</p><p>体系结构的概念：部件，连接件，配置</p><ul><li>部件：承载系统的主要功能，包括处理和数据</li><li>连接件：定义了部件间的交互</li><li>配置：部件与连接件之间的关联方式</li></ul><p>体系结构风格：</p><ol><li>主程序子进程<ol><li>优点：流程清晰，易于理解；强控制性</li><li>缺点：强耦合，非常依赖交互方的接口规格，难以修改和复用；限制部件间的数据交互，产生公共耦合</li></ol></li><li>面向对象<ol><li>优点：内部实现的可修改性；易开发、易理解、易复用</li><li>缺点：接口、标识的耦合性；难以理解、高耦合性以及数据的不一致视图</li></ol></li><li>分层<ol><li>优点：易于理解；支持并行开发；可复用性和内部可修改性</li><li>缺点：交互协议难以修改；性能损失；难以确定层次数量和粒度</li></ol></li><li>MVC<ol><li>优点：易开发；视图和控制的可修改性；适宜于网络系统开发的特征</li><li>缺点：复杂性；模型修改困难</li></ol></li></ol><p>体系结构设计过程</p><ol><li>分析关键需求和项目约束</li><li>选择体系结构风格</li><li>进行体系结构逻辑设计</li><li>进行体系结构（实现）设计</li><li>完善体系结构设计</li><li>添加构件接口</li><li>迭代 3-6</li></ol><p>包的设计原则</p><ol><li>重用发布等价原则 REP</li><li>共同封闭原则 CCP</li><li>共同重用原则 CRP</li><li>无环依赖原则 ADP</li><li>稳定依赖原则 SDP</li><li>稳定抽象原则 SAP</li></ol><p>人机交互-可用性：</p><ol><li>易学性</li><li>效率</li><li>易记性</li><li>出错率</li><li>主观满意度</li></ol><p>界面设计注意事项</p><ol><li>简洁设计 7±2 原则</li><li>一致性设计 精神模型</li><li>低出错率设计</li><li>易记性设计</li><li>可视化设计要点</li><li>所见即所得</li></ol><p>控制风格</p><ol><li>集中式</li><li>委托式</li><li>分散式</li></ol><p>耦合：两个模块之间关系的复杂程度。包括内容、公共、重复、控制、印记、数据<br>内聚：一个模块内部的联系的紧密性。包括偶然、逻辑、时间、过程、通信、功能、信息</p><p>信息隐藏：每个模块都隐藏了重要设计决策的实现，因此只有该模块的组成部分才能知道详细信息。</p><p>模块化的原则</p><ol><li>全局变量是有害的</li><li>让代码清晰</li><li>不要重复</li><li>面向接口编程</li><li>迪米特法则</li><li>接口隔离原则</li><li>里氏替换原则</li><li>组合代替继承</li><li>单一责任原则</li></ol><p>OCP 开闭原则：对扩展开放，对修改关闭<br>DIP 依赖倒置原则：细节依赖于抽象</p><p>设计模式：</p><ol><li>策略模式：减少耦合、依赖倒置</li><li>抽象工厂模式：职责抽象、接口重用</li><li>单件模式：信息隐藏、职责抽象</li><li>迭代器模式：减少耦合、依赖倒置</li></ol><p>重构：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构<br>测试驱动开发：完成测试代码之后，程序员再编写程序代码，并在编程中重复执行测试代码，以验证程序代码的正确性。<br>结对编程：两位程序员并排工作，在相同的设计，算法，代码或测试上进行协作。</p><p>黑盒测试：将测试对象作为一个黑盒子，完全基于输入输出数据来判断测试对象的正确性</p><ul><li>等价类划分 边界值分析 决策表 状态转换</li></ul><p>白盒测试：将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作</p><ul><li>语句覆盖 条件覆盖 路径覆盖</li></ul><p>软件维护</p><ul><li>问题/环境发生变化 产品存在缺陷</li></ul><p>开发可维护软件的方法</p><ul><li>考虑软件的可变更性</li><li>为降低维护困难而开发</li></ul><p>演化式生命周期模型：初始开发 演化 服务 逐步淘汰 停止<br>逆向工程：分析目标系统，标识系统的部件及其交互关系，并使用其他形式或者更高层的抽象创建系统表现的过程<br>再工程：检查和改造一个目标系统，用新的模式及其实现复原该目标系统</p><p>软件生命周期模型：人们将软件从生产到报废的生命周期分割为不同阶段，各个阶段形成明确、连续的顺次过程，这些阶段划分就被称为软件生命周期模型。</p><ul><li>软件演化生命周期模型：需求工程-软件设计-软件实现-软件测试-软件交付-软件维护</li></ul><p>软件开发过程模型</p><ol><li>构建修复模型<ol><li>缺点：没有规范、没有分析需求</li><li>适用：小规模 个人开发</li></ol></li><li>瀑布模型<ol><li>允许活动出现反复和迭代，重点在于要求每个活动的结果必须要进行验证</li><li>优点：为软件开发活动定义了清晰的阶段划分</li><li>缺点：对文档期望过高；线性假设局限性；里程碑颗粒过粗</li></ol></li><li>增量迭代模型<ol><li>在项目开始时完成对项目前景和范围的界定，然后将后续开发活动组织为多个迭代、并行的瀑布开发模式</li><li>优点：符合软件开发实践情况；渐进交付加强用户反馈；缩短开发时间</li><li>缺点：需要完备清晰的项目前景和范围</li><li>适用：大规模软件系统</li></ol></li><li>演化模型<ol><li>将软件开发活动组织为多个迭代、并行的瀑布式开发活动。</li><li>优点：同上</li><li>缺点：在前代基础上进行修改和扩展，容易让后续迭代忽略分析和设计工作，退变为构建修复模式</li><li>适用：不稳定领域的大规模软件系统</li></ol></li><li>原型模型<ol><li>将需求开发活动展开为抛弃式原型开发活动和演化式原型开发活动</li><li>优点：加强了与用户的交流；适用于有大量不确定性的新领域</li><li>缺点：开发成本高；不舍得抛弃“抛弃式原型”，使得质量较差的代码进入最终产品</li><li>适用：有大量不确定性的新领域</li></ol></li><li>螺旋模型<ol><li>是风险驱动的，完全按照风险解决的方式组织软件开发活动。 充分利用原型方法来解决风险。</li><li>优点：降低风险，减少项目因风险造成的损失</li><li>缺点：原型的缺点；模型过于复杂，不利于管理者依据其组织软件开发活动</li><li>适用：高风险的大规模软件系统开发</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>2025春-软件工程与计算2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软工</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程与计算2-复习提纲</title>
    <link href="/2025/08/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972-%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
    <url>/2025/08/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%972-%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="01-软件工程基础">01 软件工程基础</h2><p>名词解释-软件工程：应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。</p><h2 id="02-软件工程的发展">02 软件工程的发展</h2><p>简答：从 1950s~2000s 之间的特点</p><ol><li>1950s：科学计算；以机器为中心进行编程；像生产硬件一样生产软件。</li><li>1960s：业务应用(批量数据处理和事物计算)；软件不同于硬件；用软件工艺的方式生产软件。</li><li>1970s：结构化方法；瀑布模型；强调规则和纪律。它们奠定了软件工程的基础，是后续年代软件工程发展的支撑。</li><li>1980s：追求生产力最大化；现代结构化方法/面向对象编程广泛应用；重视过程的作用。</li><li>1990s：企业为中心的大规模软件系统开发；追求快速开发、可变更性和用户价值；web 应用出现</li><li>2000s：大规模 web 应用；大量面向大众的 web 产品；追求快速开发、可变更性、用户价值和创新。</li></ol><h2 id="04-项目启动">04 项目启动</h2><p>如何管理团队？</p><ul><li>在实验中采取了哪些办法？有哪些经验？<ul><li>建立团队章程 持续成功 和谐沟通 不断总结 避免团队杀手</li></ul></li><li>团队结构有哪⼏种？<ul><li>主程序员团队 民主团队 开放团队</li></ul></li></ul><p>质量保障有哪些措施？ - 结合实验进⾏说明</p><ol><li>需求开发——需求评审和需求度量；</li><li>体系结构——体系结构评审和集成测试(持续集成)；</li><li>详细设计——详细设计评审、设计度量和集成测试(持续集成)；</li><li>构造阶段——代码评审、代码度量、测试(测试驱动和持续集成)；</li><li>测试阶段——测试、测试度量。</li><li>要及时的根据保障计划进行质量验证，质量验证的方法主要有评审、测试和质量度量三种。</li></ol><p>配置管理有哪些活动？ - 实验中是如何进⾏配置管理的</p><ol><li>标识配置项:确定应该被保留的部分，并且给予他们确定标识，包含配置项的特征，包括生产者、基线建立时间、使用者等。</li><li>版本管理：极其重要</li><li>变更控制：变更请求表单，教材 61 页</li><li>配置审计：验证配置项的完整性、正确性、一致性和可追踪性。</li><li>状态报告：反映当前的配置状态。</li><li>软件发布管理：将配置项发布到开发活动之外，例如发布给客户。</li></ol><h2 id="05-需求基础">05 需求基础</h2><p>名词解释-需求</p><ol><li>用户为了解决问题或达到某些目标所需要的条件或能力；</li><li>系统或系统部件为了满足合同、标准、规范或其它正式文档所规定的要求而需要具备的条件或能力；</li><li>对 1 或 2 中的一个条件或一种能力的一种文档化表述。</li></ol><p>区分需求的三个层次</p><ul><li>给出⼀个实例，给出其三个层次的例⼦<ul><li>业务需求 Rx：目标，解决方案与系统特性，描述为什么要开发系统</li><li>用户需求 URx：任务，问题域知识，描述系统能帮用户做什么</li><li>系统需求 SRx：描述开发人员需要实现什么</li></ul></li><li>对给定的需求示例，判定其层次 - 例如课程实验/ATM/图书管理…</li></ul><p><img src="2025052157.png" alt=""></p><p>掌握需求的类型</p><ul><li>对给定的实例，给出其不同类型的需求例⼦</li><li>对给定的需求示例，判定其类型<ul><li>例如课程实验/ATM/图书管理…</li></ul></li></ul><p>需求：</p><ul><li>项目需求：人的数量、计划成本、时间<ul><li>R5：项目的成本要控制在 60 万元人民币以下。</li><li>R6：项目要在 6 个月内完成。</li></ul></li><li>过程需求：人的分共、合作、方法、工具<ul><li>R7：在开发中，开发者要提交软件需求规格说明⽂档、设计描述⽂档和测试报告。</li><li>R8：项⽬要使⽤持续集成⽅法进⾏开发。</li></ul></li><li>系统需求：软件 硬件 其它<ul><li>软件需求：功能 数据 性能 质量 对外接口 约束</li><li>功能：能够为用户带来业务价值的系统⾏为；比如:在接到客户经理的请求后，系统应该为客户经理提供所有会员的个人信息。</li><li>数据：数据需求是需要在数据库、⽂件或者其他介质中存储的数据描述。数据信息、使用频率、可访问性、实体关系、完整性、数据保持要求</li><li>性能：需要进⾏专门的模拟和测试</li><li>约束：开发⼈员设计和构建系统时的选择范围</li></ul></li></ul><h2 id="06-需求分析方法">06 需求分析方法</h2><p>为给定的描述</p><ul><li>建⽴ ⽤例图</li><li>建⽴ 分析类图（概念类图）（只有属性，没有⽅法）</li><li>建⽴ 系统顺序图</li><li>建⽴ 状态图</li></ul><p><img src="2025061334.png" alt=""><br><img src="2025061346-1.png" alt=""></p><p><strong>用例图</strong><br>步骤：</p><ol><li>目标分析与解决方向的确定</li><li>寻找参与者</li><li>寻找用例</li><li>细化用例：⽤例描述了为应对一个业务事件，由一个用户发起，并在一个连续时间段内完成，可以增加业务价值的任务。</li></ol><p><img src="2025052178.png" alt=""></p><p><strong>概念类图/分析类图</strong><br>步骤：</p><ol><li>识别候选类(名词分析法)</li><li>确定概念类  (看是否满足既有状态又有行为)<ol><li>既需要维持一定的状态，又需要依据状态表现一定的行为：确定为一个概念类</li><li>如只需要维护状态，不需要表现行为：其他概念类的属性</li><li>不需要维护状态，却需要表现行为：首先重新审视需求是否有遗漏，因为没有状态支持的对象无法表现行为；如果确定没有需求的遗漏，就需要剔除该候选类，并将行为转交给具备状态支持能力的其他概念类</li><li>既不需要维护状态，又不需要表现行为：应该被完全剔除</li></ol></li><li>识别关联(文本中提取出&quot;名词＋动词＋名词&quot;的结构)：第一标准是满足需求的要求，第二标准是现实状况</li><li>识别重要属性：协作的必要信息，通过分析用例的描述，补充问题域信息发现。</li></ol><p>线段直接连接-普通的关联 文字为关联名称<br>空心菱形-聚合 实心菱形-组合 三角-集成<br><img src="2025052135.png" alt=""></p><p><strong>系统顺序图</strong><br>消息种类：实心箭头-同步消息 普通箭头-异步消息 虚线-返回消息</p><p>不同边框</p><ul><li>alt 多选一：一定要选 可选分支用虚线分割，执行状态的分支上写监护条件，放在中括号中</li><li>opt：一定要选 0 或 1</li><li>loop：循环，用中括号写循环条件</li></ul><p><img src="2025052132.png" alt=""><br><img src="2025061338.png" alt=""></p><p><strong>状态图</strong></p><ol><li>状态：一组可观察的情况，描述了一个系统在给定时间的行为</li><li>状态转换：从一个状态到另一个状态的转换</li><li>事件：使系统表现出某种可预测的行为形式的事件</li><li>行为：由于过渡而发生的过程</li></ol><p><img src="2025052181.png" alt=""><br><img src="2025061302.png" alt=""></p><h2 id="07-需求文档化与验证">07 需求文档化与验证</h2><p>为什么需要需求规格说明？结合实验进⾏说明</p><ol><li>方便交流，软件开发过程中，<strong>子任务与人员</strong>之间存在错综复杂的关系，存在大量的沟通和交流，所以软件开发中要编写不同类型的文档，每种文档都是针对项目中需要广泛交流的内容。因为<strong>软件需求</strong>需要进行<strong>广泛交流</strong>，所以要把需求文档化。</li><li>需求规格说明是在<strong>软件产品的角度以系统级需求列表的方式</strong>描述软件系统解决方案，书写需求规格说明，可以建立管理控制的基线，方便任务分配，制定工作计划，进行跟踪和度量。</li><li>在实验中，需求规格的重要性不只体现在结果上，还包括中间过程，在书写需求规格过程中，才真正把问题域的问题和分析模型的成果转化为系统级需求，方便小组成员真正明确需求，个人认为在这个阶段包含一部分的需求在发现和完整化。</li></ol><p>对给定的需求示例，判定并修正其错误</p><ul><li>对给定的需求规格说明片段，找出并修正其错误</li></ul><p>了解需求文档化要点：</p><ol><li>技术文档写作要点(简洁，精确，易读，易修改)；</li><li>需求书写要点(使用用户术语，可验证，可行性)；</li><li>需求规格说明文档书写要点(充分利用标准的文档模板，保持所以内容位置得当；保持文档内的需求集具有完备性和一致性；为需求划分优先级)</li></ol><p>对给定的需求示例，设计功能测试⽤例 ==?==</p><ul><li>结合测试⽅法</li></ul><h2 id="08-软件设计基础">08 软件设计基础</h2><p>名词解释-软件设计：指关于软件对象的设计，是一种设计活动。软件设计既指软件对象实现的规格说明，又指这个规格说明产生的过程。</p><ul><li>以需求开发的制品(需求规格说明和分析模型)为基础，构建软件设计方案描述和原型，为后期的构造活动提供规划或蓝图。</li><li>工程性 艺术性 演化性 决策性</li></ul><p>软件设计的核心思想是什么？<br>分解与抽象是软件设计的核心思想，两者都是由层次性的，彼此之间可以嵌套使用。</p><ol><li>分解：在横向上将系统分割为几个相对简单的子系统与子系统之间的关系</li><li>抽象：在纵向上聚焦个子系统的接口(这里的接口与实现相对)，可以分离接口和实现，使得人们更好的关注软件系统本质，降低复杂度。</li></ol><p>软件⼯程设计有哪三个层次？各层的主要思想是什么？</p><ol><li>高层设计：基于反映软件高层抽象的构件设计，描述系统的高层结构、关注点和设计决策。</li><li>中层设计：更加关注组成构件的模块的设计、导入/导出、过程之间调用关系或者类之间的协作。</li><li>低层设计：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。</li></ol><h2 id="09-软件体系结构基础">09 软件体系结构基础</h2><p>体系结构的概念：{部件(Component),连接件(Connector),配置(Configuration)}</p><ol><li><strong>部件</strong>是软件体系结构的基本组成单位之⼀,承载系统的主要功能,包括处理与数据;</li><li><strong>连接件</strong>是软件体系结构的另一个基本组成单位,定义了部件间的交互,是连接的抽象表示;</li><li><strong>配置</strong>是对&quot;形式&quot;的发展,定义了&quot;部件&quot;以及&quot;连接件&quot;之间的关联方式,将它们组织成系统的总体结构。</li></ol><p>体系结构的风格的优缺点：<br><em>主程序子进程风格</em></p><ul><li>组件：程序、函数和模块</li><li>连接件：在上述三个组件之间相互调用<br>优点：</li></ul><ol><li>流程清晰,易于理解(符合分解和分治的思想)。</li><li>强控制性(容易保证正确性)。</li></ol><p>缺点：</p><ol><li>程序调用是⼀种<strong>强耦合</strong>的连接⽅式,⾮常依赖交互⽅的接口规格,这会使得系统难以修改和复用。</li><li>程序调用的连接方式限制了各部件之间的数据交互,可能会使得不同部件使⽤隐含的共享数据交流,产⽣不必要的公共耦合,进⽽破坏它的&quot;正确性&quot;控制能力。</li></ol><p><img src="2025061397.png" alt=""></p><p><em>面向对象风格</em></p><ul><li>组件：对象或模块</li><li>连接件：函数或调用</li></ul><p>优点：</p><ol><li>内部实现的可修改性(隐藏内部实现)。</li><li>易开发、易理解、易复用的结构组织(契合模块化思想)。</li></ol><p>缺点：</p><ol><li>接口的耦合性(由于方法调用机制，接口的耦合性无法消除)</li><li>标识(Identity)的耦合性(一个对象要和其他对象交互，必须知道标识)</li><li>副作用:难以理解、高耦合性以及数据的不一致视图</li></ol><p><img src="2025061343.png" alt=""></p><p><em>分层风格</em></p><ul><li>组件：过程或对象的集合</li><li>连接件：在受限可见性下进行过程调用或方法调用</li></ul><p>优点：</p><ol><li>设计机制清晰,易于理解(抽象层次分离，隔离复杂度)。</li><li>支持并行开发(层次之间遵守程序稳定的接口)。</li><li>更好的可复用性与内部可修改性(接口的稳定性，不同层次的部件能够互相替代)。</li></ol><p>缺点：</p><ol><li><strong>交互协议难以修改</strong>(可能需要改变所有的层次，接口具有强耦合性)。</li><li>性能损失(禁止跨层调用)。</li><li>难以确定层次数量和粒度。</li></ol><p><img src="2025061333.png" alt=""></p><p><em>Model-View-Controller Style MVC 风格</em></p><ul><li>组件：<ul><li>模型组件负责保持问题域知识和确认视图层的修改</li><li>视图组件负责显示信息给用户并且将用户的行为传递给控制器</li><li>控制器<ul><li>修改模型的状态：将用户的行为和模型的更新映射起来</li><li>选择用来反映的视图</li></ul></li></ul></li><li>连接件：方法调用、信息、事件</li></ul><p>优点：</p><ol><li>易开发性(分别抽象了业务逻辑，表现和控制机制清晰，易于开发)</li><li>视图和控制的可修改性。</li><li>适宜于网络系统开发的特征。(MVC 不仅允许视图和控制的可修改性,⽽且其对业务逻辑、表现和控制的分离使得⼀个模型可以同时建⽴并保持<strong>多个视图</strong>,这⾮常适⽤于⽹络系统开发)。</li></ol><p>缺点：</p><ol><li>复杂性。MVC 将⽤户任务分解成了表现、控制和模型三个部分,这增加系统的复杂性,不利于理解任务实现。</li><li>模型修改困难。视图和控制都要依赖于模型,因此,模型难以修改。(往往会我们带来比较高的复杂度问题）</li></ol><p><img src="2025061320.png" alt=""></p><p><em>观察者模式</em><br><img src="2025061351.png" alt=""></p><h2 id="10-软件体系结构设计与构建">10 软件体系结构设计与构建</h2><p><img src="2025061358.png" alt=""></p><p>体系结构设计的过程？</p><ol><li>分析关键需求和项目约束：分析用例文档和需求规格说明书(包含需求规格和项目约束)。注意既要考虑功能性需求，又要考虑非功能性需求，甚至很大意义上体系结构设计是为了满足非功能性需求。</li><li>通过选择体系结构风格：选择分层风格(信息系统、并行开发、非 web 应用)，进行评审。</li><li>进行软件体系结构逻辑(抽象)设计：产生逻辑包图</li><li>依赖逻辑设计进行软件体系结构(实现)设计：产生物理类图</li><li>完善体系结构设计：关键类图，持久化数据格式的定义等</li><li>添加构件接口：包、重要文件的创建，定义接口</li><li>迭代过程 3-6</li></ol><p>p.s: 1-3 逻辑设计 4-7 物理设计</p><p>包的设计原则</p><ol><li>重用发布等价原则(REP):重用的粒度就是发布的粒度</li><li>共同封闭原则(CCP):包中所有类对于同一类性质的变化应该是共同封闭的，一个变化若对一个包产生影响，则对该包中的所有类产生影响，而对于其他包不造成任何影响。（使包变大）</li><li>共同重用原理(CRP):一个包中的所有类应该是能够共同重用的。（使包变小）</li><li>无环依赖原则(ADP):在包的依赖关系图中不能存在环。</li><li>稳定依赖原则(SDP):朝着稳定的方向进行依赖 （稳定性：输出/输入+输出）</li><li>稳定抽象原则(SAP):包的抽象程度应该和其稳定程度一致（稳定的包是抽象的包，接口）</li></ol><p>p.s. 前三条描述的是依赖性，后三条描述的是耦合性</p><p><img src="2025061433.png" alt=""></p><p>体系结构构件之间接⼝的定义（*）<br><img src="2025061469.png" alt=""></p><p>体系结构开发集成测试⽤例</p><ul><li>Stub 和 Driver</li></ul><p>Stub 桩程序</p><ol><li>为了完成程序的编译和连接⽽使⽤的暂时代码</li><li>对外模拟和代替承担模块接⼝的关键类</li><li>⽐真实程序简单的多，使⽤为<strong>简单</strong>的逻辑:比如简单的替代 DAO 层。</li></ol><p><img src="2025061490.png" alt=""><br><img src="2025061463.png" alt=""></p><h2 id="11-人机交互设计">11 人机交互设计</h2><p><img src="2025061461.png" alt=""></p><p>名词解释-可用性：不是用户界面的单一一维属性，包含以下维度：</p><ol><li>易学性：新手用户容易学习，能够很快使用系统。</li><li>效率：熟练的用户可以高效使用它</li><li>易记性：使用过软件系统的用户，能够有效记忆或快速重新学会使用该系统。(超市可以缓存之前的信息)</li><li>出错率：几乎没有错误，可以从错误中快速恢复</li><li>主观满意度：让用户有良好的体验。</li></ol><p>能够列出⾄少 5 个界面设计的注意事项，并加以解释</p><ul><li>例⼦-违反了哪些条界⾯设计原则</li></ul><p>简洁设计（7±2 原则）</p><ul><li>人类的信息处理能力是受限的，一般满足 7±2 原则</li></ul><p>一致性设计</p><ul><li>用户在使用软件系统时，会为软件系统建立精神模型。</li><li>比如：取消和确认键在不同页面的位置互换，就违反了该原则</li></ul><p>低出错率设计</p><ol><li>人机交互设计首先要帮助人们避免犯错，尽可能设计不让用户犯严重错误的系统<ol><li>具体措施包括将不适当的菜单选项功能以灰色显示屏蔽</li><li>禁⽌在数值输入域中出现字母字符</li></ol></li><li>当错误出现时，系统还要在⼈机交互中提供简洁、有建设性、具体的指导来帮助⽤户消除错误：填写表单时如果使用输⼊了无效的编码，那么系统应该引导他们对此进行修改，⽽不是要求⽤户重新填写整个表单。</li><li>出错信息应当遵循以下四个简单原则[Shneiderman1982]：<ol><li>应当使用清晰的语言来表达，而不要使用难懂的代码；</li><li>使⽤的语言应当精炼准确，而不是空泛、模糊的；</li><li>应当对用户解决问题提供建设性的帮助；</li><li>出错信息应当友好，不要<strong>威胁或责备</strong>使用。</li></ol></li><li>系统还应该提供错误恢复和故障解决帮助⼿册。</li><li>应当‘’尽快的进行校验(检查用户名重复)</li></ol><p>易记性设计</p><ol><li>减少短期记忆的负担</li><li>使用逐层递进的方式展示信息</li><li>使用直观的快捷方式</li><li>设置有意义的默认值</li></ol><p>可视化设计要点</p><ol><li>按照任务模型设计界面隐喻，同时不要把软件系统的内部构造机制暴露给用户</li><li>可视化设计还应该基于界面隐喻，尽可能地把功能和任务细节表现出来。</li></ol><p>精神模型、差异性<br>精神模型：用户进行人机交互时头脑中的任务模型。依据精神模型可以进行隐喻 Metaphor 设计：</p><ol><li>隐喻又被称为视觉隐喻，是视觉上的图像，但会被用户映射为业务事物。用户在识别图像时，会依据隐喻将控件功能与已知的熟悉事物联系起来，形成任务模型；</li><li>隐喻本质上是在用户已有知识的基础上建立一组新的知识，实现界面视觉提示和系统功能之间的知觉联系。</li></ol><p>差异性：</p><ol><li>新手用户<ol><li>是对业务不熟悉的⼈</li><li>例如新员工或者新接触系统的⼈。为新手用户设计系统时要关注易学性，进⾏业务导航，尽量避免出错。如果⼀个系统的⼤多数⽤户都是新手用户，整个系统的⼈机交互设计都要侧重<strong>易学性</strong>。</li></ol></li><li>专家用户<ol><li>是能够熟练操作计算机完成业务任务的⼈，⼀般都是⻓时间使⽤软件系统并且计算机操作技能熟练的人。</li><li>为专家用户设计系统时，要关注效率。如果⼀个系统的大多数用户都是专家⽤户，整个系统的⼈机交互设计都要侧重效率。</li></ol></li><li>熟练用户：是介于新手用户和专家用户之间的⼈。为熟练用户设计⼈机交互系统要在易学性和效率之间进行折中。</li><li>好的人机交互应该为不同的用户群体提供<em>差异化的交互机制</em>。<ol><li>既为新⼿用户提供易学性高的⼈机交互机制(图形界面)</li><li>⼜为专家用户提供效率高的⼈机交互机制(命令行、快捷方式、热键)</li></ol></li></ol><p>导航、反馈、协作式设计<br>导航：</p><ul><li>好的人机交互设计就像⼀个服务周到的推销员，能够主动将自己的产品和服务简明扼要地告诉⽤户，这个就是导航。</li><li>导航的目的就是为用户提供⼀个很好的完成任务的入口，好的导航会让这个入口非常符合人的精神模型。</li><li>全局结构按照任务模型将软件产品的功能组织起来，并区分不同的重要性和主题提供给 不同的⽤户。<ol><li>全局结构常⽤的导航控件包括<strong>窗口、菜单、列表、快捷方法、热键</strong>等等。</li><li>全局结构的设计主要以功能分层和任务交互过程为主要依据。</li></ol></li><li>局部结构通过安排界面布局细节，制造<strong>视觉上的线索</strong>来给用户提供导航。<ol><li>局部结构常用的导航控件包括可视化控件布局与组合、按钮设置、文本颜色或字体大小等等。</li><li>局部结构的设计主要以⽤户关注的任务细节为主要依据。</li></ol></li></ul><p>反馈：</p><ul><li>一定要有反馈，避免进行错误的操作</li><li>⽤户喜欢较短的响应时间，较⻓的响应时间(&gt;15 秒)具有破坏性</li><li>较短的响应时间导致了较短的⽤户思考时间；较快的节奏可能会提⾼效率，但也会增加出错率；</li><li><strong>经验测试</strong>有助于设置适当的响应时间。</li></ul><p>协作式设计：</p><ol><li>人和计算机是⼈机交互的方法，其中人的因素是比较固定的，一定时期内不会发⽣⼤的变化，所以要让二者交互顺畅，就需要让计算机更多地适应⼈的因素，这也是人机交互设计以用户为中心的根本原因。</li><li>这种<em>调整计算机因素以更好地适应并帮助用户</em>的设计方式被称为协作式设计</li></ol><h2 id="12-详细设计">12 详细设计</h2><p><img src="2025061457.png" alt=""><br>详细设计的出发点：所有功能性需求和非功能性需求</p><p>职责分配</p><ul><li>职责是执行任务(操作职责)或维护某些数据(数据职责)的义务。</li><li>职责可以在不同的抽象层次上陈述。职责可以分解。可以将高级职责分配给高级组件。</li><li>职责分解可以作为分解组件的基础：职责既反映了操作义务，也反映了数据义务，因此职责驱动的分解可能与功能分解不同。</li></ul><p>协作</p><ul><li>程序中的对象必须协作</li><li>协作式通过网络追求特定行为的消息模式</li></ul><p>控制风格：</p><ol><li>集中式控制风格<ol><li>容易找到做出决定的地方</li><li>易于查看如何制定决策以及如何更改决策流程</li><li>控制器可能会变得的庞大，复杂且难以理解，维护，测试等。</li><li>控制器可以将其他组件视为数据存储库<ol><li>增加耦合</li><li>破坏信息隐藏</li></ol></li></ol></li><li>委托式控制风格<ol><li>作出决策的对象不只有一个，职责的分解决定了控制对象的层次。</li></ol></li><li>分散式控制风格<ol><li>拥有许多组件，几乎没有数据，职责也很少。</li><li>组件无法独自完成很多工作，从而增加了耦合。</li><li>隐藏信息是很难的。</li><li>内聚性通常很差。</li></ol></li></ol><p><img src="2025061461-1.png" alt=""></p><p>给定分析类图、系统顺序图和设计因素描述</p><ul><li>建立设计类图</li><li>或者详细顺序图</li></ul><p>概念/分析类图的类和设计类图的类是不同的，设计类图中有的类是辅助类<br>通过职责建立静态设计模型</p><ul><li>职责分类：属性职责、行为职责</li></ul><p><img src="2025061443.png" alt=""></p><ol><li>虚线箭头:依赖</li><li>实线箭头:关联(两侧写数量)</li><li>空菱形在一侧的实线箭头:聚合</li><li>实菱形在一侧的实线箭头:合成</li><li>空心实线箭头:泛化(extends)</li><li>空心虚线箭头:实现(implements)</li></ol><p><img src="2025061499.png" alt=""><br><img src="2025061415.png" alt=""></p><p>添加辅助类后：<br><img src="2025061499-1.png" alt=""></p><p>通过协作创建动态设计模型<br><img src="2025061481.png" alt=""></p><p>协作的测试</p><ul><li>MockObject</li></ul><p><img src="2025061456.png" alt=""><br><img src="2025061434.png" alt=""><br><img src="2025061424.png" alt=""></p><h2 id="13-详细设计中的模块化与信息隐藏">13 详细设计中的模块化与信息隐藏</h2><p>名词解释：解释耦合与内聚<br>耦合：耦合描述的是两个模块之间关系的复杂程度：包括内容耦合，公共耦合，重复耦合，控制耦合，印记耦合，数据耦合<br>内聚：内聚表达的是一个模块内部的联系的紧密性：包括信息内聚、功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。</p><p>耦合与内聚</p><ul><li>对例⼦-说明它们之间的耦合程度与内聚，给出理由</li></ul><p>耦合程度的度量</p><ol><li>CBO 方法调用耦合：<ol><li>CBO = 该类访问他类的成员方法的数量 + 其他类的成员访问该类的成员方法的数量</li></ol></li><li>DAC 数据抽象耦合：<ol><li>DAC = 统计一类包含的其他类的其他类的实例的数量，不包括继承关系带来的实例引用</li></ol></li><li>有效和 Ca 和 Ce<ol><li>Ca:在此类之外依赖于这类内部的类的数量</li><li>Ce:这个类中依赖于这个类的外部的类的数量</li></ol></li><li>DIT 继承树的深度<ol><li>从节点到树的根的最大长度</li><li>随着 DIT 的增长，由于高度的继承性，很难预测类的行为</li><li>理论上 DIT 是越大也好，但是同样也会带来很难实现 LSP 的问题，DIT&gt;3 同样也需要审查继承机制的正确性。</li></ol></li><li>NOC 子类的数量<ol><li>一个类的直接子类的数量</li><li>一般 NOC 超过三，就需要认真审查继承机制的正确性，检查是否满足 LSP</li></ol></li></ol><p><img src="2025061454.png" alt=""></p><p>内聚<br><img src="2025061430.png" alt=""></p><p>信息隐藏</p><ul><li>基本思想：每个模块都隐藏了重要设计决策的实现，因此只有该模块的组成部分才知道详细信息：特别是如果存在所有可能的设计更改的列表-隐藏假设列表</li><li>两种常⻅的信息隐藏决策<ol><li>一是根据需求分配的职责，因为实践表明，需求是经常变化的，频率和幅度都很大；</li><li>二是内部实现机制，常见的变化主题包括硬件依赖，输入输出形式，非标准语言特征和库，负责的设计和实现，复杂的数据结构，复杂的逻辑，全局变量。数据大小限制等。</li></ol></li><li>对例⼦-说明其信息隐藏程度好坏</li></ul><h2 id="14-面向对象的模块化">14 面向对象的模块化</h2><p>Principles from Modularization</p><ul><li>1: Global Variables Consider Harmful 全局变量被认为是有害的<ul><li>将潜在共享元素细分为组，将每个组的访问权限限制为最小的模块子集</li></ul></li><li>2: To be Explicit 让代码清晰</li><li>3: Do not Repeat 不要重复<ul><li>先写接口（printer 的例子）</li></ul></li><li>4: Programming to Interface (Design by Contract) 面向接口编程</li><li>5: The Law of Demeter 迪米特法则<ol><li>你可以自己玩。(this)</li><li>你可以玩自己的玩具，但不能拆开它们(自己的成员变量)</li><li>你可以玩送给你的玩具。(方法)</li><li>你可以玩自己制作的玩具。(自己创建的对象)</li></ol></li><li>6: Interface Segregation Principle (ISP) 接口隔离原则<ul><li>不应强迫客户端依赖于不使用的接口</li></ul></li><li>7: Liskov Substitution Principle (LSP) 里氏替换原则<ul><li>所有派生类都必须可以替代其基类</li><li>用来判断是否可以进行继承</li></ul></li><li>8: Favor Composition Over Inheritance 组合代替继承<ul><li>使用继承实现多态 使用委托不继承重用代码</li><li>例：Person 里面持有 Passenger、Agent</li><li>例：Object -&gt;(Smoke / Person / Ground) 根据子类需求，实现不同接口（Visible Movable Solid）</li></ul></li><li>9: Single Responsibility Principle (SRP) 单一责任原则<ul><li>模块中的元素应在功能上紧密相关</li><li>例：Accout 有业务逻辑和转 xml 格式的逻辑，把 xml 格式的逻辑分到 AccountSerializer</li></ul></li></ul><p>对给定的示例，发现其所违反的原则，并进⾏修正</p><h2 id="15-面向对象的信息隐藏">15 面向对象的信息隐藏</h2><p>信息隐藏的含义：每一个模块都隐藏了这个模块中关于重要设计决策的实现，以至于只有这个模块的每一个组成部分才能知道具体的细节</p><p>封装</p><ul><li>目的是信息隐藏</li><li>封装将数据和行为同时包含在类中，分离对外接口与内部实现</li><li>接口是模块的可见部分，描述了一个类中的暴露到外界的可见特征</li><li>实现被隐藏在模块之中，隐藏实现意味着只能在类内操作，更新数据，而不意味着隐藏接口数据</li></ul><p>封装实现的细节</p><ul><li>数据和行为</li><li>内部结构<ul><li>暴露 setPosition (index, position) 隐藏 append (position)</li></ul></li><li>其他对象的引用</li><li>类型信息</li><li>潜在变更</li></ul><p>OCP 开闭原则</p><ol><li>对<strong>扩展</strong>开放：模块的行为可以被扩展，比如新添加一个子类</li><li>对<strong>修改</strong>关闭：模块中的源代码不应该被修改</li></ol><p>DIP 依赖倒置原则</p><ol><li>抽象不应该依赖于细节，细节应该依赖于抽象。因为抽象是稳定的，细节是不稳定的。</li><li>高层模块不应该依赖于低层模块，而是<em>双方都依赖于抽象</em>，因为抽象是稳定的，而高层模块和低层模块都可能是不稳定的。</li></ol><p>如果我们需要 B 依赖于 A</p><ol><li>如果 A 是抽象的，那么符合 DIP</li><li>如果 A 不是抽象，那么不符合 DIP，我们为 A 建立抽象借口接口 IA，然后使用 B 依赖于 IA、A 实现 IA，所以这样子 B 就依赖于 IA，A 也依赖于 IA。</li></ol><p><img src="2025061482.png" alt=""><br><img src="2025061563.png" alt=""></p><h2 id="16-设计模式">16 设计模式</h2><p>如何实现可修改性、可扩展性、灵活性（参考例子 Client、Interface_A、Class_A1）</p><ul><li>可修改性：接口与实现的分离</li><li>可扩展性：实现接口、继承、组合…</li><li>灵活性：用组合灵活性更好</li></ul><ol><li>策略模式:减少耦合、依赖倒置。</li><li>抽象工厂模式:职责抽象、接口重用。</li><li>单件模式:信息隐藏、职责抽象。</li><li>迭代器模式:减少耦合、依赖倒置。</li></ol><p>策略模式</p><ul><li>典型问题：雇员的薪酬支付方式和支付频率有很多种</li><li>参与者：上下文、策略、具体策略</li><li>应用场景：同一个行为的不同实现、消除 switch 选择分支</li></ul><p><img src="2025061482-1.png" alt=""><br><img src="2025061433-1.png" alt=""></p><p>抽象⼯⼚模式</p><ul><li>定义了一个创建对象的接口，由子类决定要使实例化哪一个类。工厂方法让类的实例化延迟到子类。</li><li>参与者：抽象工厂、具体工厂、抽象产品、具体产品、客户</li><li>应用场景：帮助系统独立于如何对产品的创建、构成、表现；让系统灵活配置拥有多个产品族中的某一个</li></ul><p><img src="2025061474.png" alt=""><br><img src="2025061432.png" alt=""></p><p>单件模式</p><ul><li>对于某个类，在内存中只希望有唯一一个对象存在。每次想得到这个类的一个对象的引用的时候，都指向唯一的那个对象。</li></ul><p><img src="2025061485.png" alt=""><br><img src="2025061471.png" alt=""></p><p>迭代器模式</p><ul><li>典型问题：某个方法 f ()，可能需要调用 g ()，对于 g () 的来说，往往可能只是希望挨个访问某个聚合结构。而且我们往往并不希望让 g () 知道到底是什么样的聚合结构。对遍历抽象：1-是否有下一个元素 2-得到下一个元素</li><li>参与者：迭代器、具体迭代器、聚合（创建迭代器对象的接口）、具体聚合</li><li>应用场景：访问一个聚合对象的内容而无需暴露它的内部实现，支持对聚合对象的多种遍历</li></ul><p><img src="2025061484.png" alt=""><br><img src="2025061487.png" alt=""></p><p>给定场景，应用设计模式并写出代码</p><p>给出代码，要求用设计模式改写</p><h2 id="17-软件构造">17 软件构造</h2><p>构造包含的活动：详细设计、编程、测试、调试、代码评审、集成与构建、构造与管理</p><p>名词解释</p><p>重构：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构</p><p>测试驱动开发：要求程序员在编写一段代码之前，优先完成该段代码的测试代码。测试代码通常由测试工具自动装载执行，也可以由程序员手工执行。完成测试代码之后，程序员再编写程序代码，并在编程中重复执行测试代码，以验证程序代码的正确性。</p><p>结对编程：</p><ul><li>两位程序员并排工作，在相同的设计，算法，代码或测试上进行协作</li><li>一个程序员（驱动程序）可以控制键盘/鼠标并主动执行程序</li><li>另一个程序员（观察员）不断观察驾驶员的工作，以发现战术上的（语法上的，拼写的等）缺陷，并从战略上考虑工作的方向</li><li>根据需要，两位程序员可以集思广益解决任何难题</li><li>两位程序员定期切换角色，他们平等地合作开发软件</li></ul><h2 id="18-代码设计">18 代码设计</h2><p>给定代码段示例，对其进⾏改进或者发现其中的问题</p><ul><li>简洁性/可维护性</li><li>使⽤数据结构消减复杂判定</li><li>控制结构</li><li>变量使⽤</li><li>语句处理</li><li>How to write unmaintainable code</li><li>防御与错误处理</li></ul><p>单元测试⽤例的设计</p><p>为方法开发测试用例：</p><ol><li>方法的规格：根据第一种线索，可以使用基于规格的测试技术开发测试用例，等价类划分和边界值分析是开发单元测试用例常用的黑盒测试方法。</li><li>方法代码的逻辑结构：根据第二种线索，可以使用基于代码的测试技术开发测试用例，对关键、复杂的代码使用路径覆盖，对复杂代码使用分支覆盖，简单情况使用语句覆盖</li></ol><p>使用 Mock Object 测试类：<br><img src="2025061447.png" alt=""><br><img src="2025061424-1.png" alt=""></p><p>契约式设计</p><ul><li>异常方式</li><li>断言方式</li></ul><p>防御式编程 ：在一个方法与其他方法、操作系统、硬件等外界环境交互时，不能确保外界都是正确的，所以要在外界发生错误时，保护方法内部不受损害</p><ul><li>输入参数合法？用户输入有效？外部文件存在？引用为 NULL？对象初始化？</li><li>异常和断言都可以用来实现防御式编程</li><li>往往会带来比较冗余和复杂的代码，但是会有效地提高程序的抗干扰能力和回复能力，有利于人机交互。</li></ul><p>表驱动<br><img src="2025061469-1.png" alt=""></p><h2 id="19-软件测试">19 软件测试</h2><p>掌握⽩盒测试和⿊盒测试的常⻅⽅法，并进⾏能够优缺点⽐较<br>能解释并区别⽩盒测试三种不同的⽅法：语句覆盖、分⽀覆盖和路径覆盖</p><p>白盒测试和⿊盒测试的常⻅⽅法：<br>黑盒测试：将测试对象作为一个黑盒子，完全基于输入输出数据来判断测试对象的正确性</p><ul><li>等价类划分：把所有可能的输入数据，即程序的输入域划分为若干部分 (子集)，从每个子集中选取少量具有代表性的数据作为测试用例。</li><li>边界值分析：针对边界情况设计测试用例，可以发现更多的缺陷。</li><li>决策表：为复杂逻辑判断设计测试用例的技术。决策表示由条件声明、行动声明、规则选项和行动选项等四个象限组成的表格。</li><li>状态转换：针对复杂测试对象的测试技术。该类复杂测试对象对输入数据的反映是多样的，还需要依赖自身的状态才能决定。<ul><li>状态图：描述测试对象集合、输入集合和输入导致的状态转换集合</li><li>以状态图为基础，建立测试对象的状态转换表</li></ul></li></ul><p>白盒测试：将测试对象看做透明的，不关心测试对象的规格，而是按照测试对象内部的程序结构来设计测试用例进行测试工作</p><ul><li>语句覆盖：确保测试对象的每一行程序代码至少执行一次。（所有路径都覆盖一遍）</li><li>条件覆盖：确保每个判断的每个结果都至少满足一次</li><li>路径覆盖：确保程序中每一条独立执行的路径都至少执行一次</li></ul><p>给出⼀个场景，判断应该使⽤哪种测试⽅法，如何去写（*） - 对给定的场景和要求的测试⽅法，设计测试⽤例</p><ul><li>给出功能需求，则要求写功能测试⽤例</li><li>给出设计图，则要求写集成测试⽤例，Stub and Driver</li><li>给出⽅法的描述，则要求写单元测试⽤例，Mock Object</li><li>JUnit 基本用法</li></ul><h2 id="20-软件交付">20 软件交付</h2><p>用户文档、系统文档<br>用户文档：指为用户编写参考指南或者操作教程，常见的如用户使用手册、联机帮助文档等，统称为用户文档。<br>系统管理员文档：更注重系统维护方面的内容，例如系统性能调整、访问权限控制、常见故障解决等等。因此，系统管理员文档需要详细介绍软硬件的配置方式、网络连接方式、安全验证与访问授权方法、备份与容灾方法、部件替换方法等等。</p><h2 id="21-软件维护与演化">21 软件维护与演化</h2><p>如何理解软件维护的重要性？</p><ul><li>问题发生变化，软件的需求发生变化，导致新的需求</li><li>环境发生变化，需要经常修改以适应外界环境的改变</li><li>软件产品中存在缺陷，缺陷在使用中暴露出来，必须予以及时解决</li></ul><p>开发可维护软件的⽅法</p><ul><li>考虑软件的可变更性：预测变更并将其独立封装，便于修改时的程序定义与理解，防止修改时的连锁反映</li><li>为降低维护困难而开发：为后期理解程序和进行影响分析提供额外的便利<ul><li>编写详细的技术文档并保持及时更新</li><li>保证代码的可读性</li><li>维护需求跟踪链</li><li>维护回归测试基线</li></ul></li></ul><p>演化式生命周期模型</p><ol><li>初始开发：完成第一个版本的软件产品开发。<ol><li>极其重要的工作是建立好的软件体系结构（好的可扩展性、可修改性、坚实可靠）</li></ol></li><li>演化：保持软件产品的持续增值，让软件产品能够满足用户越来越多的需要，实现更大的业务价值</li><li>服务：不再持续的增加自己的价值，而只是周期性的修正已有的缺陷。</li><li>逐步淘汰：开发者已经不再提供软件产品的任何服务，也即不再继续维护该软件。</li><li>停止：开发者不再进行维护，用户也不再使用。</li></ol><p>逆向⼯程、再⼯程</p><ul><li>逆向工程：分析目标系统，标识系统的部件及其交互关系，并且使用其它形式或者更高层的抽象创建系统表现的过程<ul><li>基本原理是抽取软件系统的需求与设计而隐藏实现细节，然后在需求与设计的层次上描述软件系统，以建立对系统更加准确和清晰的理解。</li></ul></li><li>再工程：检查和改造一个目标系统，用新的模式及其实现复原该目标系统。<ul><li>目的是对遗留软件系统进行分析和重新开发，以便进一步利用新技术来改善系统或促进现存系统的再利用。</li></ul></li></ul><h2 id="22-软件开发过程模型">22 软件开发过程模型</h2><p>软件生命周期模型：人们将软件从<strong>生产到报废</strong>的生命周期分割为不同阶段，每段阶段有明确的典型输入/输出、主要活动和执行人，各个阶段形成明确、连续的顺次过程，这些阶段划分就被称为软件生命周期模型。</p><ul><li>软件演化生命周期模型：需求工程-软件设计-软件实现-软件测试-软件交付-软件维护</li></ul><p>解释与⽐较不同过程模型（要求、特征描述、优点、缺点）<br>对给定的场景，判定适⽤的开发过程模型<br>构建修复模型 Build-and-fix model</p><ul><li>没有对开发工作进行规范和组织</li><li>没有分析需求的真实性</li><li>没有考虑软件结构的质量</li><li>没有考虑测试和程序的可维护性</li></ul><p><img src="2025061346.png" alt=""></p><p>瀑布模型 Waterfall model<br>按照软件生命周期模型将软件开发活动组织为需求开发、软件设计、软件实现、软件测试、软件交付和软件维护等活动，并且规定了它们自上而下、相互邻接的次序<br>允许活动出现反复和迭代，重点在于要求每个活动的结果必须要进行验证<br>文档驱动：按照文档的划分、产生和验证来规划、组织和控制开发活动<br>优点：为软件开发活动定义了清晰的阶段划分<br>缺点：</p><ul><li>对文档的过高期望具有局限性</li><li>耗费很大的工作量和成本</li><li>很难为经常变化的需求建立完备可靠的文档</li><li>对开发活动的线性顺序假设具有局限性</li><li>客户、用户参与具有局限性</li><li>里程碑颗粒度具有局限性</li></ul><p>适用范围：</p><ul><li>需求非常成熟、稳定，没有不确定的内容，也不会发生变化</li><li>所需技术成熟可靠</li><li>复杂度适中</li></ul><p><img src="2025061353.png" alt=""></p><p>Iterative Models：<br>增量迭代模型 Incremental model<br>增量迭代模型是在项目开始时，通过系统需求开发和核心体系结构设计活动完成项目对前景和范围的界定，然后再将后续开发活动组织为多个迭代、并行的瀑布式开发模型。需求驱动。</p><ul><li>增量迭代模型需要在项目早期就确定项目的目标和范围，项目需求要比较成熟和稳定</li><li>少量的不确定性和影响不大的需求变更通过迭代的方式加以解决</li><li>每个迭代的增量需求相对独立，被开发为产品的独立部分交付给用户</li><li>需求驱动：增量需求是增量迭代模型进行迭代规划、开发活动组织和控制的主要依据</li></ul><p>优点：</p><ul><li>更加符合软件开发的实践情况，具有更好的适用性</li><li>并行开发可以帮助缩短软件产品的开发时间</li><li>渐进交付可以加强用户反馈，降低开发风险</li></ul><p>缺点：</p><ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。</li><li>增量交付模型需要一个完备、清晰的项目前景和范围以进行并发开发规划，但是在一些不稳定的领域，不确定性太多或者需求变化非常频繁，很难在项目开始就确定前景和范围。</li></ul><p><img src="2025061368.png" alt=""></p><p>演化迭代模型 Evolutionary</p><ul><li>Evolutionary development</li></ul><p>将软件开发活动组织为多个迭代、并行的瀑布式开发活动。能够更好应对需求变更，更适用于需求变更比较频繁或不确定性较多的领域<br>优点：</p><ul><li>使用迭代式开发，具有更好的适用性，尤其是其演化式迭代安排能够适用于那些需求变更比较频繁或不确定性较多的软件系统的开发</li><li>并行开发可以帮助缩短软件产品的开发时间</li><li>渐进交付可以加强用户反馈，降低开发风险</li></ul><p>缺点：</p><ul><li>无法在项目早期阶段建立项目范围，所以项目的整体计划、进度调度、尤其是商务协商事宜无法准确把握；</li><li>后续迭代的开发活动是在前导迭代基础上进行修改和扩展的，这容易让后续迭代忽略设分析与设计工作，退变为构建-修复方式。</li><li>容易退化为构建修复方式</li></ul><p>适用性：</p><ul><li>不稳定领域的大规模软件系统开发</li></ul><p><img src="2025061371.png" alt=""></p><p>原型模型 Prototyping<br>将需求开发活动展开为抛弃式原型开发活动和演化式原型开发活动<br>整体安排迭代的情况下，强调&quot;抛弃式原型&quot;的演化模型。抛弃式原型解决对未来知识的局限性产生的不确定性，将未来置于现在进行推敲。</p><ul><li>抛弃式原型：通过模拟&quot;未来&quot;的产品，将&quot;未来&quot;的知识置于&quot;现在&quot; 进行推敲，解决不确定性。存在的原因是&quot;不确定的&quot;，这一类原型在后续的开发过程中会被抛弃</li><li>演化式原型：在迭代中构建，是系统的核心，并不断扩充，最终成为真正的软件产品。它将作为真正产品的一部分，所以必须有很好的质量。在迭代式开发中，通常会在第一个迭代中构建一个核心的体系结构演化式原型，并且在后续迭代中不断扩充，成为真正的软件产品。</li></ul><p>优点：</p><ul><li>对原型方法的使用加强了与客户、用户的交流，可以让最终产品取得更好的满意度</li><li>适用于非常新颖的领域，这些领域因为新颖所以有着大量的不确定性</li></ul><p>缺点：</p><ul><li>原型方法能够解决风险，但是自身也能带来新的风险，例如原型开发的成本较高，可能会耗尽项目的费用和时间</li><li>实践中，很多项目负责人不舍得抛弃&quot;抛弃式原型&quot;，使得质量较差的代码进入了最终产品，导致了最终产品的低质量</li></ul><p>适用：</p><ul><li>有着大量不确定性的新颖领域进行开发活动组织。</li></ul><p><img src="2025061337.png" alt=""></p><p>螺旋模型 Spiral Model<br>是风险驱动的，完全按照风险解决的方式组织软件开发活动。</p><ol><li>确定目标、解决方案和约束</li><li>评估方案，发现风险</li><li>寻找风险解决方法</li><li>落实风险解决方案</li><li>计划下一个迭代</li></ol><p>基本思想是尽早解决比较高的风险，如果有些问题实在无法解决，那么早发现比目结束时再发现要好，至少损失要小得多。<br>原型能够澄清不确定性，所以原型能够解决风险，螺旋模型是充分利用原型方法来解决风险的。<br>原型模型 vs 螺旋模型</p><ul><li>原型模型：使用原型解决需求的不确定性</li><li>螺旋模型：实用原型解决项目开发中常见的各种类型的技术风险，包括系统需求开发、软件需求开发、软件体系结构设计、详细设计等各个阶段</li></ul><p>优点：降低风险，减少项目因风险造成的损失<br>缺点：</p><ul><li>风险解决需要使用原型手段，也就会存在原型自身带来的风险，这一点与原型模型相同</li><li>模型过于复杂，不利于管理者依据其组织软件开发活动</li></ul><p>适用：高风险的大规模软件系统开发<br><img src="2025061365.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-软件工程与计算2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软工</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-汇总</title>
    <link href="/2025/08/25/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-%E6%B1%87%E6%80%BB/"/>
    <url>/2025/08/25/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>1NF 横平竖直的表<br>2NF 没有非主属性对主属性的部分函数依赖<br>3NF 没有非主属性对主属性的传递函数依赖<br>BCNF 两种判别：1. 关系中还有左边的属性不是候选码 2. 主属性内部没有部分/传递依赖</p><p><strong>绪论</strong><br>数据库：长期储存在计算机内、有组织的、可共享的大量数据的集合。<br>数据库管理系统：位于用户（应用程序）与数据库（操作系统）之间的一层数据管理软件，是一种用于管理数据库的大型系统软件。</p><ul><li>数据定义功能</li><li>数据组织、存储和管理</li><li>数据操纵功能</li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护功能</li></ul><p>数据库系统：由数据库、数据库管理系统、数据库管理员、支撑系统运行所必须的系统软件和硬件平台组成的存储、管理、处理和维护数据的系统。<br>数据库应用系统：由数据库系统、应用开发工具、应用系统、数据库用户组成的计算机系统。</p><p>数据库用户</p><ul><li>数据库管理员</li><li>应用开发人员</li><li>最终用户</li></ul><p>数据库系统特点</p><ul><li>数据结构化</li><li>数据的共享性高，冗余度低，且易扩充</li><li>数据独立性高</li><li>数据由数据库管理系统统一管理和控制</li></ul><p>数据模型分类</p><ul><li>概念数据模型：用户的观点来对数据和信息建模，用于数据库设计</li><li>逻辑数据模型：计算机系统的观点对数据建模，用于 DBMS 实现</li><li>物理数据模型：对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法。</li></ul><p>数据模型组成要素</p><ul><li>数据结构<ul><li>数据模型中的数据结构被称为‘数据模式’ (data schema)</li><li>‘数据模式’是划分不同类型数据模型的依据。</li></ul></li><li>数据操作</li><li>数据约束</li></ul><p>模式：数据库中全体数据的逻辑结构和特征的描述。一个数据库只有一个模式。</p><ul><li>外模式：‘子模式’ 或 ‘用户模式’；是对数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述；一个数据库可以有多个外模式。</li><li>内模式（也称 ‘存储模式’或 ‘物理模式’）；是数据物理结构和存储方式的描述；是数据在数据库内部的表示方式；一个数据库只有一个内模式</li></ul><p>二级映象</p><ul><li>外模式／模式映像<ul><li>模式：描述的是数据的全局逻辑结构</li><li>外模式：描述的是数据的局部逻辑结构</li><li>保证数据的逻辑独立性<ul><li>当模式改变时，数据库管理员对外模式／模式映象作相应改变，使外模式保持不变</li><li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性</li></ul></li></ul></li><li>模式／内模式映像<ul><li>定义了数据全局逻辑结构与存储结构之间的对应关系。</li><li>数据库中模式／内模式映象是唯一的</li><li>保证数据的物理独立性<ul><li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。</li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称数据的物理独立性。</li></ul></li></ul></li></ul><p><strong>关系数据模型</strong><br>‘域’是一组具有相同数据类型的值的集合<br>笛卡尔积<br>元组：笛卡尔积中每一个元素（d1, d2, …, dn）叫作一个 ‘n 元组’ (n-tuple)<br>分量：笛卡尔积元素（d1, d2, …, dn）中的每一个值 di 叫作一个 ‘分量’<br>基数：一个域允许的不同取值个数称为这个域的‘基数’<br>关系：给定一个域的序列 D1, D2, …, Dn (其中可能存在相同的域)，笛卡尔积 D1 × D2 × … × Dn 的子集叫做在域 D1, D2, …, Dn 上的关系，表示为 R(D1, D2, …, Dn)（ 或简写为关系 R）<br>码 (Key)、候选码 (Candidate key)：若关系中的某一属性组的值能唯一地标识一个元组，而其所有的真子集都不能，则称该属性组为关系的 ‘候选码’，简称 ‘码’<br>全码：由关系中的所有属性构成的属性组是这个关系的候选码<br>主码： 在一个关系中，可以选择一个候选码作为该关系的 ‘主码’。是关系数据库管理系统（SQL）中才有的概念。<br>主属性：候选码中的诸属性称为该关系的 ‘主属性’</p><p>关系的类型</p><ul><li>基本关系（基本表/基表）：实际存在的表</li><li>查询表</li><li>视图表：由基本表或其他视图表导出的表, 是虚表, 结果数据也不需要持久存储。</li></ul><p>‘表’（包括基本表、基表、查询表、视图表）的概念，一般只在关系数据库管理系统（即 SQL 语言）中使用；<br>关系模型是一种逻辑数据模型，不涉及数据的物理存储，在关系模型理论中， 其数据结构只有 ‘关系’；</p><p>关系是元组的集合<br>关系模式是关系的“型”，元组集合是关系的“值”<br>关系模式是对关系的描述<br>元组集合的结构</p><ul><li>属性构成</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul><p>关系模式的形式化表示：R (U, D, DOM, F)<br>关系数据库：在一个给定的应用领域中，所有关系的集合构成一个关系数据库</p><p>关系的完整性</p><ul><li>实体完整性：关系中元组（二维表中的行） 的唯一性。</li><li>参照完整性：若属性（或属性组）F 是基本关系 R 的外码, 它与基本关系 S 的主码 Ks 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中每个元组在 F 上的值必须为：或者取空值（𝐀 的每个属性值均为空值）；或者等于 S 中某个元组的主码值</li><li>用户定义的完整性: 针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求</li></ul><p><strong>关系代数</strong><br>关系操作</p><ul><li>集合操作：并、交、差、笛卡尔积</li><li>专门的连接操作：选择、投影、连接、除</li><li>5 种基本操作：选择、投影、并、差、笛卡尔积<br>基本运算：并 差 笛卡尔积 选择 投影<br>扩充运算：交 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> -连接 自然连接 外连接 左/右外连接 除</li></ul><p><strong>事务</strong><br>事务 (Transaction) 是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。<br>——为了确保实现数据库的数据完整性 (integrity of the database)<br>事务启动：隐式方式</p><ul><li>由数据库管理系统来决定，何时为何用户启动一个新的事务</li></ul><p>事务结束</p><ul><li>用户调用 commit 或 rollback 命令，显式地结束当前事务</li><li>由数据库管理系统强行结束一个用户的当前正在运行中的事务</li></ul><p>事务结束方式</p><ul><li>COMMIT<ul><li>事务正常结束</li><li>提交事务的所有操作（读+更新）</li><li>被提交的事务对数据库的所有更新结果被写回到磁盘上的物理数据库中，确保事务执行结果的持久化</li></ul></li><li>ROLLBACK<ul><li>事务异常终止</li><li>事务运行的过程中发生了故障，不能继续执行</li><li>数据库管理系统将负责撤销被异常终止的事务对数据库的所有已完成的操作，并将数据库中的数据回退到事务开始时状态</li></ul></li></ul><p>事务的启动方式</p><ul><li>数据定义命令 (DDL)</li><li>将系统设为自动提交方式（打开自动提交标志）</li><li>数据操纵命令 (DML)</li></ul><p>保存点 (savepoint)</p><ul><li>在事务的执行过程中，用户可以为该事务设置若干个保存点</li><li>用户事务可以使用 Rollback 命令将当前事务回退到前面的某个保存点 sp，放弃“在保存点 sp 之后，回退操作之前”执行过的对数据库的所有访问操作， 并继续执行当前事务</li><li>不带保存点的回退操作将结束并放弃整个事务</li></ul><p>SQL<br>设置事务的运行方式：</p><ul><li>设置事务的自动提交命令：SET AUTOCOMMIT ON | OFF ;</li><li>设置事务的类型：SET TRANSACTION READONLY | READWRITE ;<ul><li>READONLY 只能执行对数据库的‘读’操作</li></ul></li><li>设置事务的隔离级别：SET TRANSACTION ISOLATION LEVEL READUNCOMMITTED | READCOMMITTED | READREPEATABLE | SERIALIZABLE ;<ul><li>READUNCOMMITTED：未提交读<ul><li>不需要申请任何类型的封锁，因而可能会‘读’到其他并发事务未提交的修改结果</li><li>禁止一个事务以该方式去执行对数据的 ‘写’ 操作，以避免与其它并发事务的 ‘写’ 冲突现象</li></ul></li><li>READCOMMITTED：提交读<ul><li>在‘读’一个数据对象 A 之前，需要先申请并获得数据对象 A 上的‘共享性’封锁， 在‘读’操作执行结束之后立即释放该封锁</li><li>以避免读取到其它并发事务未提交的修改结果</li></ul></li><li>READREPEATABLE：可重复读<ul><li>在 ‘读’ 数据对象 A 之前需要先申请并获得数据对象 A 上的 ‘共享性’ 封锁，并将该封锁维持到当前事务的结束</li><li>可以避免其它的并发事务对当前事务正在使用的数据对象的修改</li></ul></li><li>SERIALIZABLE：可序列化 (可串行化)<ul><li>并发事务以一种可串行化的调度策略实现其并发执行，以避免它们相互之间的干扰现象</li></ul></li></ul></li><li>不管采用何种隔离级别，在一个事务以‘<em>写</em>’方式访问数据对象 A 之前，需要先申请并获得数据对象 A 上的‘排它性’封锁，并将该封锁维持到当前事务的结束。</li></ul><p>ACID 特性：</p><ul><li>原子性：事务中包括的诸操作要么都做，要么都不做</li><li>一致性：数据库中只包含已成功完成提交的事务的执行结果</li><li>隔离性：一个事务的执行不能被其他事务干扰</li><li>持久性：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li></ul><p><strong>数据库安全性</strong><br>安全性控制<br>用户身份鉴别：系统提供的最外层安全保护措施<br>存取控制机制</p><ul><li>定义用户权限，并将用户权限登记到数据字典中</li><li>合法权限检查</li></ul><p>存取控制方法</p><ul><li>自主存取控制</li><li>强制存取控制：对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul><p>自主存取控制——GRANT REVOKE<br>用户存取权限定义</p><ul><li>一个客体的 ‘属主’ 自动拥有该客体上的所有存取权限</li><li>拥有权限的用户可以自主地将他所拥有的权限传授给在数据库系统中注册的其他用户</li><li>用户只能通过上述两种方式（或之一）来获得在一个客体上的存取权限。</li></ul><p>授权机制</p><ul><li>管理员</li><li>用户<ul><li>拥有自己建立的对象的全部的存取权限</li><li>可以使用 GRANT，把自己拥有的对象上的存取权限授予其他用户</li></ul></li><li>被授权用户<ul><li>如果具有“继续授权”的许可，可以把获得的权限再授予其他用户</li></ul></li><li>所有授予出去的权限在必要时又都可用 REVOKE 语句收回<br>eg. GRANT UPDATE (Sno), SELECT ON TABLE Student TO U1 WITH GRANT OPTION;<br>REVOKE UPDATE (Sno) ON TABLE Student FROM U4 CASADE;</li><li>（U4 之前把权限授予给了 U5）若有 CASADE 则同时收回 U6 的权限，否则拒绝执行</li></ul><p>创建用户授权<br>CREATE USER &lt;username&gt; [WITH DBA|RESOURCE|CONNECT]</p><ul><li>默认 CONNECT：不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库</li><li>RESOURCE：能创建基本表和视图，成为所创建对象的属主； 但不能创建模式，不能创建新的用户。</li><li>DBA：超级用户，可以创建新的用户、创建模式、创建基本表和视图等；拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户</li></ul><p>数据库角色<br>CREATE ROLE &lt;角色名&gt;;<br>给角色授权 权限回收<br>GRANT &lt;权限&gt; [, &lt;权限&gt;] … ON &lt;对象类型&gt; &lt;对象名&gt; TO &lt;角色&gt; [, &lt;角色&gt;] … ;<br>REVOKE &lt;权限 &gt;[, &lt;权限&gt;] … ON &lt;对象类型&gt; &lt;对象名&gt; FROM &lt;角色&gt; [, &lt;角色&gt;] …;<br>将角色授予 角色/用户 &amp; 从 角色/用户 回收角色</p><ul><li>GRANT &lt;角色&gt; [, &lt;角色&gt;] … TO &lt;角色<em>or</em>用户&gt; [, &lt;角色<em>or</em>用户&gt;] … ;</li><li>REVOKE &lt;角色&gt; [, &lt;角色&gt;] … FROM &lt;角色<em>or</em>用户&gt; [, &lt;角色<em>or</em>用户&gt;] …;</li></ul><p>授予角色 WITH ADMIN OPTION</p><ul><li>该语句把角色授予某用户，或授予另一个角色</li><li>授予者是角色的创建者或拥有在这个角色上的 ADMIN OPTION</li><li>指定了 WITH ADMIN OPTION 则获得某种权限的角色或用户还可以把这种权限授予其他角色或用户（即‘继续授权’许可）</li></ul><p>授予权限 WITH GRANT OPTION</p><ul><li>关于对象权限的授予权（对象权限：指数据库对象的访问权限，如表中的数据访问、存储过程的调用等）</li></ul><p>视图机制</p><ul><li>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</li></ul><p>审计</p><ul><li>启用一个专用的审计日志（Audit Log）将用户对数据库的所有操作记录在上面</li><li>审计员利用审计日志监控数据库中的各种行为，找出非法存取数据的人、时间和内容</li><li>AUDIT 语句：设置审计功能 &amp; NOAUDIT 语句：取消审计功能<ul><li>eg. AUDIT ALTER, UPDATE ON SC;</li></ul></li></ul><p>数据加密</p><ul><li>存储加密</li><li>传输加密</li></ul><p><strong>数据库完整性</strong></p><ul><li>数据的正确性：数据符合现实世界语义，反映了当前的实际状况</li><li>数据的相容性：数据库中的同一对象在不同关系表中的数据是符合逻辑的<br>完整性机制</li><li>提供定义完整性约束条件的机制</li><li>提供完整性检查的方法</li><li>违约处理<ul><li>拒绝</li><li>级联 CASCADE</li></ul></li></ul><p>可能破坏参照完整性的情况及违约处理<br><img src="2025060544.png" alt=""><br><img src="2025060562.png" alt=""></p><p>完整性约束命名子句<br>定义和修改：</p><ul><li>在 CREATE TABLE 语句中定义完整性约束</li><li>在定义完整性约束时，可以对完整性约束进行命名</li><li>使用 ALTER TABLE 语句来修改表中的完整性约束的定义，包括<ul><li>定义新的完整性约束</li><li>删除现有的 (命名) 完整性约束</li></ul></li></ul><p><img src="2025060568.png" alt=""></p><p>修改：<br><img src="2025060688.png" alt=""></p><p><em>域</em>中的完整性限制</p><ul><li>可以用 CREATE DOMAIN 命令来创建新的域（用户自定义数据类型）</li></ul><p><img src="2025060633.png" alt=""></p><p>断言</p><ul><li>可以使用 CREATE ASSERTION 语句，通过声明性断言来指定更具一般性的约束。</li><li>任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。</li></ul><p>CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt;;<br>DROP ASSERTION &lt;断言名&gt;;<br><img src="2025060693.png" alt=""></p><p>触发器<br>CREATE TRIGGER &lt;触发器名&gt; { BEFORE | AFTER } &lt;触发事件&gt; ON &lt;表名&gt; REFERENCING NEW | OLD ROW AS &lt;变量&gt; FOR EACH { ROW | STATEMENT } [ WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;<br><img src="2025060694.png" alt=""><br><img src="2025060697.png" alt=""></p><p>激活多个触发器</p><ul><li>执行该表上的 BEFORE 触发器;</li><li>激活触发器的 SQL 语句;</li><li>执行该表上的 AFTER 触发器。</li></ul><p><strong>数据库编程</strong><br>嵌入式 SQL</p><ul><li>将 SQL 语句嵌入程序设计语言中，被嵌入的程序设计语言，如 C、C++、 Java，称为宿主语言，简称主语言。</li></ul><p>（在 C 语言中）嵌入式 SQL 语句</p><ul><li>带有前缀 ‘EXEC SQL’ 和后缀 ‘;’</li><li>使用 into 子句来获取结果元组值（SELECT … INTO … 或 FETCH … INTO …）</li><li>用主变量 ‘: host_var’ 保存查询结果元组中的属性值；通过前缀‘:’来区分主变量和 SQL 语言中的表名或属性名（也被称为 SQL 变量）</li></ul><p>EXEC SQL select Sno, Sname, Sage<br>into : hsno, : hsname, : hsage<br>from Student where Sno = : givensno ;<br>数据库工作单元与源程序工作单元之间的通信</p><ul><li>向主语言传递 SQL 语句的执行状态信息，使主语言能够据此控制程序流程，主要用 SQL <em>通信区</em>实现</li><li>主语言向 SQL 语句提供执行参数，主要用（输入）<em>主变量</em>实现</li><li>将 SQL 语句查询数据库的结果交给主语言处理，主要用（输入）<em>主变量和游标</em>实现</li></ul><p>SQL 通信区——SQLCA： SQL Communication Area</p><ul><li>定义 SQLCA：EXEC SQL INCLUDE SQLCA</li><li>使用 SQLCA：<ul><li>SQLCA 中有一个用于存放每次执行 SQL 语句后返回当前 SQL 语句执行状态的代码变量 SQLCODE；</li><li>如果 SQLCODE 等于预定义的常量 SUCCESS，则表示 SQL 语句成功，否则表示出错；</li><li>应用程序每执行完一条 SQL 语句之后都应该测试一下 SQLCODE 的值，以了解该 SQL 语句执行情况并做相应处理</li></ul></li></ul><p>主变量： 在 SQL 语句中使用的主语言程序变量简称为主变量<br><img src="2025060607.png" alt=""></p><p>指示变量：</p><ul><li>是一个整型变量，是一种特殊的‘主变量’，用来“指示”相关主变量的值是否为‘空值</li><li>一个主变量可以附带一个指示变量</li><li>空格 or INDICATOR</li></ul><p><img src="2025060646.png" alt=""></p><p>为了使用主语言变量，必须首先在 DECLARE SECTION 部分声明这些变量<br><img src="2025060644.png" alt=""></p><p>作用</p><ul><li>在编译时对主语言变量与对应属性进行类型一致性检查</li><li>为接收从数据库返回的结果值而预先申请足够大的内存空间</li></ul><p><em>游标</em></p><ul><li>是系统为用户开设的一个数据缓冲区，用于存放 SQL 查询的执行结果</li><li>每个游标都有一个名字 – 游标名</li><li>当游标被打开后，用户可以用 SQL 语句逐一从游标中获取结果记录，并赋给主变量，交由主语言进一步处理</li></ul><p>建立数据库连接</p><ul><li>EXEC SQL CONNECT TO target [AS connection-name] [USER user-name];</li><li>可修改 EXEC SQL SET CONNECTION connection-name | DEFAULT;</li></ul><p>关闭</p><ul><li>EXEC SQL DISCONNECT [connection-name];</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c">EXEC SQL BEGIN DECLARE SECTION; <span class="hljs-comment">/*主变量声明开始*/</span><br><span class="hljs-type">char</span> Deptname[<span class="hljs-number">21</span>];<br><span class="hljs-type">char</span> Hsno[<span class="hljs-number">10</span>];<br><span class="hljs-type">char</span> Hsname[<span class="hljs-number">21</span>];<br><span class="hljs-type">char</span> Hssex[<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> HSage;<br><span class="hljs-type">int</span> NEWAGE;<br>EXEC SQL END DECLARE SECTION; <span class="hljs-comment">/*主变量声明结束*/</span><br><span class="hljs-type">long</span> SQLCODE;<br>EXEC SQL INCLUDE SQLCA; <span class="hljs-comment">/*定义SQL通信区*/</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">/*C语言主程序开始*/</span><br>&#123;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> yn; <span class="hljs-comment">/*变量yn代表yes或no*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please choose the department name(CS/MA/IS): &quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,deptname); <span class="hljs-comment">/*为主变量deptname赋值*/</span><br>EXEC SQL CONNECT TO TEST@localhost:<span class="hljs-number">54321</span> USER <span class="hljs-string">&quot;SYSTEM&quot;</span>/<span class="hljs-string">&quot;MANAGER&quot;</span>; <span class="hljs-comment">/*连接数据库TEST*/</span><br>EXEC SQL DECLARE SX CURSOR FOR <span class="hljs-comment">/*定义游标SX*/</span><br>SELECT Sno,Sname,Ssex,Sage <span class="hljs-comment">/*游标SX对应的查询语句*/</span><br>FROM Student<br>WHERE SDept = :deptname;<br>EXEC SQL OPEN SX;<br><span class="hljs-comment">/*打开游标SX，执行游标对应的查询，并指向查询结果的第一行*/</span><br><br><span class="hljs-keyword">for</span> ( ; ; ) <span class="hljs-comment">/*用循环结构逐条处理结果集中的记录*/</span><br>&#123;<br>EXEC SQL FETCH SX INTO :HSno,:Hsname,:HSsex,:HSage;<br><span class="hljs-comment">/*推进游标，将当前数据放入主变量*/</span><br><span class="hljs-keyword">if</span> (SQLCA.SQLCODE != <span class="hljs-number">0</span>) <span class="hljs-comment">/*SQLCODE != 0，表示操作不成功*/</span><br><span class="hljs-keyword">break</span>; <span class="hljs-comment">/*利用SQLCA中的状态信息决定何时退出循环*/</span><br><span class="hljs-keyword">if</span> (count++ == <span class="hljs-number">0</span>) <span class="hljs-comment">/*如果是第一行的话，先打出行头*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%-10s %-20s %-10s %-10s\n&quot;</span>, <span class="hljs-string">&quot;Sno&quot;</span>,<span class="hljs-string">&quot;Sname&quot;</span>,<span class="hljs-string">&quot;Ssex&quot;</span>,<span class="hljs-string">&quot;Sage&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-10s %-20s %-10s %-10d\n &quot;</span>, HSno,Hsname,Hssex,HSage); <span class="hljs-comment">/*打印查询结果*/</span><br><span class="hljs-built_in">printf</span>(“UPDATE AGE(y/n)?”); <span class="hljs-comment">/*询问用户是否要更新该学生的年龄*/</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>,&amp;yn);<br>&#125; <span class="hljs-keyword">while</span>(yn != <span class="hljs-string">&#x27;N&#x27;</span> &amp;&amp; yn != <span class="hljs-string">&#x27;n&#x27;</span> &amp;&amp; yn != <span class="hljs-string">&#x27;Y&#x27;</span> &amp;&amp; yn != <span class="hljs-string">&#x27;y&#x27;</span>);<br><span class="hljs-keyword">if</span> (yn == <span class="hljs-string">&#x27;y&#x27;</span> || yn == <span class="hljs-string">&#x27;Y&#x27;</span>) <span class="hljs-comment">/*如果选择更新操作*/</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;INPUT NEW AGE:&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;NEWAGE); <span class="hljs-comment">/*用户输入新年龄到主变量中*/</span><br>EXEC SQL UPDATE Student <span class="hljs-comment">/*嵌入式SQL更新语句*/</span><br>SET Sage = :NEWAGE<br>WHERE CURRENT OF SX;<br>&#125; <span class="hljs-comment">/*对当前游标指向的学生年龄进行更新*/</span><br>&#125;<br>EXEC SQL CLOSE SX; <span class="hljs-comment">/*关闭游标SX，不再和查询结果对应*/</span><br>EXEC SQL COMMIT WORK; <span class="hljs-comment">/*提交更新*/</span><br>EXEC SQL DISCONNECT TEST; <span class="hljs-comment">/*断开数据库连接*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，游标相关</p><ul><li>EXEC SQL DECLARE <em>SX</em> CURSOR FOR…</li><li>EXEC SQL OPEN SX;</li><li>EXEC SQL FETCH SX INTO : HSno,: Hsname,: HSsex,: HSage;</li><li>EXEC SQL UPDATE Student<br>SET Sage = : NEWAGE<br>WHERE CURRENT OF SX;</li><li>EXEC SQL CLOSE SX;</li></ul><p>异常处理<br>whenever 语句用于定义异常处理办法<br>最常见的执行异常是：sqlerror 和 not found<br>最常用的异常处理办法是： 用 goto 语句跳转到特定的语句标号处，进行异常处理</p><ul><li>exec sql whenever sqlerror goto report_error（语句标号）</li></ul><p>EXEC SQL WHENEVER condition action;</p><ul><li>condition: SQLERROR | NOT FOUND | SQLWARNING</li><li>action: CONTINUE | GOTO label | STOP | DO function | BREAK</li></ul><p>不使用游标的 SQL 语句</p><ul><li>说明性语句</li><li>数据定义语句</li><li>数据控制语句</li><li>查询结果为单记录的 SELECT 语句</li><li>非 CURRENT 形式的 INSERT、DELETE、UPDATE 等增删改语句</li></ul><p>必须使用游标的 SQL 语句</p><ul><li>查询结果为多条记录的 SELECT 语句</li><li>CURRENT 形式的 UPDATE 语句</li><li>CURRENT 形式的 DELETE 语句</li></ul><p>CURRENT 形式的 UPDATE 或 DELETE 语句</p><ul><li>在 UPDATE 语句或 DELETE 语句中要用子句 WHERE CURRENT OF &lt;游标名&gt;</li><li>表示修改或删除最近一次取出的记录，即游标指针当前指向的记录</li></ul><p>动态 SQL</p><ol><li>使用 SQL 语句主变量</li><li>动态参数</li><li>执行准备好的语句（EXECUTE）</li></ol><p><img src="2025060628.png" alt=""></p><p>动态参数</p><ul><li>SQL 语句中的可变元素</li><li>使用参数符号（?）表示该位置的数据在运行时设定</li></ul><p>和主变量的区别</p><ul><li>动态参数的输入不是编译时完成绑定</li><li>而是通过 PREPARE 语句准备主变量和执行语句 EXECUTE 绑定数据或主变量来完成</li></ul><p>使用动态参数的步骤</p><ol><li>声明 SQL 语句主变量</li><li>准备 SQL 语句（PREPARE）<ol><li>EXEC SQL PREPARE &lt;语句名&gt; FROM &lt;SQL 语句主变量&gt;;</li></ol></li></ol><p>执行</p><ul><li>EXEC SQL EXECUTE &lt;语句名&gt; [INTO &lt;主变量表&gt;] [USING &lt;主变量或常量&gt;];</li></ul><p><img src="2025060680.png" alt=""></p><p>过程化 SQL<br>为了能够在数据库中实现部分应用程序逻辑，需要在交互式 SQL 语言的基础上扩充部分过程式程序设计语言的成份，构成一个可编程的 SQL 语言，称为过程化 SQL，又被称为过程式 SQL、可编程 SQL。<br>过程化 SQL 相对于嵌入式 SQL 的优势</p><ul><li>可独立编程，不再需要区分主变量与 SQL 变量</li><li>不需要经历从预编译到编译的处理</li><li>在数据库服务器内部实现数据交换与处理</li></ul><p>过程化 SQL 的基本结构是 ‘块’</p><ul><li>块之间可以互相嵌套</li><li>每个块完成一个逻辑操作</li></ul><p>PL/SQL 变量定义 三种方式</p><ul><li>基本数据类型<ul><li>sex BOOLEAN :=TRUE； age number (3) not null:=25；</li></ul></li><li>%TYPE<ul><li>声明一个变量，使它的类型与某个变量或数据库表中某个列的数据类型一致</li></ul></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">DECLARE</span><br>teacher_name char(<span class="hljs-number">5</span>)<br>student_name teacher_name %<span class="hljs-keyword">TYPE</span><br><span class="hljs-type">BEGIN</span><br><span class="hljs-type"></span>...<br><span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><ul><li>记录类型定义的一般格式<ul><li>TYPE &lt;recordtypename&gt; IS RECORD ( &lt;field&gt; &lt;datatype&gt; [[NOT NULL]{DEFAULT|:=} &lt;expression&gt;] [,&lt;field&gt; …] );</li></ul></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">DECLARE</span><br><span class="hljs-keyword">TYPE</span> student <span class="hljs-keyword">IS</span> <span class="hljs-type">RECORD</span> （<br>id NUMBER(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>, <span class="hljs-comment">/* 非空时必须加上缺省值 */</span><br><span class="hljs-type">name</span> <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) ,<br>sex <span class="hljs-type">BOOLEAN</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span>,<br>birthdate <span class="hljs-type">DATE</span>,<br>physics NUMBER(<span class="hljs-number">3</span>),<br>chemistry NUMBER(<span class="hljs-number">3</span>)<br>);<br><span class="hljs-comment">/* 下面定义一个student 类型的变量 */</span><br>student1 student;<br></code></pre></td></tr></table></figure><p>声明一个记录型变量，使它的类型与某个基本表的数据结构一致，用%ROWTYPE</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts">DECLARE<br>emp_val emp<span class="hljs-variable">&amp;</span>ROWTYPE<span class="hljs-punctuation">;</span><br><span class="hljs-comment">/*定义与关系表emp的表结构相同的记录行变量emp_val*/</span><br>变量引用方式：emp_val.empno <span class="hljs-comment">/*empno是emp中的一个属性*/</span><br></code></pre></td></tr></table></figure><p>局部变量：在过程块中定义的变量，只能在块内引用<br>全局变量：在块外定义，使用时需要加’: '前缀<br>游标属性</p><ul><li>%ISOPEN 如果游标已经打开，返回 TRUE，否则返回 FALSE。</li><li>%FOUND 如果最近一次使用 FETCH 语句，有返回结果则为 TRUE，否则为 FALSE;</li><li>%NOTFOUND 如果最近一次使用 FETCH 语句，没有返回结果则为 TRUE，否则为 FALSE;</li><li>%ROWCOUNT 数值型。描述的是到目前为止实际从游标工作区取的记录数。</li></ul><p>T-SQL<br>局部变量</p><ul><li>用户自己定义的变量，用于在语句之间传递数据</li><li>以@开头<br>全局变量</li><li>是系统定义的变量，用于存储系统的特定信息</li><li>用户不能建立全局变量，也不能修改其值</li><li>以@@开头</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE Northwind<br>GO<br><span class="hljs-keyword">DECLARE</span> <span class="hljs-variable">@EmpIDVariable</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@EmpIDVariable</span> <span class="hljs-operator">=</span> EmployeeID<br><span class="hljs-keyword">FROM</span> Employees<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> EmployeeID <span class="hljs-keyword">DESC</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@EmpIDVariable</span><br>GO<br></code></pre></td></tr></table></figure><p>存储过程<br>用过程化 SQL 编写的过程，经编译和优化后存储在数据库服务器中，因而被称为 ‘存储过程<br>创建 CREATE [OR REPLACE] PROCEDURE 过程名 ([参数 1, 参数 2,…]) AS &lt;过程化 SQL 块&gt;;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">OR</span> REPLACE <span class="hljs-keyword">PROCEDURE</span> TRANSFER<br>( inAccount <span class="hljs-type">INT</span>, outAccount <span class="hljs-type">INT</span>, amount <span class="hljs-type">FLOAT</span> )<br><span class="hljs-comment">/* 定义存储过程TRANSFER，如果该过程已经存在则覆盖其原有定义 */</span><br><span class="hljs-comment">/* 三个输入参数：转入账户、转出账户、转账额度 */</span><br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">DECLARE</span> <span class="hljs-comment">/* 定义变量 */</span><br>totalDepositOut <span class="hljs-type">Float</span>;<br>totalDepositIn <span class="hljs-type">Float</span>;<br>inAccountnum <span class="hljs-type">INT</span><br><span class="hljs-keyword">BEGIN</span> <span class="hljs-comment">/* 过程体执行部分的开始 */</span><br><span class="hljs-comment">/* 检查转出账户及其余额 */</span><br><span class="hljs-keyword">SELECT</span> Total <span class="hljs-keyword">INTO</span> totalDepositOut <span class="hljs-keyword">FROM</span> Accout <span class="hljs-keyword">WHERE</span> accountnum<span class="hljs-operator">=</span>outAccount;<br>IF totalDepositOut <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span> <span class="hljs-comment">/* 转出账户不存在或账户中没有存款 */</span><br><span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">/* 回滚事务 */</span><br><span class="hljs-keyword">RETURN</span>;<br><span class="hljs-keyword">END</span> IF;<br>IF totalDepositOut <span class="hljs-operator">&lt;</span> amount <span class="hljs-keyword">THEN</span> <span class="hljs-comment">/*如果账户存款不足*/</span><br><span class="hljs-keyword">ROLLBACK</span>; <span class="hljs-comment">/* 回滚事务 */</span><br><span class="hljs-keyword">RETURN</span>;<br><span class="hljs-keyword">END</span> IF;<br>.....<br></code></pre></td></tr></table></figure><p>执行存储过程：CALL/PERFORM PROCEDURE 过程名 ([参数 1, 参数 2,…]);</p><p><strong>数据库设计</strong><br>对于一个给定的应用环境，构造（设计）优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求<br>步骤</p><ul><li>需求分析</li><li>概念结构设计<ul><li>概念模型：E-R 图</li><li>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念数据模型</li></ul></li><li>逻辑结构设计<ul><li>形成外模式</li><li>将概念结构转换为某个数据库管理系统所支持的逻辑数据模型，并对其进行优化</li></ul></li><li>物理结构设计<ul><li>形成内模式</li><li>为逻辑数据结构选取一个最适合应用环境的物理结构，包括存储结构和存取方法</li></ul></li><li>数据库实施</li><li>数据库运行和维护</li></ul><p>需求分析<br>数据字典：数据项 数据结构 数据流 数据存储 处理过程<br>需求分析的结果：数据字典，用户需求规格说明书</p><p>概念结构设计<br>常用策略：自顶向下地进行需求分析 &amp; 自底向上地设计概念结构<br>自底向上设计概念结构的步骤</p><ol><li>第 1 步：抽象数据并设计局部视图</li><li>第 2 步：集成局部视图，得到全局概念结构</li></ol><p>实体&amp;属性</p><ul><li>作为属性，不能再具有需要描述的性质。属性必须是不可分的数据项，不能包含其他属性</li><li>属性不能与其他实体具有联系，即 E-R 图中所表示的联系是实体之间的联系。</li></ul><p>逻辑结构设计<br>把概念结构设计阶段设计好的基本 E-R 图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构<br>关系数据模型的优化</p><ul><li>关系规范化设计：确定数据依赖 + 规范化设计</li><li>不同关系之间冗余函数依赖的检查</li><li>并不是规范化程度越高的关系就越优</li></ul><p>关系模式的分解：</p><ul><li>水平：把 (基本) 关系的元组集合划分为若干子集合，定义每个子集合为一个子关系，以提高系统的效率。</li><li>把关系模式 R 的属性集划分解为若干子集合，形成若干子关系模式。</li></ul><p>基本方法：</p><ul><li>每个‘实体集’被转换成一个关系</li><li>每个‘联系’通常也被转换成一个关系</li></ul><p>物理结构设计<br>数据库在物理设备上的存储结构与存取方法称为数据库的物理结构， 它依赖于选定的数据库管理系统。<br>步骤</p><ul><li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构;</li><li>对物理结构进行评价，评价的重点是时间和空间效率</li></ul><p>扩展 ER 模型<br>ISA 联系</p><ul><li>不相交约束<ul><li>父类中的一个实体不能同时属于多个子类中的实体集。即父类中的一个实体最多属于一个子类实体集。</li><li>用 ISA 联系符号中的一个叉号“X” 来表示</li></ul></li><li>可重叠约束</li><li>完全特化：父类中的每一个实体，必须是某一个子类中的实体；双线连接</li><li>部分特化：允许父类中的某些实体不属于任何一个子类</li></ul><p>基数约束</p><ul><li>min = 1 要求 E 中的每一个实体在联系 R 中至少出现一次<ul><li>强制参与</li></ul></li><li>min = 0 允许 E 中的某些实体在联系 R 中不出现<ul><li>非强制参与</li></ul></li><li>max = 1 E 中的每一个实体在联系 R 中最多只出现一次<ul><li>单值参与</li></ul></li><li>max = * 允许 E 中的某些实体在联系 R 中可以出现多次<ul><li>多值参与</li></ul></li></ul><p><strong>关系数据理论</strong><br>函数依赖：设 R (U) 是一个属性集 U 上的关系模式，X 和 Y 是 U 的子集。若对于 R (U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不等，则称“X 函数确定 Y”或“Y 函数依赖于 X”，记作 X→Y。</p><p>平法 &amp; 非平凡：</p><ul><li>非平凡，如果 X → Y 但 X ⊈ Y</li><li>平凡，如果 X → Y 但 X 属于 Y</li></ul><p>完全 &amp; 部分：</p><ul><li>如果 X → Y, 并且对于 X 的任何一个真子集 X’, 都有 X’ ↛ Y, 则称 X 对 Y 完全函数依赖</li></ul><p>传递：</p><ul><li>如果 X → Y，Y ⊈ X，Y ↛ X，Y → Z，Z ⊈ Y, 则称 Z 对 X 传递函数依赖</li></ul><p>候选码：K -F-&gt; U，K 是 R 的一个候选码，简称码<br>超码：K -&gt; U（部分 or 完全）, 则 K 是超码</p><ul><li>候选码是最小的超码，候选码的真子集一定不是超码</li></ul><p>全码：R 的所有属性 U 是 R 的码<br>若有多个候选码，则选定一个做为主码<br>主属性：包含在任何一个候选码中的属性<br>外码：R 中属性或属性组 X 并非 R 的码，但是另一个关系模式的码</p><p>范式<br>2NF：若关系模式 R ∈ 1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则 R ∈ 2NF</p><ul><li>消除 非对主 的部分函数依赖</li></ul><p>3NF：设关系模式 R(U, F) ∈ 1NF，若 R 中不存在这样的码 X、属性组 Y 及非主属性 Z（Z ⊈ Y）, 使得 X → Y，Y → Z 成立，Y ↛ X，则称 R(U, F) ∈ 3NF.</p><ul><li>消除 非主属性对候选码 的传递函数依赖</li></ul><p>BCNF：设关系模式 R(U, F) ∈ 1NF，若 X → Y 且 Y ⊈ X 时 X 必含有码，则 R(U, F) ∈ BCNF.</p><ul><li>如果每一个决定属性集都包含候选码</li><li>性质<ul><li>所有非主属性都完全函数依赖于每个候选码</li><li>所有主属性都完全函数依赖于每个不包含它的候选码</li><li>没有任何属性完全函数依赖于非码的任何一组属性</li></ul></li></ul><p>Armstrong 公理<br>基本规则</p><ul><li>自反率：若 Y ⊆ X ⊆ U，则 X → Y 为 F 所蕴涵。</li><li>增广率：若 X → Y 为 F 所蕴涵，且 Z ⊆ U，则 XZ → YZ</li><li>传递率：若 X → Y 及 Y → Z 为 F 所蕴含，则 X → Z 为 F 所蕴含</li></ul><p>推理规则</p><ul><li>合并规则：若 X → Y 及 X → Z，则 X → YZ</li><li>分解规则：若 X → Y 及 Z ⊆ Y，则 X → Z</li><li>伪传递规则：若 X → Y 及 WY → Z，则 XW → Z</li></ul><p>函数依赖集 F 的闭包 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">F^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7713em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></p><ul><li>为 F 所逻辑蕴含的函数依赖的全体叫作 F 的闭包</li></ul><p>属性集的闭包</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>X</mi><mi>F</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo>→</mo><mi>A</mi><mtext> 能由</mtext><mi>F</mi><mtext>根据</mtext><mi>A</mi><mi>r</mi><mi>m</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>g</mi><mtext>公里导出，</mtext><mi>A</mi><mo>∈</mo><mi>U</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X_F^{+}=\{A|X \rightarrow A\  能由F根据Armstrong公里导出，A\in U\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">A</span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord cjk_fallback">能由</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord cjk_fallback">根据</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ro</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord cjk_fallback">公里导出，</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mclose">}</span></span></span></span></li></ul><p><em>计算闭包</em><br><img src="2025060633-1.png" alt=""></p><p>极小函数依赖集（最小覆盖）</p><ul><li>F 中任一函数依赖的右部仅含有一个属性；</li><li>F 中不存在这样的函数依赖 X → A， 使得 F 与 F − {X → A} 等价<ul><li>不存在冗余</li></ul></li><li>F 中不存在这样的函数依赖 X → A， X 有真子集 Z 使得 F - {X → A} U {Z → A}与 F 等价<ul><li>不存在部分函数依赖</li></ul></li></ul><p><em>计算最小函数依赖集</em></p><ol><li>把右边变成单属性</li><li>左边是多属性的，看少一个属性能不能推出来</li><li>删除每个依赖，看用剩下的能不能推出来</li><li>把左边一样的合并</li></ol><p>模式分解<br>无损连接 + 保持函数依赖</p><p><em>候选码计算</em></p><ol><li>求最小函数依赖集</li><li>找在左/中/右出现的属性集<ol><li>左：肯定是 右：不可能是 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">U_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ol><p><img src="2025060683.png" alt=""></p><p><em>转换为 3NF 既有无损连接性又保持函数依赖的分解</em></p><ol><li>计算极小函数依赖集</li><li>对 F 中的每一个函数依赖 X → Y 做如下处理<ol><li>如果在分解 ρ 中找不到满足下述条件的关系模式 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo stretchy="false">(</mo><msub><mi>U</mi><mi>Z</mi></msub><mo separator="true">,</mo><msub><mi>F</mi><mi>z</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Z(U_Z,F_z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：XY ⊆ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>U</mi><mi>Z</mi></msub></mrow><annotation encoding="application/x-tex">U_Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">Z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>则由 X 和 Y 合并构成一个新的子关系模式并加入到分解 ρ 中</li></ol></li><li>如果关系 R 的所有候选码都没有出现在分解 ρ 的关系模式中，则任选一个候选码 K，由 K 中的属性单独构成一个关系模式加入分解 ρ</li></ol><p><strong>SQL</strong><br>模式</p><ul><li>create schema 模式名 authrization 用户名 + 表/视图/授权定义子句</li><li>drop schema 模式名 CASCADE | RESTRICT<ul><li>CASCADE 级联：删除模式的同时把该模式中所有的数据库对象全部删除</li><li>RESTRICT 限制：如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行</li></ul></li></ul><p>基本表</p><ul><li>修改 alter table xxxxxx<ul><li>add 新列名 数据类型 完整性约束</li><li>add 表级完整性约束</li><li>drop 列名 CASCADE | RESTRICT</li><li>drop constraint 完整性约束名 CASCADE | RESTRICT</li><li>alter column 列名 数据类型</li></ul></li><li>删除 drop table 表明 CASCADE | RESTRICT</li></ul><p>索引</p><ul><li>create [unique] [cluster] index 索引名 on 表名 （列名 次序…）<ul><li>e.g CREATE UNIQUE INDEX SCno ON SC (Sno ASC, Cno DESC);</li></ul></li><li>drop index 索引名</li></ul><p>查询语句</p><ol><li>目标子句 SELECT [distinct] column-name-list | expressions | *<ol><li>简单的属性投影：可以通过‘表名. 列名’的方式来指明是对哪一张表中的哪个列的投影；</li><li>可以将一个表达式的计算结果投影到某个目标列上；</li><li>可以在目标子句中对投影得到的结果列进行重命名：&lt;column_expression&gt; AS &lt;colname&gt;</li><li>可用‘ * ’来代替表中的所有列；</li><li>可添加保留字 distinct 来消除结果表中的重复元组。</li></ol></li><li>范围子句： FROM tablename { , tablename … }<ol><li>可以在 FROM 子句中对一个表重新命名（即定义一个别名 alias）： &lt;table_name&gt; &lt;alias_name&gt;</li></ol></li><li>条件子句： WHERE search_condition<ol><li>在 FROM 子句中给出的表只是表明此次查询需要访问这些表，它们之间是通过笛卡儿积运算进行合并的</li><li>如果需要执行它们之间的‘θ-连接’或‘自然连接’运算，则需要在 WHERE 子句中显式地给出它们的连接条件。</li></ol></li></ol><p>查询满足条件的元组</p><ul><li>比较大小：=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;</li><li>确定范围：BETWEEN … AND … 或 NOT BETWEEN … AND …</li><li>确定集合：IN &lt;值表&gt;, NOT IN &lt;值表&gt;</li><li>字符匹配： [ NOT ] LIKE ‘&lt;匹配串&gt;’ [ ESCAPE ‘&lt;换码字符&gt;’ ]<ul><li>ESCAPE 使用换码字符将通配符转义为普通字符<ul><li>WHERE Cname LIKE ‘DB\ _ Design’ ESCAPE ‘\’</li></ul></li></ul></li><li>涉及空值的查询： IS NULL 或 IS NOT NULL<ul><li>在 SQL 标准中，“IS” 不能用 “=” 代替</li></ul></li><li>多重条件：逻辑运算符：AND 和 OR 来连接多个查询条件</li></ul><p>对结果进行排序：ORDER BY 子句</p><p>聚集函数：</p><ul><li>count<ul><li>count (*)：返回集合中的元组个数\</li><li>count (colname)：返回在 colname 属性上取值非空的元组个数</li><li>count (distinct colname)：返回 colname 取值非空且互不相同的元组个数</li></ul></li><li>SUM, AVG, MAX, MIN 统计: 分别用于统计一组元组在某个属性上的取值的总和、平均值、最大值、最小值</li></ul><p>三种类型统计查询语句</p><ul><li>统计查询<ul><li>没有 group by, 直接对整个查询结果进行统计计算</li><li>返回单条统计结果</li></ul></li><li>分组统计查询<ul><li>使用 group by 子句，分组进行统计计算</li><li>每一个‘组’返回一条统计结果</li></ul></li><li>分组-选择统计查询<ul><li>使用 group by 子句先分组，再用 having 子句进行‘组’的选择，最后再对符合条件的组进行统计计算</li><li>每一个符合 having 条件的‘组’返回一条统计结果</li></ul></li></ul><p>WHERE 子句中与嵌套查询有关的查询谓词主要有：</p><ul><li>expr [ NOT ] IN ( subquery ) 标量与集合量之间的属于比较</li><li>expr θ SOME|ANY|ALL ( subquery ) 标量与集合中元素之间的量化比较</li><li>: [ NOT ] EXISTS ( subquery ) 是否为空集的判断谓词</li></ul><p>集合操作</p><ul><li>并 UNION</li><li>交 INTERSECT</li><li>差 EXCEPT</li></ul><p>视图</p><ul><li>CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt; [,&lt;列名&gt;]…)] AS &lt;子查询&gt; [WITH CHECK OPTION];</li><li>WITH CHECK OPTION：对视图进行 UPDATE，INSERT 和 DELETE 操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）</li><li>DROP VIEW &lt;视图名&gt; [CASCADE];<ul><li>如果该视图上还导出了其他视图，使用 CASCADE 级联删除语句，把该视图和由它导出的所有视图一起删除。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-数据管理基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-08计算机网络中的安全</title>
    <link href="/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-08%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8/"/>
    <url>/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-08%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<p>总结：</p><ul><li>基本原理<ul><li>加密（对称和公开）</li><li>报文完整性</li><li>端节点的认证（鉴别）</li></ul></li><li>在多种安全场景中使用<ul><li>安全电子邮件</li><li>安全传输层（SSL）</li><li>IP sec</li><li>802.11</li></ul></li><li>运行中的安全性：firewalls &amp; IDS</li></ul><h2 id="网络安全的概念">网络安全的概念</h2><p><strong>机密性</strong> confidentiality：只有发送方和预定的接收方能理解传输的报文内容</p><ul><li>发送方加密报文</li><li>接收方解密报文</li></ul><p><strong>认证</strong> authentication：发送方和接收方需要确认对方的身份<br><strong>报文完整性</strong> message integrity：发送方、接收方需要确认报文在传输的过程中或者事后没有被改变<br><strong>访问控制和服务的可用性</strong> access and availability：服务可以接入以及对用户而言是可用的</p><p>著名的模型：</p><ul><li>Bob, Alice：需要安全的通信</li><li>Trudy：可以截获，删除和增加报文</li></ul><p>网络中的 bad guy 可以做什么：</p><ul><li>窃听：截获报文</li><li>插入：在连接上插入报文</li><li>伪装：在分组的源地址上写伪装的地址</li><li>劫持：将发送方或者接收方踢出，接管连接</li><li>拒绝服务：阻止服务被其它正常用户使用</li></ul><h2 id="加密原理">加密原理</h2><p>加密语言：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span>: plaintext message<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_A(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>: ciphertext, encrypted with key <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">K_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msub><mi>K</mi><mi>B</mi></msub><mo stretchy="false">(</mo><msub><mi>K</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">m=K_B (K_A (m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span></span></span></span></p><p>方法：</p><ul><li>对称密钥密码学：发送方和接收方的密钥相同</li><li>公开密钥密码学：发送方使用接收方的公钥进行加密，接收方使用自己的私钥进行解密</li></ul><h3 id="对称密钥加密">对称密钥加密</h3><p>——Bob 和 Alice 共享一个对称式的密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>A</mi><mo>−</mo><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{A-B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span><br>替换密码：将一个事情换成另一个</p><ul><li>单码替换密码：将一个字母换成另一个字母</li></ul><p><strong>DES</strong>：Data Encryption Standard</p><ul><li>56bit 对称密钥，64bit 明文输出</li></ul><p>AES：Advanced Encryption Standard</p><ul><li>数据 128bit 成组加密</li></ul><h3 id="公开密钥密码学">公开密钥密码学</h3><p><img src="2025053170.png" alt=""></p><p>公开密钥加密算法：</p><ul><li>需要 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{+}(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{-}(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span>，满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K_B^{-}(K_B^{+}(m))=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></li><li>给定一个公钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{+}(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span> 不可能计算出私钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mo>⋅</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{-}(\cdot)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">⋅</span><span class="mclose">)</span></span></span></span></li></ul><h4 id="RSA">RSA</h4><p>背景知识：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><msup><mo stretchy="false">)</mo><mi>d</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi><mo>=</mo><msup><mi>a</mi><mi>d</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">(a\ mod\ n)^d\ mod\ n=a^d\ mod\ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span></span></span></span></p><p>-创建公钥私钥对</p><ol><li>选择 2 个很大的质数 p, q</li><li>计算 n=pq, z=(p-1)(q-1)</li><li>选择一个 e（e&lt;n），和 z 没有公因子，即互素</li><li>选择 d 使得 ed-1 正好被 z 整除，也就是 ed mod z = 1</li><li>公钥（n, e）私钥（n, d）</li></ol><p>-加密解密</p><ul><li>加密一个报文 m，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><msup><mi>m</mi><mi>e</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">c=m^e\ mod\ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">e</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span></span></span></span></li><li>对接收到的 c 解密，计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><msup><mi>c</mi><mi>d</mi></msup><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>n</mi></mrow><annotation encoding="application/x-tex">m=c^d\ mod\ n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8491em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">d</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">n</span></span></span></span></li></ul><p>例：<br><img src="2025053193.png" alt=""></p><p>-另一个重要的特性</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mo>=</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{-}(K_B^{+}(m))=m=K_B^{+}(K_B^{-}(m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2837em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-2.4163em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2837em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-2.4163em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2837em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2837em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-2.4163em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2837em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8213em;"><span style="top:-2.4163em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2837em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span></span></span></span></span></p><p>-实际应用</p><ul><li>指数运算让计算复杂度很高</li><li>DES 比 RSA 至少快 100 倍</li><li>使用公钥加密技术建立安全连接，然后再建立第二个密钥——对称会话密钥 session key <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ——用于数据加密</li></ul><h2 id="认证-Authentication">认证 Authentication</h2><p><img src="960b57f1bf7c12a4893df435f7f3f02.jpg" alt=""></p><h2 id="报文完整性-message-integrity">报文完整性 message integrity</h2><h3 id="数字签名">数字签名</h3><p>类比手写签名</p><ul><li>发送方数字签署了文件，前提是他是文件的拥有者/创建者</li><li>可验证性，不可伪造性，不可抵赖性<ul><li>谁签署：接收方 Alice 可以向他人证明是 Bob，而不是其他人签署了这个文件（包括 Alice）</li><li>签署了什么：这份文件，而不是其他文件</li></ul></li><li>简单对 m 的数字签名<ul><li>Bob 用自己的私钥对 m 进行签署，创建数字签名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{-}(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>假设 Alice 收到报文 m，以及数字签名 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{-}(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></li><li>Alice 用 Bob 的公钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup></mrow><annotation encoding="application/x-tex">K_B^{+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span></span></span></span> 对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B^{-}(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 进行验证，判断 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">−</mo></msubsup><mo stretchy="false">(</mo><msubsup><mi>K</mi><mi>B</mi><mo lspace="0em" rspace="0em">+</mo></msubsup><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">K_B^{-}(K_B^{+}(m))=m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.105em;vertical-align:-0.2935em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8115em;"><span style="top:-2.4065em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.1031em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">+</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2935em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 是否成立</li><li>如果成立，则签署这个文件的人一定有 Bob 的私钥</li></ul></li></ul><h3 id="报文摘要">报文摘要</h3><p>背景：对长报文进行公开密钥加密算法的实施需要耗费大量的时间</p><p>目标：固定长度，容易计算的 fingerprint</p><ul><li>对 m 使用散列函数 H，获得固定长度的报文摘要 H (m)</li></ul><p>散列函数的特性：</p><ul><li>多对一</li><li>结果固定长度</li><li>给定一个报文摘要 x，反向计算出原报文在计算上是不可行的</li></ul><p>Internet 检验和——弱的散列函数</p><ul><li>拥有散列函数的特性<ul><li>产生报文 m 的固定长度摘要</li><li>多对 1</li></ul></li><li>但给定一个散列值，很容易计算出另一个报文具有同样的散列值</li></ul><p><em>数字签名=对保卫摘要进行数字签署</em><br><img src="2025060257.png" alt=""></p><p>可信赖中介</p><ul><li>对称密钥问题：相互通信的实体如何分享对称式的密钥？<ul><li>trusted key distribution center KDC 在实体之间扮演可信赖中介的角色</li></ul></li><li>公共密钥问题：当 Alice 获得 Bob 的公钥，她如何知道是 Bob 的 public key 而不是 Trudy 的？<ul><li>可信赖的 certification authority</li></ul></li></ul><p><strong>Public key Certification Authorities (CA)</strong></p><p>CA：将每一个注册实体 E 和他的公钥捆绑</p><p>entity (person, website, router) 到 CA 注册它的公钥</p><ul><li>E 提供给 CA 自己的身份证据 proof of identity</li><li>CA 创建一个证书，捆绑了实体信息和它的公钥</li><li>certificate 包括了 E 的公钥，而且是被 CA 签署的（被 CA 用私钥加密）</li></ul><p><img src="2025060297.png" alt=""></p><p>当 Alice 需要拿到 Bob 的公钥时：</p><ul><li>获得 Bob 的证书 certificate</li><li>对 Bob 的证书，使用 CA 的公钥来验证</li></ul><h2 id="安全电子邮件">安全电子邮件</h2><p>Alice 需要发送机密的报文 m 给 Bob:<br><img src="2025060227.png" alt=""></p><p>Alice:</p><ul><li>产生随机的对称密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 对报文加密</li><li>对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 使用 Bob 的公钥进行加密</li><li>发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_S(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>B</mi></msub><mo stretchy="false">(</mo><msub><mi>K</mi><mi>S</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_B(K_S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 给 Bob</li></ul><p>Bob:</p><ul><li>使用自己的私钥解密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">K_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 解密 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>S</mi></msub><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_S(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 得到报文</li></ul><p>Alice 需要提供源端的可认证性和报文完整性：<br><img src="2025060271.png" alt=""></p><ul><li>Alice 数字签署文件</li><li>发送报文（明文）和数字签名</li></ul><p>Alice 需要提供机密性，源端可认证性和报文完整性：<br><img src="2025060271-1.png" alt=""></p><p>Alice 使用了 3 个 keys：自己的私钥，Bob 的公钥，新产生的对称式密钥</p><h2 id="安全-TCP-连接：TLS">安全 TCP 连接：TLS</h2><p><strong>Transport-layer security (TLS)</strong><br>提供</p><ul><li>机密性：通过 symmetric encryption</li><li>完整性：通过 cryptographic hashing</li><li>可认证性：通过 public key cryptography</li></ul><p>t-tls 需要什么：</p><ul><li>handshake</li><li>key derivation</li><li>data transfer</li><li>connection closure</li></ul><p>初始握手：</p><ul><li>Bob 与 Alice 建立 TCP 连接</li><li>Bob 验证 Alice 是否真的是 Alice</li><li>Bob 给 Alice 发送 MS，用来生成 TLS 对话中的所有其它 key<br><img src="2025060218.png" alt=""></li></ul><p>cryptographic keys:<br>考虑到使用相同的 key 对多种加密函数是不好的</p><ul><li>对报文认证码 MAC 和加密使用不同的 key</li></ul><p>4 种 keys:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">K_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：从 client 到 server 传输数据时用的 encryption key</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">M_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：从 client 到 server 用的 MAC key</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：从 server 到 client 传输数据时用的 encryption key</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">M_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：从 server 到 client 用的 MAC key</li></ul><p>用 KDF key derivation function 来产生 key</p><ul><li>使用 master secret 和（可能有的）一下其它随机数据来产生新的 key</li></ul><p>加密数据：</p><p>TCP 提供数据字节流的抽象</p><p>我们能否在写入 TCP 套接字时对流中的数据进行加密？</p><ul><li>MAC（报文鉴别编码）放在哪里？如果放在末尾，则在接收完所有数据并关闭连接之前无法验证消息完整性<ul><li>解决方案：将流拆分为一系列“记录”<br>✓ 每个客户端到服务器的记录携带一个 MAC，使用  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">M_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ​  生成<br>✓ 接收方可以在每个记录到达时立即处理</li></ul></li><li>t-tls 记录使用对称密钥  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">K_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ​  加密后传递给 TCP：</li></ul><p><img src="2025060223.png" alt=""></p><p>数据流可能遭受哪些攻击？</p><ul><li>重排序攻击：中间人拦截 TCP 分段并重新排序（通过篡改未加密的 TCP 头部中的序列号）</li><li>重放攻击</li></ul><p>解决方案：</p><ul><li>使用 TLS 序列号（将数据和 TLS 序列号包含在 MAC 的计算中）</li><li>使用随机数（nonce）</li></ul><p>关闭连接：<br>截断攻击：</p><ul><li>攻击者伪造 TCP 连接关闭分段</li><li>导致一方或双方认为实际数据量比真实情况少</li></ul><p>解决方案：使用记录类型标记，其中一种类型专用于关闭</p><ul><li>类型 0 表示数据；类型 1 表示关闭</li></ul><p>现在 MAC 的计算包含数据、类型和序列号：<br><img src="2025060230.png" alt=""></p><h2 id="网络层安全：IPsec">网络层安全：IPsec</h2><p>提供数据报级别的加密、认证、完整性</p><ul><li>适用于用户流量和控制流量（例：BGP、DNS 消息）</li></ul><p>两种模式：<br><img src="2025060259.png" alt=""><br>2 个 IPsec 协议：</p><ul><li>认证头部 Authentication Header (AH) 协议<ul><li>提供可认证性和完整性，不提供私密性</li></ul></li><li>Encapsulation Security Protocal (ESP) 协议<ul><li>提供可认证性、完整性、私密性</li></ul></li></ul><h3 id="Security-associations-SAs">Security associations SAs</h3><ul><li>发送数据前，从发送方到接收方建立安全关联 SA</li><li>结束时，接收方维护关于 SA 的状态信息<ul><li>TCP 端点也维护状态信息</li><li>IP 是无状态的，IPsec 是有连接的</li></ul></li></ul><p><img src="2025060298.png" alt=""></p><p><strong>IPsec datagram</strong><br>隧道模式 ESP （图片中 ESP auth 不是 authenticated）<br><img src="2025060269.png" alt=""></p><ul><li>ESP 尾部：分组密码的填充</li><li>ESP 头部<ul><li>SPI，接收方知道如何处理</li><li>序列号，防止重放攻击</li></ul></li><li>ESP 认证字段中的 MAC 由共享密钥生成</li></ul><p>ESP 隧道模式：操作<br><img src="2025060267.png" alt=""></p><p><strong>IPsec sequence numbers</strong><br>对新的安全关联 SA，发送方将序列号初始化为 0<br>每次在 SA 上发送数据时：</p><ul><li>发送方递增序列号计数器</li><li>将值放入序列号字段</li></ul><p>目标：</p><ul><li>防止攻击者窃听和重放数据包</li><li>收到重复的、经过认证的 IP 数据包可能会中断服务</li></ul><p>方法：</p><ul><li>目的地检查重复项</li><li>不跟踪所有接收到的数据包，而是使用窗口</li></ul><p>IPsec security databases<br><img src="2025060279.png" alt=""></p><h3 id="IKE-Internet-Key-Exchange">IKE Internet Key Exchange</h3><p><strong>背景：</strong><br><img src="2025060246.png" alt=""></p><p><strong>IKE: PSK &amp; PKI</strong><br>身份验证可以通过</p><ul><li>预共享密钥 PSK</li><li>PKI（公钥/密钥和证书）</li></ul><p>PSK：双方从密钥开始</p><ul><li>运行 IKE 来互相验证并生成 IPsec SA （每个方向一个），包括加密、认证密钥</li></ul><p>PKI：双方均以公钥/私钥对和证书开始</p><ul><li>运行 IKE 以相互认证，获取 IPsec SA（每个方向一个）</li><li>与 SSL 中握手类似</li></ul><p><strong>IKE 阶段</strong><br>阶段 1：建立双向的 IKE SA</p><ul><li>注意：IKE SA 不同于 IPsec SA</li><li>也成为 ISAKMP 安全关联</li></ul><p>阶段 2：ISAKMP 用于安全协商 IPsec 的 SAs 对</p><p>阶段 1 有两种模式：激进模式和主模式</p><ul><li>激进模式用更少的消息</li><li>主模式提供身份保护且更灵活</li></ul><h3 id="IPsec-Summary">IPsec Summary</h3><ul><li>算法、密钥、SPI 编号的 IKE 消息交换</li><li>AH 或 SEP 协议<ul><li>AH 提供完整性、源认证</li><li>ESP 额外提供加密</li></ul></li><li>IPsec 对 可以是两个终端系统、两个路由器/防火墙，或一个路由器/防火墙和一个终端系统</li></ul><h2 id="无线和移动网络中的安全">无线和移动网络中的安全</h2><h3 id="802-11：认证、加密">802.11：认证、加密</h3><p><img src="2025060263.png" alt=""></p><p>到达的移动设备必须：</p><ul><li>与接入点关联：通过无线链路的通信</li><li>认证到网络</li></ul><p><img src="2025060235.png" alt=""></p><p><em>(1) discovery of security capabilities</em></p><ul><li>AP 宣告其存在，提供的认证和加密方式</li><li>设备请求特定的认证方式，期望的加密方式</li></ul><p>尽管设备和 AP 已经开始交换消息，但设备尚未通过认证，也没有加密密钥</p><p><em>(2) 相互认证和共享对称密钥生成</em></p><ul><li>AS 和移动设备已经共享了共同秘密（例如，密码）</li><li>AS 和移动设备使用共享秘密、非对称（防止中继攻击）、密码散列（确保消息完整性）来相互认证</li><li>AS 和移动设备推导出对称会话密钥</li></ul><p><img src="2025060222.png" alt=""></p><p>a. AS 生成随机数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>A</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Nonce_{AS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，发送给移动设备<br>b. 移动设备接收 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>A</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Nonce_{AS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><ul><li>生成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">Nonce_{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>A</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Nonce_{AS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">Nonce_{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和初始共享密钥 生成对称共享对话密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>M</mi><mo>−</mo><mi>A</mi><mi>P</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{M-AP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></li><li>发送 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">Nonce_{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 HMAC-signed value using <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>o</mi><mi>n</mi><mi>c</mi><msub><mi>e</mi><mrow><mi>A</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Nonce_{AS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和初始共享密钥</li></ul><p>c. AS 生成对称共享对话密钥 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mrow><mi>M</mi><mo>−</mo><mi>A</mi><mi>P</mi></mrow></msub></mrow><annotation encoding="application/x-tex">K_{M-AP}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span></p><p><em>(3) 共享对称会话密钥分发</em>（例，用于 AES 加密）</p><ul><li>移动端和 AS 处生成相同的密钥</li><li>AS 通知 AP 共享对称对话</li></ul><p><em>(4) 通过 AP 在移动设备和远程主机之间进行加密通信</em></p><p><img src="2025060287-1.png" alt=""></p><p>Extensive Authentication Protocal (EAP)：定义了移动设备与认证服务器 (AS) 之间的端到端请求/响应协议</p><h3 id="4G-LTE-中的认证、加密">4G LTE 中的认证、加密</h3><p><img src="2025060218-1.png" alt=""><br><img src="2025060250.png" alt=""><br><img src="2025060267-1.png" alt=""></p><p><img src="2025060284.png" alt=""></p><p><em>a. 向归属网络 HSS 发送认证请求</em></p><ul><li>移动设备发送 attach 消息（包含其 IMSI、访问网络信息），由 BS 中继到访问 MME，再传到归属 HSS</li><li>IMSI 标识移动设备的归属网络</li></ul><p><em>b. HSS 使用预先共享的密钥 K_HSS-M 来派生认证令牌 auth_token 和预期的认证响应令牌 xres_HSS</em></p><ul><li>auth*token 包含 HSS 使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∗</mo><mrow><mi>H</mi><mi>S</mi><mi>S</mi><mo>−</mo><mi>M</mi></mrow></mrow><annotation encoding="application/x-tex">K*{HSS-M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.05764em;">SS</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span> 加密的信息，允许移动设备知道无论谁计算了 auth_token，都了解预先共享的密钥</li><li>移动设备已认证网络</li><li>访问过的 HSS 保留 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>r</mi><mi>e</mi><msub><mi>s</mi><mrow><mi>H</mi><mi>S</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">xres_{HSS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">SS</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 供以后使用</li></ul><p><em>c. 来自移动设备的认证响应</em></p><ul><li>移动设备使用其密钥计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><msub><mi>s</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">res_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，进行与 HSS 相同的加密计算以计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>r</mi><mi>e</mi><msub><mi>s</mi><mi>H</mi></msub><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">xres_HSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05764em;">SS</span></span></span></span>，并将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><msub><mi>s</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">res_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 发送给 MME</li></ul><p><em>d. 移动设备通过网络进行认证</em></p><ul><li>MMS 比较移动计算出的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><msub><mi>s</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">res_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 值与 HSS 计算出的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>r</mi><mi>e</mi><msub><mi>s</mi><mrow><mi>H</mi><mi>S</mi><mi>S</mi></mrow></msub></mrow><annotation encoding="application/x-tex">xres_{HSS}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">re</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.08125em;">H</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">SS</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 值。如果它们匹配，移动就通过认证了！</li><li>MMS 通知 BS 移动已通过认证，为 BS 生成密钥</li></ul><p><em>e. 移动设备、BS 确定用于在 4G 无线信道上加密数据和控制帧的密钥</em></p><ul><li>可以使用 AES</li></ul><p>从 4G 到 5G：<br><img src="2025060234.png" alt=""></p><h2 id="运营安全：防火墙和-IDS">运营安全：防火墙和 IDS</h2><h3 id="防火墙">防火墙</h3><p>将组织内部网络和互联网隔离开来，按照规则允许某些分组通过（进出），或阻塞某些分组<br><img src="2025060270.png" alt=""><br>用处：</p><ul><li>防止拒绝服务攻击 Deny of Service DOS<ul><li>SYN flooding：攻击者建立许多伪造的 TCP 连接，对于真正用户而言已经没有资源留下了</li></ul></li><li>阻止非法的修改/对非授权内容的访问<ul><li>例如：攻击者替换掉 CIA 的主页</li></ul></li><li>只允许认证的用户访问内部网络资源<ul><li>认证用户/主机的集合</li></ul></li></ul><p>3 种类型的防火墙</p><ul><li>网络级别：分组过滤器<ul><li>有状态 &amp; 无状态</li></ul></li><li>应用级别：应用程序网关</li></ul><h3 id="无状态分组过滤器">无状态分组过滤器</h3><p><img src="2025060296.png" alt=""><br>内部网络通过配置防火墙的路由器连接到互联网上<br>路由器对分组逐个过滤，根据以下规则来决定转发还是丢弃</p><ul><li>源 IP 地址，目的 IP 地址</li><li>TCP/UDP 源，目的端口号</li><li>ICMP 消息类型</li><li>TCP SYN，ACK bits</li></ul><p>示例 1：阻止 IP 协议字段为 17 且源端口或目的端口为 23 的入站和出站数据报</p><ul><li>结果：所有入站和出站 UDP 流以及 Telnet 连接都被阻止</li></ul><p>示例 2：阻止 ACK=0 的入站 TCP 段</p><ul><li>结果：阻止外部客户端与内部客户端建立 TCP 连接，但允许内部客户端连接到外部</li></ul><p><strong>访问控制列表</strong><br>ACL：规则的表格，top-bottom 应用到输入的分组 (action, condition) 对<br><img src="2025060277.png" alt=""></p><h3 id="有状态分组过滤">有状态分组过滤</h3><p>无状态分组过滤：heacy handed tool</p><ul><li>允许那些“毫无意义”的数据包，例如目标端口为 80，ACK 位被设置，即使没有建立 TCP 连接</li></ul><p>有状态分组过滤：跟踪每个 TCP 连接的状态</p><ul><li>跟踪连接建立（SYN）、拆除（FIN）：确定传入、传出数据包是否合理</li><li>在防火墙超时非活动连接：不再允许数据包通过</li></ul><p>ACL 增强以指示在允许数据包之前需要检查连接状态表<br><img src="2025060218-2.png" alt=""></p><h3 id="应用程序网关">应用程序网关</h3><p>根据应用数据的内容来过滤进出的数据报<br>例：允许部分内容用户 telnet 外部</p><ol><li>要求所有 telnet 用户通过网关 telnet</li><li>对认证的用户而言，网关建立与目标主机的 telnet 连接，网关在两个连接上进行中继</li><li>路由器过滤器对所有不是来自网关的 telnet 的分组全部过滤掉</li></ol><p><strong>防火墙和网关的局限性</strong></p><ul><li>IP spoofing：路由器无法确定数据是否真的来自声称的源</li><li>如果多个应用程序需要特殊处理，每个应用程序都有自己的应用程序网关</li><li>客户端软件必须知道如何联系网关<ul><li>例如，必须在网络浏览器中设置代理的 IP 地址</li></ul></li><li>过滤器通常对 UDP 使用全有或全无策略</li><li>折中：与外部通信的自由度，安全的级别</li><li>许多高度受保护的站点仍然遭受攻击</li></ul><h3 id="入侵检测系统-IDS">入侵检测系统 IDS</h3><p>分组过滤</p><ul><li>对 TCP/IP 头部进行检查</li><li>不检查会话间的相关性</li></ul><p>IDS：intruction detection system</p><ul><li>深入分组检查，检查分组的内容（例如，检查包中的字符字符串与已知病毒、攻击字符串的数据库进行比对）</li><li>检查分组间的相关性，判断是否是有害的分组<ul><li>端口扫描</li><li>网络映射</li><li>DoS 攻击</li></ul></li></ul><p>multiple IDSs：在不同的地点进行不同类型的检查<br><img src="2025060213.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-07无线网络和移动网络</title>
    <link href="/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-07%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/"/>
    <url>/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-07%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="引入">引入</h2><p>无线网络的组成元素<br><img src="2025060244.png" alt=""></p><p>无线主机：</p><ul><li>笔记本电脑、智能手机、物联网</li><li>运行应用程序</li><li>可能是固定的或移动的<ul><li>无线并不总意味着移动</li></ul></li></ul><p>基站：</p><ul><li>通常连接到有线网络</li><li>中继器：复杂在有线的网络和其“区域”内的无线主机之间发送数据报<ul><li>例：蜂窝塔、802.11 接入点</li></ul></li></ul><p>无线链路：</p><ul><li>通常用于连接移动设备到基站，也用作骨干链路</li><li>多址协议协调链路访问</li><li>各种传输速率和距离，频率带</li></ul><p><img src="2025060203.png" alt=""></p><p>基础设施模式：</p><ul><li>基站将移动设备连接到有线网络</li><li>切换：移动设备更换提供连接到有线网络的基站</li></ul><p>ad hoc 模式：</p><ul><li>没有基站</li><li>节点只能向链接覆盖范围内的其它节点传输</li><li>节点自行组织成网络：彼此之间进行路由</li></ul><p><img src="2025060202.png" alt=""></p><h2 id="无线">无线</h2><h3 id="无线链路和网络特性">无线链路和网络特性</h3><h4 id="fading-衰减">fading 衰减</h4><p>无线电信号在传播过程中会衰减（失去能量）（自由空间“路径损耗”）<br><img src="2025060201.png" alt=""></p><h4 id="mutipath-多径">mutipath 多径</h4><p>多径传播：无线电信号从地面、建筑物等物体反射，到达目的地的时间略有不同</p><p><img src="2025060274.png" alt=""></p><p><img src="2025060250-1.png" alt=""></p><h4 id="noise-噪声">noise 噪声</h4><p><img src="2025060272.png" alt=""><br><strong>信噪比 SNR</strong> signal-to-noise ratio</p><ul><li>较大的信噪比——更容易从噪声中提取信号（一件“好事”）</li></ul><p><em>信噪比 SNR 与误码率 BER</em> 之间的权衡</p><ul><li>给定物理层：增加功率 &gt; 增加信噪比 -&gt; 降低误码率</li><li>信噪比可能随移动性变化：动态调整物理层（调制技术、速率）</li></ul><h4 id="hidden-terminals-隐藏终端">hidden terminals 隐藏终端</h4><p><img src="2025060251.png" alt=""></p><h3 id="CDMA：码分多址">CDMA：码分多址</h3><p>Code Division Multiple Access</p><ul><li>为每个用户分配唯一的“码”，即码集划分<ul><li>所有用户共享相同频率，但每个用户有自己的“码片”</li><li>允许多个用户“共存”，并以最小干扰同时传播（如果码是“正交”）</li></ul></li><li>编码：内积：原始数据 x 扩频序列</li><li>解码：累加内积：编码数据 x 扩频序列</li></ul><p><img src="2025060242.png" alt=""></p><p>双发干扰：<br><img src="2025060299.png" alt=""></p><h3 id="WiFi：802-11-wireless-LANs">WiFi：802.11 wireless LANs</h3><p><img src="2025060294.png" alt=""></p><ul><li>无线主机与基站通信<ul><li>base station = access point AP 基站=接入点</li></ul></li><li>在基础设施模式下，基本服务集 BSS（又名蜂窝）包含：<ul><li>无线主机</li><li>接入点 AP</li><li>ac hoc 模型：仅主机</li></ul></li></ul><p><strong>Channels 信道</strong><br>频谱在不同频率上划分为信道</p><ul><li>AP 管理员选择 AP 的频率</li><li>可能存在干扰，信道可能与邻近 AP 选择的相同</li></ul><p><img src="2025060296-1.png" alt=""></p><p><strong>Association 关联</strong><br>到达主机：必须与主机关联</p><ul><li>扫描信道，监听包含 AP 名称 SSID 和 MAC 地址的信标帧</li><li>选择要关联的 AP</li><li>然后可能执行认证</li><li>然后通常运行 DHCP 以获取 AP 子网中的 IP 地址</li></ul><p><strong>passive/active scanning 被动/主动扫描</strong><br><img src="2025060213-1.png" alt=""></p><p>被动扫描：</p><ol><li>来自 APs 的 beacon 帧</li><li>发送关联请求帧：H1 到选定的 AP</li><li>选定 AP 发送给 H1 的关联响应帧</li></ol><p>主动扫描</p><ol><li>H1 广播探测请求帧</li><li>来自 APs 的探测响应帧</li><li>发送给选定 AP 的关联请求帧：H1 到选定 AP</li><li>从选定 AP 发送给 H1 的关联响应帧</li></ol><p><strong>IEEE 802.11: 多路访问</strong><br>避免冲突：两个节点同时传输<br>802.11：CSMA - 传输前先感知</p><ul><li><p>不要与另一个正在进行的传输发生冲突</p><p>802.11：没有冲突检测</p></li><li><p>难以感知碰撞：高发射信号，由于衰落接收信号弱</p></li><li><p>无法在任何情况下检测到所有碰撞：隐藏终端，衰落</p></li><li><p>目标：避免碰撞：CSMA/Collision Avoidance</p></li></ul><p><strong>IEEE 802.11 MAC Protocol: CSMA/CA</strong><br>802.11 发送者：</p><ol><li><p>如果信道空闲超过 DIFS 时间，则发送整个帧（不进行载波监测）</p></li><li><p>如果感知到信道繁忙，启动随机退避计时器，信道空闲时计时器递减，计时器归零时立即传输，若未收到 ACK，则增大随机退避间隔；重复步骤 2</p><p>802.11 接收方：</p></li></ol><ul><li>若正确接收帧，在 SIFS 时长后返回 ACK（由于隐藏终端问题，必须发送 ACK）</li></ul><p><strong>避免冲突：</strong><br>想法：发送者使用小的预留数据包“预留”信道用于数据帧</p><ul><li>发送方首先使用 CSMA 向基站发送小的 request-to-send（RTS）数据包<ul><li>RTSs 可能仍相互碰撞</li></ul></li><li>基站响应 RTS 数据包广播 clear-to-send CTS</li><li>CTS 被所有节点接收<ul><li>发送方传输数据帧</li><li>其它站点延迟传输</li></ul></li></ul><p><img src="2025060284-1.png" alt=""></p><p><strong>802.11 frame: 寻址</strong><br><img src="2025060216.png" alt=""><br>Address1: 接收此帧的无线主机或 AP 的 MAC 地址<br>Address2: 发送此帧的无线主机或 AP 的 MAC 地址<br>Address3: AP 连接的路由器接口的 MAC 地址<br>Address4: 仅在 ad hoc 模式下使用</p><p><img src="2025060252.png" alt=""><br>duration: 保留传输时间（RTS/CTS）的持续时间<br>seq control: 帧序列号（用于可靠数据传输）<br>type：帧类型（RTS, CTS, ACK, 数据）</p><p><img src="2025060263-1.png" alt=""></p><p><strong>802.11：同一子网内的移动性</strong></p><p><img src="2025060280.png" alt=""></p><p><strong>802.11：高级功能</strong><br>速率自适应：</p><ul><li>基站和移动设备根据移动情况动态改变传输速率（物理层调制技术），随着移动变化，信噪比变化<ul><li>当节点远离基站时，信噪比下降，误码率上升</li><li>当误码率过高时，切换到较低传输速率但误码率较低的模式</li></ul></li></ul><p>电源管理：</p><ul><li>node-to-AP：“我将休眠，直到下一个信标帧”<ul><li>接入点知道不要向该节点发送帧</li><li>节点在下一个信标帧之前醒来</li></ul></li><li><em>beacon frame 信标帧</em>：包含等待发送的 AP 到移动设备的帧的移动设备列表<ul><li>如果有待发送的 AP 到移动设备的帧，节点将保持唤醒状态；否则再次进入睡眠状态，直到下一个信标帧</li></ul></li></ul><p><strong>个人区域网络：蓝牙</strong><br><img src="2025060283.png" alt=""><br><img src="2025060291.png" alt=""></p><h3 id="移动网络：4G-和-5G">移动网络：4G 和 5G</h3><p>与有线互联网的相似性：</p><ul><li>边缘/核心的区分，但两者都属于同一运营商</li><li>全球蜂窝网络：一个由网络组成的网络</li><li>广泛使用我们已研究的协议：HTTP、DNS、TCP、UDP、IP、NAT、数据/控制平面分离、SDN、以太网、隧道</li><li>与有线互联网互联</li></ul><p>与有线互联网的不同之处</p><ul><li>不同的无线链路层</li><li>移动性作为一类服务</li><li>用户“身份”（通过 SIM 卡）</li><li>商业模式：用户订阅蜂窝运营商<ul><li>强烈的“家庭网络”概念与在访问网络上的漫游</li><li>全球接入，具有认证基础设施，以及运营商间结算</li></ul></li></ul><h4 id="4G-LTE-架构的要素">4G LTE 架构的要素</h4><p><img src="2025060282.png" alt=""></p><p><em>Mobile device</em></p><ul><li>智能手机、平板电脑、笔记本电脑、物联网、… 配备 4G LTE ratio</li><li>64 位国际移动用户身份识别码（IMSI），存储在 SIM（用户身份模块）卡上</li><li>LTE 术语：用户设备（UE）</li></ul><p><em>Base station</em></p><ul><li>在运营商网络的边缘</li><li>管理无线无线电资源，其覆盖区域内的移动设备（蜂窝）</li><li>与其他元素协调设备认证</li><li>类似于 WiFi 接入点，但<ul><li>在用户移动中发挥积极作用</li><li>与近基站协调以优化无线电使用</li></ul></li><li>LTE 术语：eNode-B</li></ul><p><img src="2025060228.png" alt=""></p><p><em>Home Subscriber Service (HSS)</em></p><ul><li>存储 HSS 的网络是其归属网络的移动设备的信息</li><li>与 MME 在设备认证中协同工作</li></ul><p><em>Service Gateway S-GW PDN Gateway P-GW</em></p><ul><li>位于从移动设备到/从互联网的数据路径上</li><li>P-GW<ul><li>移动蜂窝网络的网关</li><li>看起来像其他互联网网关路由器</li><li>提供 NAT 服务</li></ul></li><li>其它路由器<ul><li>广泛使用隧道技术</li></ul></li></ul><p><em>Mobility Management Entity (MME)</em></p><ul><li>设备认证 (device-to-device, network-to-device) 与 移动归属网络 HSS 协调</li><li>移动设备管理<ul><li>单元间设备切换</li><li>跟踪/寻呼设备位置</li></ul></li><li>从移动设备到 P-GW 的路径（隧道）设置</li></ul><h4 id="LTE">LTE</h4><p><strong>数据平面与控制平面分离</strong><br><img src="2025060208.png" alt=""></p><p><strong>数据平面协议栈：第一跳</strong><br><img src="2025060247.png" alt=""></p><p>LTE 链路层协议：</p><ul><li>分组数据汇聚：头部压缩、加密</li><li>无线链路控制 RLC 协议：分片/重组、可靠数据传输</li><li>媒体访问：请求、使用射频传输时隙 OFDM</li></ul><p><strong>数据平面协议栈：数据包核心</strong><br><img src="2025060243.png" alt=""></p><p>隧道：</p><ul><li>移动数据报使用 GPRS 隧道协议封装，通过 UDP 数据报发送到 S-GW</li><li>S-GW re-tunnels 数据报到 P-GW</li><li>支持移动性：当移动用户移动时，只有隧道端点会改变</li></ul><p><strong>LTE 数据平面：与基站关联</strong><br><img src="2025060280-1.png" alt=""></p><p><strong>LTE 移动设备：休眠模式</strong><br>就像 WiFi、蓝牙一样：LTE 移动网络可能会将无线电置于“睡眠”状态以节省电池：</p><ul><li>浅睡眠：在 100 毫秒的无活动后<ul><li>定期唤醒（100 毫秒）以检查下行传输</li></ul></li><li>深度睡眠：在 5-10 秒的无活动后<ul><li>机在深度睡眠时可能会更换基站——需要重新建立关联</li></ul></li></ul><p>全球蜂窝网络：一个由 IP 网络组成的网络<br><img src="2025060261.png" alt=""></p><p>所有 IP：</p><ul><li>运营商相互连接，并在交换点连接公共互联网</li><li>传统 2G、3G：并非所有 IP，其他方式处理</li></ul><h4 id="迈向-5G">迈向 5G</h4><p><img src="2025060226.png" alt=""></p><p><img src="2025060246-1.png" alt=""></p><h2 id="移动性">移动性</h2><h3 id="移动管理：原理">移动管理：原理</h3><p><img src="2025060228-1.png" alt=""></p><p>挑战：<br>如果一个设备从一个网络移动到另一个网络</p><ul><li>“网络”将如何知道将数据包转发到新的网络</li></ul><p>方法：<br><img src="2025060210.png" alt=""></p><p>让终端来处理：</p><ul><li>间接路由：通信从对应节点到移动节点通过家庭网络，然后转发到远程移动节点</li><li>直接路由：对应节点获取移动节点的国外地址，直接发送到移动节点</li></ul><p><img src="2025060209.png" alt=""></p><p>拥有“home”的重要性：</p><ul><li>你信息的明确来源</li><li>人们可以知道你所在的地方</li></ul><p><strong>家庭网络，访问网络：4G/5G</strong><br>家庭网络：</p><ul><li>向蜂窝运营商（如 Verizon、Orange）购买的服务计划</li><li>家庭网络 HSS 存储身份和服务信息</li></ul><p>访问网络：</p><ul><li>除了你的家庭网络之外的任何网络</li><li>与其他网络的服务协议：提供对访客移动的访问</li></ul><p><strong>家庭网络，访问网络：ISP/WiFi</strong><br>没有全球“家”的概念</p><ul><li>来自 ISP 的凭证（用户名、密码）存储在设备上或与用户一起</li><li>互联网服务提供商可能由全国性、国际性的业务范围</li><li>不同的网络：不同的认证凭证</li></ul><p>注册：家需要知道你在哪里<br><img src="2025060283-1.png" alt=""></p><p><strong>移动性——间接路由</strong><br><img src="2025060291-1.png" alt=""></p><p>评价：<br>三角形路由：当通信方和移动终端在同一网络时效率低下<br>移动终端在访问网络间移动：对通信方完全透明</p><ul><li>在新访问网络中注册</li><li>新访问网络向归属 HSS 注册</li><li>数据报继续从归属网络转发到在新网络中的移动终端</li><li>通信方和移动终端之间的进行中的连接（如 TCP）可以保持</li></ul><p><strong>移动性——直接路由</strong><br><img src="2025060262.png" alt=""></p><p>评价：</p><ul><li>克服三角形路由低效问题</li><li>对通信方不透明：通信方必须从归属代理获取转交地址</li><li>如果移动设备更换访问网络<ul><li>可以处理，但会增加额外复杂性</li></ul></li></ul><h3 id="移动管理：实践">移动管理：实践</h3><p>4G 网络中的移动性：主要移动任务<br><img src="2025060267-2.png" alt=""></p><p><strong>配置 LTE 控制平面元素</strong> （上图 2）</p><ul><li>移动设备通过基站控制平面信道与本地 MME 通信</li><li>MME 使用移动的 IMSI 信息联系移动设备的归属 HSS<ul><li>获取认证、加密、网络服务信息</li><li>归属 HSS 知道移动设备现在驻留在访问网络</li></ul></li><li>基站、移动设备选择 BS-mobile 数据平面无线信道参数</li></ul><p><strong>给移动设备配置数据平面隧道</strong><br><img src="2025060215.png" alt=""></p><ul><li>S-GW to BS tunnel：当移动设备切换基站时，只需更改隧道端点的 IP 地址</li><li>S-GW to home P-GW tunnel：间接路由的实现</li><li>tunneling via GTP (GPRS tunneling protocal)：移动设备的数据报文使用 GTP 封装在 UDP 内，再封装到数据报中</li></ul><p><strong>同一蜂窝网络中基站之间的切换</strong><br><img src="2025060271-2.png" alt=""><br><img src="2025060202-1.png" alt=""></p><p><strong>Mobile IP</strong><br>移动 IP 架构</p><ul><li>使用隧道间接路由到节点（通过家庭网络）</li><li>移动 IP 家庭代理：结合 4G HSS 和家庭 P-GW 的角色</li><li>移动 IP 外国代理：结合 4G MME 和 S-GW 的角色</li><li>在访问网络中代理发现的协议，通过 ICMP 扩展在家庭网络中注册访问位置</li></ul><p>无线、移动性对高层协议的影响：<br><img src="2025060267-3.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-06链路层和局域网</title>
    <link href="/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <url>/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>总结<br>数据链路层服务背后的原理：</p><ul><li>检错、纠错</li><li>共享广播式信道：多路访问</li><li>链路编址</li></ul><p>各种链路层技术的实例和实现</p><ul><li>Ethernet</li><li>交换式 LANs, VLANs</li><li>虚拟成链路层的网络：MPLS</li></ul><p>综合：一个 web 页面请求的日常场景</p><h2 id="引入">引入</h2><p>术语：</p><ul><li>nodes: 主机、路由器</li><li>links: 沿着通信路径，连接相邻节点的通信信道<ul><li>有线、无线</li><li>局域网 LANs</li></ul></li><li>第二层协议数据单元 “帧 frame”，封装数据报</li></ul><p><em>数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点</em></p><p>上下文：</p><ul><li>数据报（分组）在不同链路上以不同的链路协议传输</li><li>不同的链路层协议提供不同的服务</li></ul><p>类比：</p><p><img src="2025060374.png" alt=""></p><p><strong>链路层：服务</strong></p><p>成帧，链路接入：</p><ul><li>将数据报封装在帧中，加上帧头、帧尾部</li><li>如果采用的式共享性介质，信道接入获得信道访问权</li><li>在帧头部使用“<em>MAC</em>”地址来标识源和目的（不同于 IP 地址）</li></ul><p>在相邻两个节点完成可靠数据传输</p><ul><li>在低错误率的链路上（光纤和双绞线电缆）很少使用</li><li>在无线链路经常使用：出错率高</li></ul><p>流量控制：</p><ul><li>使得相邻的发送和接收方节点的速度匹配</li></ul><p>错误检测：</p><ul><li>差错由信号衰减和噪声引起</li><li>接收方检测处的错误：通知发送方进行重传或丢弃帧</li></ul><p>差错纠正：</p><ul><li>接收端检查和纠正 bit 错误，不通过重传来纠正错误</li></ul><p>半双工和全双工：</p><ul><li>半双工：链路可以双向传输，但一次只有一个方向</li></ul><p><em>链路层实现的位置</em></p><ul><li>在每个主机上</li><li>链路层功能实现在 NIC 或芯片组</li><li>接到主机的系统总线上</li><li>硬件、软件和固件的综合体</li></ul><h2 id="差错检测和纠正">差错检测和纠正</h2><p><strong>错误检测</strong><br>EDC=差错检测和纠正位（冗余位）<br>D=由差错检测保护的数据，可以包含头部字段<br>错误检测不是 100%可靠的</p><ul><li>协议会漏检一些错误，但是很少</li><li>更长的 EDC 字段可以得到更好的检测和纠正效果</li></ul><p><img src="2025060364.png" alt=""></p><p>奇偶校验：<br><img src="2025060337.png" alt=""></p><p><strong>Internet 校验和</strong><br>目标：检测在传输报文段时的错误（如位翻转）</p><p>发送方：</p><ul><li>将报文段堪称 16bit 整数</li><li>报文段的检验和：和 1’ 的补码和</li><li>发送方将 checksum 的值放在 ‘UDP 校验和’ 字段</li></ul><p>接收方：</p><ul><li>计算接收到的报文段的校验和</li><li>检查是否与携带的校验和字段值一致<ul><li>不一致：检出错误</li><li>一致：没有检出错误，但可能还是由错误</li></ul></li><li>ps. 更简单的检查：全部加起来看是不是全 1</li></ul><p>检验和：<em>循环冗余校验 CRC</em><br><img src="2025060361.png" alt=""></p><p>例：<br><img src="2025060336.png" alt=""></p><h2 id="多点访问协议">多点访问协议</h2><p>两种类型的链路（一个子网内部链路连接形式）：</p><ul><li>点对点<ul><li>以太网交换机和主机之间的点对点链路</li><li>拨号访问的 PPP</li></ul></li><li>广播（共享线路或媒体）<ul><li>传统以太网</li><li>HDC 上行链路</li><li>802.11 无线局域网</li></ul></li></ul><p>单个共享的广播型链路<br>2 个或更多站点同时传送：冲突</p><ul><li>多个节点在同一个时刻发送，则会收到 2 个或多个信号叠加</li></ul><p>多路访问协议（multiple access protocol <strong>MAC</strong>）</p><ul><li>分布式算法 - 决定节点如何使用共享信道，即决定节点什么时候可以发送</li><li>关于共享控制的信道必须借助信道本身传输<ul><li>没有带外的信道，各节点使用其协调信道使用</li></ul></li></ul><h3 id="理想的多路访问协议">理想的多路访问协议</h3><p>给定：Rbps 的广播信号</p><p>必要条件</p><ul><li>当一个节点要发送时，可以 R 速率发送</li><li>当 M 个节点要发送，每个可以以 R/M 的平均速率发送</li><li>完全分布的<ul><li>没有特殊节点协调发送</li><li>没有时钟和时隙的同步</li></ul></li><li>简单</li></ul><p><strong>MAC 协议：分类</strong></p><ul><li>信道划分<ul><li>把信道划分成小片（时间、频率、编码）</li><li>分配片给每个节点专用</li></ul></li><li>随机访问<ul><li>信道不划分，允许冲突</li><li>冲突后恢复</li></ul></li><li>依次轮流<ul><li>节点依次轮流</li><li>但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul><h3 id="信道划分-MAC-协议">信道划分 MAC 协议</h3><p><strong>TDMA</strong></p><ul><li>轮流使用信道，信道的实践分为周期</li><li>每个站点使用每周期中固定的时隙 (长度=帧传输时间) 传输帧</li><li>如果站点无帧传输，时隙空闲-&gt;浪费</li></ul><p><strong>FDMA</strong></p><ul><li>信道的有效频率范围被分成一个个小的频段</li><li>每个站点被分配一个固定的频段</li><li>分配给站点的频段如果没有被使用，则空闲</li></ul><p><strong>码分多路访问 CDMA</strong></p><ul><li>所有站点在整个频段上同时进行传输, 采用编码原理加以区分</li><li>完全无冲突</li><li>假定: 信号同步很好, 线性叠加</li></ul><h3 id="随机存取协议">随机存取协议</h3><p>当节点有帧要发送时</p><ul><li>以信道带宽的全部 R bps 发送</li><li>没有节点间的预先协调</li></ul><p>两个或更多节点同时传输，会发生 ➜ 冲突 “collision”<br>随机存取协议规定:</p><ul><li>如何检测冲突</li><li>如何从冲突中恢复（如：通过稍后的重传）</li></ul><p>随机 MAC 协议:</p><ul><li>时隙 ALOHA</li><li>ALOHA</li><li>CSMA, CSMA/CD, CSMA/CA</li></ul><h4 id="时隙-ALOHA">时隙 ALOHA</h4><p>假设：</p><ul><li>所有帧是等长的</li><li>时间被划分为相等的时隙，每个时隙可发送一帧</li><li>节点只在时隙开始时发送帧</li><li>节点在时钟上是同步的</li><li>如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突</li></ul><p>运行：</p><ul><li>当节点获取新的帧，在下一个时隙传输</li><li>传输时没有检测到冲突，成功<ul><li>节点能够在下一时隙发送新帧</li></ul></li><li>检测时如果检测到冲突，失败<ul><li>节点在每一个随后的时隙以概率 p 重传帧直到成功</li></ul></li></ul><p><img src="2025060343.png" alt=""></p><p>效率：当有很多节点，每个节点有很多帧发送时，x%的时隙是成功传输帧的时隙</p><ul><li>假设 N 个节点，每个节点都有很多帧要发送， 在每个时隙中的传输概率是 p</li><li>一个节点成功传输概率是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">p(1-p)^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li><li>任何一个节点的成功概率是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>p</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo stretchy="false">)</mo><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">Np(1-p)^{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">Np</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0913em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p>-&gt;最好情况：信道利用率 37%</p><h4 id="CSMA（载波监听多路访问）">CSMA（载波监听多路访问）</h4><p>CSMA：在传输前先侦听信道</p><ul><li>如果侦听到信道空闲，传送整个帧</li><li>如果侦听到信道忙，推迟传送</li></ul><p>CSMA/CD：CSMA with collision detection</p><ul><li>没有传完一个帧就可以在短时间内检测到冲突</li><li>冲突发生时则传输终止，减少对信道的浪费</li><li>冲突检测 CD 技术，有线局域网中容易实现<ul><li>检测信号强度，比较传输与接收到的信号是否相同</li><li>通过周期的过零点检测</li></ul></li></ul><p><strong>CSMA：冲突</strong><br>冲突仍然可能发生</p><ul><li>由传播延迟造成：两个节点可能侦听不到正在进行的传输<br>冲突：整个冲突帧的传输时间都被浪费了，是无效的传输 (红黄区域)</li><li>注意： 传播延迟（距离）决定了冲突的概率</li></ul><p><strong>CSMA/CD</strong></p><p>以太网 CSMA/CD 算法</p><ol><li>Ethernet 获取数据报，创建帧</li><li>发送前：侦听信道 CS<ol><li>闲：开始传送帧</li><li>忙：一直等到闲再发送</li></ol></li><li>发送过程中，冲突检测 CD<ol><li>没有冲突: 成功</li><li>检测到冲突: 放弃, 之后尝试重发</li></ol></li><li>发送方适配器检测到冲突，除放弃外，还将发送一个 jam 信号，所有听到冲突的适配器也是如此<ol><li>强化冲突：让所有站点都知道冲突</li></ol></li><li>如果放弃，适配器进入指数退避状态<ol><li>在第 m 次失败后，适配器随机选择一个{0,1,2… 2^m-1}中 k，等待 k * 512 位时，转到步骤 2（二进制指数退避算法 exponential backoff）</li></ol></li></ol><p><strong>无线局域网中的 MAC</strong></p><p>802.11: CSMA – 发送前侦听信道</p><ul><li>不会和其它节点正在进行的传输发生冲突</li><li>没有冲突检测<ul><li>无法检测冲突：自身信号远远大于其他节点信号</li></ul></li><li>目标：避免冲突<ul><li>无法 CD，一旦发送一股脑全部发送完毕，不 CD</li><li>为了避免无 CD 带来的信道利用率低的问题，事前进行冲突避免</li></ul></li></ul><p><img src="2025060345.png" alt=""></p><p><em>冲突避免</em><br>思想：允许发送方“预约”信道，而不是随机访问该信道: 避免长数据帧的冲突（可选项）<br>发送方首先使用 CSMA 向 BS 发送一个小的 RTS 分组</p><ul><li>RTS 可能会冲突（但是由于比较短，浪费信道较少）</li></ul><p>BS 广播 clear-to-send CTS，作为 RTS 的响应</p><p>CTS 能够被所有涉及到的节点听到</p><ul><li>发送方发送数据帧</li><li>其它节点抑制发送</li></ul><p>——采用小的预约分组，可以<em>完全避免数据帧的冲突</em><br><img src="2025060389.png" alt=""></p><h3 id="轮流-Taking-Turns-MAC-协议">轮流 Taking Turns MAC 协议</h3><p>信道划分 MAC 协议:</p><ul><li>共享信道在高负载时是有效和公平的</li><li>在低负载时效率低下<ul><li>只能等到自己的时隙开始发送或者利用 1/N 的信道频率发送</li><li>当只有一个节点有帧传时，也只能够得到 1/N 个带宽分配</li></ul></li></ul><p>随机访问 MAC 协议</p><ul><li>在低负载时效率高：单个节点可以完全利用信道全部带宽</li><li>高负载时：冲突开销较大，效率极低，时间很多浪费在冲突中</li></ul><p>轮流协议</p><ul><li>有 2 者的优点!</li></ul><p><strong>轮询 polling</strong></p><ul><li>主节点邀请从节点依次传送</li><li>从节点一般比较“dumb”</li><li>缺点:<ul><li>轮询开销：轮询本身消耗信道带宽</li><li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送</li><li>单点故障：主节点失效时造成整个系统无法工作</li></ul></li></ul><p><strong>令牌传输</strong></p><ul><li>控制令牌 ( token) 循环从一个节点到下一个节点传递</li><li>令牌报文：特殊的帧</li><li>缺点:<ul><li>令牌开销：本身消耗带宽</li><li>延迟：只有等到抓住令牌，才可传输</li><li>单点故障 (token)：  令牌丢失系统级故障，整个系统无法传输</li><li>复杂机制重新生成令牌</li></ul></li></ul><h3 id="线缆接入网络">线缆接入网络</h3><p><img src="2025060313.png" alt=""><br><img src="2025060312.png" alt=""></p><h2 id="LANs">LANs</h2><h3 id="addressing-ARP">addressing, ARP</h3><p><strong>MAC 地址</strong></p><p>32bitIP 地址:</p><ul><li>网络层地址</li><li>前 n-1 跳：用于使数据报到达目的 IP 子网</li><li>最后一跳：到达子网中的目标节点</li></ul><p>LAN（MAC/物理/以太网）地址:</p><ul><li>用于使帧从一个网卡传递到与其物理连接的另一个网卡 (在同一个物理网络中)</li><li>48bit MAC 地址固化在适配器的 ROM，有时也可以通过软件设定</li><li>理论上全球任何 2 个网卡的 MAC 地址都不相同</li></ul><p>MAC 地址由 IEEE 管理和分配<br>制造商购入 MAC 地址空间（保证唯一性）<br>类比:</p><ul><li>MAC 地址：社会安全号</li><li>IP 地址：通讯地址</li></ul><p><em>MAC 平面地址 ➜ 支持移动</em></p><ul><li>可以将网卡到接到其它网络</li></ul><p><em>IP 地址有层次-不能移动</em></p><ul><li>依赖于节点连接的 IP 子网，与子网的网络号相同（ 有与其相连的子网相同的网络前缀）</li></ul><p><strong>ARP：Address Resolution Protocol</strong><br>已知 B 的 IP 地址，如何确定 B 的 MAC 地址？</p><ul><li>在 LAN 的每个 IP 节点都有一个 ARP 表</li><li>ARP 表：包括一些 LAN 节点 IP/MAC 地址的映射，&lt; IP address; MAC address; TTL&gt;<ul><li>TTL 时间是指地址映射失效的时间（典型是 20min）</li></ul></li></ul><p><em>ARP protocol in action</em><br>例：A 要发送帧给 B（B 的 IP 地址已知），但 B 的 MAC 地址不在 A 的 ARP 表中：</p><ol><li>A 广播包含 B 的 IP 地址的 ARP 查询包<ol><li>Dest MAC address = FF-FF-FF-FF-FF-FF</li><li>LAN 上的所有节点都会收到该查询包</li></ol></li><li>B 接收到 ARP 包，回复 A 自己的 MAC 地址<ol><li>帧发送给 A</li><li>用 A 的 MAC 地址（单播）</li></ol></li><li>A 在自己的 ARP 表中，缓存 IP-to-MAC 地址映射关系 ，直到信息超时<ol><li>软状态: 靠定期刷新维持的系统状态</li><li>定期刷新周期之间维护的状态信息可能和原有系统不一致</li></ol></li></ol><p>ARP 是即插即用的</p><ul><li>节点自己创建 ARP 的表项</li><li>无需网络管理员的干预</li></ul><p><em>路由到其它 LAN</em><br>Walkthrough : 发送数据报：由 A 通过 R 到 B， 假设 A 知道 B 的 IP 地址</p><p><img src="2025060316.png" alt=""></p><p>A 创建数据报，源 IP 地址：A；目标 IP 地址：B<br>A 创建一个链路层的帧，目标 MAC 地址是 R，该帧包含 A 到 B 的 IP 数据报</p><p><img src="2025060390.png" alt=""></p><p>R 转发数据报，数据报源 IP 地址为 A，目标 IP 地址为 B<br>R 创建一个链路层的帧，目标 MAC 地址为 B，帧中包含 A 到 B 的 IP 数据报</p><p><img src="2025060373.png" alt=""></p><h3 id="以太网-Ethernet">以太网 Ethernet</h3><p>物理拓扑<br><img src="2025060317.png" alt=""></p><p><strong>以太帧结构</strong><br><img src="2025060350.png" alt=""></p><p>前导码:</p><ul><li>7B 10101010 + 1B 10101011</li><li>用来同步接收方和发送方的时钟速率<ul><li>使得接收方将自己的时钟调到发送端的时钟</li><li>从而可以按照发送端的时钟来接收所发送的帧</li></ul></li></ul><p>地址：6 字节源 MAC 地址，目标 MAC 地址</p><ul><li>如：帧目标地址=本站 MAC 地址，或是广播地址， 接收，递交帧中的数据到网络层</li><li>否则，适配器忽略该帧</li></ul><p>类型：指出高层协 (大多情况下是 IP，但也支持其它网络层协议 Novell IPX 和 AppleTalk)<br>CRC：在接收方校验</p><ul><li>如果没有通过校验，丢弃错误帧</li></ul><p><strong>以太网：无连接、不可靠的服务</strong><br>无连接：帧传输前，发送方和接收方之间没有握手<br>不可靠：接收方适配器不发送 ACKs 或 NAKs 给发送方</p><ul><li>递交给网络层的数据报流可能有 gap</li><li>如上层使用像传输层 TCP 协议这样的 rdt，gap 会被补上 ( 源主机，TCP 实体)</li><li>否则，应用层就会看到 gap</li></ul><p>以太网的 MAC 协议：采用二进制退避的 <em>CSMA/CD</em> 介质访问控制形式</p><h3 id="Ethernet-switch-交换机">Ethernet switch 交换机</h3><p>交换机是链路层设备：扮演主要角色</p><ul><li>对帧进行存储和转发</li><li>对于到来的帧，检查帧头，根据目标 MAC 地址进行选择性转发</li><li>当帧需要向某个（些）网段进行转发，需要使用 CSMA/CD 进行接入控制</li><li>通常一个交换机端口一个独立网段</li></ul><p><em>透明</em>：主机对交换机的存在可以不关心</p><ul><li>通过交换机相联的各节点好像这些站点是直接相联的一样</li><li>有 MAC 地址；无 IP 地址</li></ul><p><em>即插即用，自学习</em>：</p><ul><li>交换机无需配置</li></ul><p><strong>多路同时传输</strong></p><ul><li>主机有一个专用和直接到交换机的连接</li><li>交换机缓存到来的帧</li><li>对每个帧进入的链路使用以太网协议，没有碰撞；全双工<ul><li>每条链路都是一个独立的碰撞域</li><li>MAC 协议在其中的作用弱化了</li></ul></li><li>交换：A-to-A’ 和 B-to-B’ 可以同时传输，没有碰撞</li></ul><p><strong>交换机转发表</strong><br><img src="2025060300.png" alt=""></p><p><strong>自学习</strong><br>交换机通过学习得到哪些主机（mac 地址）可以通过哪些端口到达</p><ul><li>当接收到帧，交换机学习到发送站点所在的端口（网段）</li><li>记录发送方 MAC 地址/ 进入端口映射关系， 在交换表中</li></ul><p><strong>过滤/转发</strong><br>当交换机收到一个帧:</p><ol><li>记录进入链路，发送主机的 MAC 地址</li><li>使用目标 MAC 地址对交换表进行索引</li></ol><p><img src="2025060392.png" alt=""></p><p>帧的目标： A’, 不知道其位置在哪： 泛洪<br>知道目标 A 对应的链路 ： 选择性发送到那个端口</p><p><strong>交换机级联</strong><br>交换机可被级联到一起<br>Q: A to G 的发送 – 交换机 S1 如何知道经过从 S4 和 S3 最终达到 F?</p><ul><li>A: 自学习! (和在一个交换机联接所有站点一样!)</li></ul><p><strong>交换机 vs. 路由器</strong><br>都是存储转发设备，但层次不同</p><ul><li>交换机：链路层设备（检查链路层头部）</li><li>路由器：网络层设备（检查网络层的头部）</li></ul><p>都有转发表：</p><ul><li>交换机：维护交换表，按照 MAC 地址转发<ul><li>执行过滤、自学习和生成树算法</li><li>即插即用；二层设备，速率高</li><li>执行生成树算法，限制广播帧的转发</li><li>ARP 表项随着站点数量增多而增多</li></ul></li><li>路由器：维护路由表，执行路由算法<ul><li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li><li>对广播分组做限制</li><li>不是即插即用的，配置网络地址（子网前缀）</li><li>三层设备，速率低</li></ul></li></ul><h3 id="VLANs">VLANs</h3><p>考虑场景：<br>CS 用户搬到 EE 大楼办公室 ，但是希望连接到 CS 的交换机?</p><ul><li>接到多个交换机上<ul><li>麻烦和浪费：96 端口 /10 个有用</li></ul></li><li>如果都接到一个交换机上 ，在一个广播域<ul><li>所有的层 2 广播流量 (ARP, DHCP, 不知道 MAC 地址对应端口的帧 ) 都必须穿过整个 LAN</li><li>安全性/私密性的问题</li></ul></li></ul><p><strong>Port-based VLANs</strong><br><em>Virtual Local Area Network (VLAN)</em>：带有 VLAN 功能的交换机（们）可以被配置成：一个物理 LAN 基础设施，虚拟成多个 LANs</p><p>基于端口的 VLAN：交换机端口</p><p>成组（通过交换机管理软件），以至于单个的交换机可以分成若干虚拟 LANs；就像多个虚拟的交换机</p><ul><li>流量隔离：从/到 1-8 端口的流量只会涉及 1-8<ul><li>也可以基于 MAC 地址进行 VLAN 定义</li></ul></li><li>动态成员：成员可以在 VLANs 之间动态分配</li><li>在 VLANs 间转发：通过路由器进行转发 (就像他们通过各自的交换机相联一样)<ul><li>实际操作中，设备生产商可以提供： 交换机和路由器的单一设备</li></ul></li></ul><p><img src="2025060353.png" alt=""></p><p><strong>VLANs 互联多个交换机</strong></p><ul><li><p>如果有多个交换机，希望它们相连并且共享 VLANs 信息</p></li><li><p>方法 1：各交换机每个 VLAN 一个端口和另外交换机相应 VLAN 端口相连-&gt;扩展性问题</p></li><li><p>trunk port 干线端口: 多个交换机共享定义的 VLAN，在它们之间传输帧 - 帧在不同交换机上的一个 VLAN 上转发，不能够再使用 vanilla 802.1 帧 (必须要携带 VLAN ID 信息) - 802.1q 协议增加/移除附加的头部字段，用于在 trunk 端口上进行帧的转发</p><p>802.1Q VLAN 帧格式</p></li></ul><p><img src="2025060303.png" alt=""></p><h2 id="链路虚拟化：MPLS">链路虚拟化：MPLS</h2><p><strong>Multiprotocol label switching MPLS</strong></p><p>目的：使用固定长度的标签 label 进行高速率 IP 转发（而不是使用 IP address，采用最长前缀匹配）</p><ul><li>一开始采用固定长度 ID 进行查表</li><li>借鉴了虚电路 VC 的思想</li><li>但是 IP 数据报仍然保留 IP 地址</li></ul><p>在帧和其封装的分组之间加入一个垫层，标签交换使能的路由器使用垫层信息进行分组转发，不解析分组目标地址<br><img src="2025060344.png" alt=""></p><p><em>具有 MPLS 能力的路由器</em></p><ul><li>a.k.a. 标签交换路由器</li><li>基于标签的值进行分组的转发 (而非检查 IP 地址)<ul><li>MPLS 转发表和 IP 转发表相互独立</li></ul></li><li>弹性: MPLS 转发决策可以和 IP 不同<ul><li>采用源地址和目标地址来路由到达同一个目标的流，不同路径（支持流量工程）</li><li>如果链路失效，能够快速重新路由: 预先计算好的备份链路 (对于 VoIP 有效)</li></ul></li></ul><p><em>MPLS vs. IP 路径</em><br><img src="2025060356.png" alt=""></p><p>MPLS 转发表<br><img src="2025060375.png" alt=""></p><h2 id="数据中心网络">数据中心网络</h2><p>负载均衡器：应用层路由</p><ul><li>接受外部的客户端请求</li><li>将请求导入到数据中心内部</li><li>返回结果给外部客户端 (对于客户端隐藏数据中心的内部结构)</li></ul><p>在交换机之间，机器阵列之间有丰富的互连措施:</p><ul><li>在阵列之间增加吞吐 (多个可能的路由路径)</li><li>通过冗余度增加可靠性</li></ul><h2 id="a-day-in-the-life-of-web-request">a day in the life of web request</h2><p>Top-down 的协议栈旅程结束了</p><ul><li>应用层、运输层、网络层和链路层</li></ul><p>以一个 web 页面请求的例子: 综述</p><ul><li>目标: 标示、回顾和理解涉及到的协议（所有层次 ），以一个看似简单的场景: 请求 www 页面</li><li>场景：学生在校园启动一台笔记本电脑：<a href="http://xn--www-kx3ei6au67d7ynk03d.google.com">请求和接受www.google.com</a></li></ul><p><strong>连接到互联网</strong></p><ul><li>笔记本需要一个 IP 地址，第一跳路由器的 IP 地址，DNS 的地址：采用 DHCP</li><li>DHCP 请求被封装在 UDP 中，封装在 IP 中，封装在 802.3 以太网帧中</li><li>以太网的帧在 LAN 上广播 (dest: FFFFFFFFFFFF), 被运行中的 DHCP 服务器接收到</li><li>以太网帧中解封装 IP 分组， 解封装 UDP，解封装 DHCP</li><li>DHCP 服务器生成 DHCP ACK 包括客户端 IP 地址，第一跳路由器 IP 地址和 DNS 域名服务器地址</li><li>在 DHCP 服务器封装，帧通过 LAN 转发（交换机学习）在客户端解封装</li><li>客户端接收 DHCP ACK 应答</li></ul><p>-&gt; 客户端有了 IP 地址，知道了 DNS 域名服务器的名字和 IP 地址第一跳路由器的 IP 地址</p><p><strong>ARP (DNS 之前，HTTP 之前)</strong></p><ul><li>在发送 HTTP request 请求之前，需要知道www.google.com的IP地址: DNS</li><li>DNS 查询被创建，封装在 UDP 段中 ，封装在 IP 数据报中，封装在以太网的帧中. 将帧传递给路由器 ，但是需要知道路由器的接口： MAC 地址：ARP</li><li>ARP 查询广播，被路由器接收， 路由器用 ARP 应答，给出其 IP 地址某个端口的 MAC 地址</li><li>客户端现在知道第一跳路由器 MAC 地址，所以可以发送 DNS 查询帧了</li></ul><p><strong>使用 DNS</strong></p><ul><li>包含 DNS 查询的 IP 数据报通过 LAN 交换机转发，从客户端到第一跳服务器</li><li>IP 数据报被转发，从校园到达 comcast 网络，路由（路由表被 RIP，OSPF，IS-IS 和/或 BGP 协议创建）到 DNS 服务器</li><li>被 DNS 服务器解封装</li><li>DNS 服务器回复给客户端：www.google.com的IP地址</li></ul><p><strong>TCP 连接携带 HTTP 报文</strong></p><ul><li>为了发送 HTTP 请求，客户端打开到达 web 服务器的 TCP socket</li><li>TCP SYN 段 (3 次握手的第 1 次握手) 域间路由到 web 服务器</li><li>web 服务器用 TCP SYNACK 应答 (3 次握手的第 2 次握手)</li><li>TCP 连接建立了</li></ul><p><strong>HTTP 请求和应答</strong></p><ul><li>HTTP 请求发送到 TCP socket 中</li><li>IP 数据报包含 HTTP 请求，<a href="http://xn--www-7j2el56g21r8kpws2a.google.com">最终路由到www.google.com</a></li><li>web 服务器用 HTTP 应答回应 ( 包括请求的页面)</li><li>IP 数据报包含 HTTP 应答最后被路由到客户端</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-05网络层：控制平面</title>
    <link href="/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"/>
    <url>/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="引入">引入</h2><p><em>网络层功能：</em></p><ul><li>转发: 将分组从路由器的一个输入端口移到合适的输出端口——数据平面</li><li>路由: 确定分组从源到目标的路径——控制平面</li></ul><p>2 种构建网络控制平面功能的方法:</p><ul><li>每个路由器控制功能实现（传统）</li><li>逻辑上集中的控制功能实现 (software defined networking)</li></ul><p>SDN 方式：逻辑上集中的控制平面</p><p><img src="2025060402-1.png" alt=""></p><h2 id="路由协议">路由协议</h2><p>路由:按照某种指标 (传输延迟, 所经过的站点数目等) 找到一条从源节点到目标节点的较好路径</p><p><em>网络到网络</em>的路由= 路由器-路由器之间路由</p><ul><li>网络对应的路由器到其他网络对应的路由器的路由</li><li>在一个网络中：<em>路由器-主机</em>之间的通信，链路层解决</li><li>到了这个路由器就是到了这个网络</li></ul><p>图抽象：边和路径的代价<br><img src="2025060463.png" alt=""></p><p><strong>Dijkstra’s link-state routing algorithm</strong><br><img src="2025060408.png" alt=""><br><img src="2025060412.png" alt=""></p><p>距离矢量路由选择 (distance vector routing)</p><p>Bellman-Ford BF<br><img src="2025060433.png" alt=""><br><img src="2025060404.png" alt=""><br><img src="2025060496.png" alt=""></p><h2 id="Intra-ISP-routing-OSPF">Intra-ISP routing: OSPF</h2><p><em>实现路由可扩展性</em><br><img src="2025060591.png" alt=""></p><p>互联网的可扩展路由方法：</p><ul><li>将路由器聚合为称为“自治系统”（AS）（也称为“域”）的区域</li></ul><p>AS 内部（又名“域内”）：同一 AS 内路由器之间的路由（“网络”）</p><ul><li>AS 内所有路由器必须运行<em>相同的域内协议</em></li><li>不同的 AS 内的路由器可以运行不同的域内路由协议</li><li>网关路由：位于其自身 AS 的边缘，具有到其它 AS 路由器的链路</li></ul><p>AS 间（又名“域间”）：AS 之间的路由</p><ul><li>网关执行域间路由（以及域内路由）</li></ul><p>互联 ASes<br><img src="2025060593.png" alt=""></p><p>跨 AS 路由：在域内转发中扮演的角色<br><img src="2025060501.png" alt=""></p><p><strong>Open Shortest Path First</strong></p><ul><li>“open”：标准可公开获得</li><li>classic link-state：<ul><li>LS 分组在网络中（一个 AS 内部）分发</li><li>全局网络拓扑、代价在每一个节点中都保持</li><li>每个路由器拥有完整的拓扑结构，使用 Dijkstra 算法计算转发表</li></ul></li><li>OSPF 通告信息中携带：<em>每一个邻居路由器一个表项</em></li><li>通告信息会传遍 AS（通过泛洪）<ul><li>在 IP 数据报上直接传送 OSPF 报文（而不是通过 UDP 和 TCP）</li></ul></li></ul><p><strong>层次性的 OSPF 路由</strong></p><p>2 个级别的层次性：本地、骨干</p><ul><li>链路状态通告仅仅在本地区域 Area 范围内进行</li><li>每一个节点拥有本地区域的拓扑信息<ul><li>关于其它区域，知道去它的方向，通过区域边界路由（最短路径）</li></ul></li></ul><p><img src="2025060543.png" alt=""></p><ul><li>区域边界路由器：“汇总（聚集）”到自己区域内网络的距离，向其它区域边界路由器通告</li><li>骨干路由器：仅仅在骨干区域内。运行 OSPF 路由</li><li>边界路由器：连接其它的 ASes</li></ul><h2 id="ISP-之间的路由选择：BGP">ISP 之间的路由选择：BGP</h2><p><strong>Border Gateway Protocol</strong>：自治区域间路由协议“事实上的”标准</p><ul><li>“将互联网各个 AS 粘在一起的胶水”</li></ul><p>允许子网向互联网其它网络通告“我在这里”<br>BGP 提供个每个 AS 以下方法：</p><ul><li>eBGP：从相邻的 ASes 获得<em>子网可达信息</em></li><li>iBGP：将获得的子网可达信息传遍到 AS 内部所有路由器</li><li>根据子网可达信息和策略来决定到达子网的“好”路径</li></ul><p><img src="2025060575.png" alt=""></p><p><strong>BGP 基础</strong><br>BGP 会话：2 个 BGP 路由器 (“peers”) 在一个半永久的 TCP 连接上交换 BGP 报文</p><ul><li>通告向不同目标子网前缀的“路径”（BGP 是一个“路径矢量”协议）</li></ul><p><img src="2025060520.png" alt=""></p><p><em>路径属性 &amp; BGP 路由</em><br>当通告一个子网前缀时，通告包括 BGP 属性</p><ul><li>prefix + attribute = “route”</li></ul><p>2 个重要属性：</p><ul><li>AS-PATH：前缀的通告所经过的 AS 列表<ul><li>检测环路：多路径选择</li><li>在向其它 AS 转发时，需要将自己的 AS 号加到路径上</li></ul></li><li>NEXT-HOP：从当前 AS 到下一跳 AS 有多个链路，在 NEXT-HOP 属性中，告诉对方通过哪个 I 转发</li></ul><p>基于策略的路由：</p><ul><li>当一个网关路由器接收到了一个路由通告，使用输入策略来接收或过滤</li><li>策略也决定了是否向它别的邻居通告收到这个路由信息</li></ul><p><strong>BGP 路径通告</strong><br><img src="2025060588.png" alt=""></p><ol><li>路由器 AS2.2c 从 AS3.3a 接收到的 AS3, X 路由通告 (通过 eBGP)</li><li>基于 AS2 的输入策略，AS2.2c 决定接收 AS3, X 的通告，而且通过 iBGP 向 AS2 的所有路由器进行通告</li><li>基于 AS2 的策略，AS2 路由器 2a 通过 eBGP 向 AS1.1c 路由器通告 <em>AS2, AS3, X</em> 路由信息<ol><li>路径上加上了 AS2 自己作为 AS 序列的一跳</li></ol></li></ol><p><img src="2025060577.png" alt=""></p><p>网关路由器可能获取有关一个子网 X 的多条路径，从多个 eBGP 会话上：</p><ul><li>AS1 网关路由器 1c 从 2a 学习到路径： AS2, AS3, X</li><li>AS1 网关路由器 1c 从 3a 处学习到路径 AS3, X</li><li>基于策略，AS1 路由器 1c 选择了路径：AS3, X，而且通过 iBGP 告诉所有 AS1 内部的路由器</li></ul><p><strong>转发表表项</strong><br><img src="2025060597.png" alt=""></p><p><strong>BGP 路径选择</strong><br>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</p><ul><li>本地偏好值属性: 偏好策略决定</li><li>最短 AS-PATH ：AS 的跳数</li><li>最近的 NEXT-HOP 路由器: 热土豆路由</li><li>附加的判据：使用 BGP 标示</li></ul><p>一个前缀对应着多种路径，采用消除规则直到留下一条路径</p><p><em>热土豆路由</em><br><img src="2025060588-1.png" alt=""></p><p><em>BGP：通过路径通告执行策略</em><br><img src="2025060577-1.png" alt=""></p><p>假设一个 ISP 只想路由流量到/去往它的客户网络 (不想承载其他 ISPs 之间的流量，即不通告：不是去往我的客户，也不是来自我的客户)</p><ul><li><p>A 向 B 和 C 通告路径 Aw</p></li><li><p>B 选择不向 C 通告 BAw：</p><ul><li>B 从 CBAw 的路由上无法获得收益，因为 C, A, w 都不是 B 的客户</li><li>C 从而无法获知 CBAw 路径的存在：每个 ISP 感知到的网络和真实不一致</li></ul></li><li><p>C 可能会通过 CAw (而不是使用 B) 最终路由到 w</p></li><li><p>A, B, C 是提供商网络：</p></li><li><p>X, W, Y 是桩网络（stub networks）或者叫端网络</p></li><li><p>X 是双重接入的，多宿桩网络，接入了 2 个网络</p></li><li><p>策略强制让 X:</p><ul><li>X 不想路由从 B 通过 X 到 C 的分组</li><li>因而 X 就不通告给 B，它实际上可以路由到 C</li></ul></li></ul><p><em>为什么内部网关协议和外部网关协议如此不同?</em></p><p>策略：</p><ul><li>Inter-AS: 管理员需要控制通信路径，谁在使用它的网络进行数据传输</li><li>Intra-AS: 一个管理者，所以无需策略;<ul><li>AS 内部的各子网的主机尽可能地利用资源进行快速路由</li></ul></li></ul><p>规模：</p><ul><li>AS 间路由必须考虑规模问题，以便支持全网的数据转发</li><li>AS 内部路由规模不是一个大的问题<ul><li>如果 AS 太大，可将此 AS 分成小的 AS ；规模可控</li><li>AS 之间只不过多了一个点而已</li><li>或者 AS 内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量</li></ul></li></ul><p>性能：</p><ul><li>Intra-AS: 关注性能</li><li>Inter-AS: 策略可能比性能更重要</li></ul><h2 id="SDN-控制平面">SDN 控制平面</h2><p>传统方式：在每一个路由器中的单独路由器算法元件，在控制平面进行交互</p><p>SDN 方式：一个不同的（通常是远程的）控制器与本地控制代理（CAs） 交互</p><p><img src="2025060516.png" alt=""></p><p>为什么需要一个逻辑上集中的控制平面？</p><ul><li>网络管理更加容易：避免路由器的错误配置，对于通信流的弹性更好</li><li>基于流表的转发（回顾一下 OpenFlow API)，允许“可编程”的路由器<ul><li>集中式“编程”更加容易：集中计算流表然后分发</li><li>传统方式分布式“编程”困难：在每个单独的路由器上分别运行分布式的算法，得到转发表（部署和升级代价低）</li></ul></li><li>控制平面的开放实现（非私有）<ul><li>新的竞争生态</li></ul></li></ul><p><strong>流量工程</strong><br>传统路由比较困难：<br><img src="2025060553.png" alt=""></p><p>Q: 网管如果需要 u 到 z 的流量走 uvwz, x 到 z 的流量走 xwyz，怎么办？</p><ul><li>A: 需要定义链路的代价，流量路由算法以此运算（ IP 路由面向目标，无法操作） (或者需要新的路由算法)!</li></ul><p>Q: 如果网管需要将 u 到 z 的流量分成 2 路：uvwz 和 uxyz ( 负载均衡)，怎么办?（ IP 路由面向目标）</p><ul><li>A: 无法完成 (在原有体系下只有使用新的路由选择算法 ，而在全网部署新的路由算法是个大的事情)</li></ul><p>Q: 如果需要 w 对蓝色的和红色的流量采用不同的路由，怎么办？</p><ul><li>A: 无法操作 (基于目标的转发，采用 LS, DV 路由)</li></ul><p><strong>SDN 特点</strong><br><img src="2025060547.png" alt=""></p><h3 id="Software-defined-networking-SDN">Software defined networking (SDN)</h3><p><em>数据平面交换机</em></p><ul><li>快速，简单，商业化交换设备采用硬件实现通用转发功能</li><li>流表被控制器计算和安装</li><li>基于南向 API（例如 OpenFlow ），SDN 控制器访问基于流的交换机<ul><li>定义了哪些可以被控制哪些不能</li></ul></li><li>也定义了和控制器的协议 (e.g., OpenFlow)</li></ul><p><em>SDN 控制器（网络 OS）</em></p><ul><li>维护网络状态信息</li><li>通过上面的北向 API 和网络控制应用交互</li><li>通过下面的南向 API 和网络交换机交互</li><li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法实现</li></ul><p><em>网络控制应用</em></p><ul><li>控制的大脑： 采用下层提供的服务（SDN 控制器提供的 API)，实现网络功能<ul><li>路由器交换机</li><li>接入控制防火墙</li><li>负载均衡</li><li>其他功能</li></ul></li><li>非绑定：可以被第三方提供 ，与控制器厂商以通常上不同，与分组交换机厂商也可以不同</li></ul><p><img src="2025060527.png" alt=""></p><h3 id="OpenFlow-协议">OpenFlow 协议</h3><ul><li>控制器和 SDN 交换机交互的协议</li><li>采用 TCP 来交换报文</li><li>3 种 OpenFlow 报文类型<ul><li>控制器&gt;交换机</li><li>异步（交换机&gt;控制器 ）</li><li>对称 (misc)</li></ul></li></ul><p><em>控制器-交换机 报文</em>：</p><ul><li>特性：控制器查询交换机特性，交换机应答</li><li>配置：交换机查询/设置交换机的配置参数</li><li>修改状态：增加删除修改 OpenFlow 表中的流表</li><li>packet-out：控制器可以将分组通过特定的端口发出</li><li>分组进入: 将分组（和它的控制） 传给控制器，见来自控制器的 packet-out 报文</li><li>流移除: 在交换机上删除流表项</li><li>端口状态: 通告控制器端口的变化</li></ul><p>幸运的是, 网络管理员不需要直接通过创建/发送流表来编程交换机，而是采用在控制器上的 app 自动运算和配置</p><p><img src="2025060529.png" alt=""></p><ol><li>链路状态路由 app 和 SDN 控制器中流表计算元件交互，计算出新的所需流表</li><li>控制器采用 OpenFlow 在交换机上安装新的需要更新的流表</li></ol><h2 id="ICMP-Internet-Control-Message-Protocol">ICMP: Internet Control Message Protocol</h2><p>由主机、路由器、网关用于传达网络层控制信息</p><ul><li>错误报告：主机不可到达、网络、端口、协议</li><li>Echo 请求和回复（ping）</li></ul><p>ICMP 处在网络层，但是是在 IP 协议的上面</p><ul><li>ICMP 消息由 <em>IP 数据报</em>承载</li></ul><p>ICMP 报文:</p><ul><li>类型</li><li>编码</li><li>加上 IP 数据报的头 8B<ul><li>第一个导致该 ICMP 报文的 IP 数据报</li></ul></li></ul><p><img src="2025060516-1.png" alt=""></p><h2 id="网络管理，配置">网络管理，配置</h2><p>什么是网络管理？</p><p>“网络管理”包括了硬件、软件和人类元素的设置，综合和协调，以便监测，测试，轮询，配置，分析，评价和控制网络和网元资源，用合理的成本满足实时性，运行能和服务质量的要求</p><p><img src="2025060574.png" alt=""></p><h3 id="SNMP-协议">SNMP 协议</h3><p>Simple Network Management Protocol：用于管理和监控网络设备（如路由器、交换机、服务器等）的标准化协议</p><ul><li>应用层协议 基于 UDP</li></ul><p>两种模式：<br><img src="2025060596.png" alt=""></p><p>报文类型：<br><img src="2025060531.png" alt=""></p><p><strong>NETCONF</strong><br>概述</p><ul><li>目标：主动管理/配置全网的设备</li><li>在管理服务器和受管网络设备之间运行<ul><li>操作：获取、设置、修改、激活配置</li><li>在多台设备上执行原子提交操作</li><li>查询运行时数据和统计信息</li><li>订阅来自设备的通知</li></ul></li><li>远程过程调用（RPC）范式<ul><li>NETCONF 协议消息以 XML 编码</li><li>通过安全的可靠传输协议（例如 TLS）交换</li></ul></li></ul><p>初始化、交换、关闭</p><p><img src="2025060512.png" alt=""></p><p><em>YANG</em></p><ul><li>用于指定 NETCONF 网络管理数据结构、语法、语义的数据建模语言<ul><li>内置数据类型，如 SMI</li></ul></li><li>从 YANG 描述中可以生成描述设备、能力的 XML 文档</li><li>可以表达必须由有效 NETCONF 配置满足的数据约束<ul><li>确保 NETCONF 配置满足正确性、一致性约束</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-04网络层：数据平面</title>
    <link href="/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/"/>
    <url>/2025/08/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04%E7%BD%91%E7%BB%9C%E5%B1%82%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="网络层作用">网络层作用</h2><p><strong>网络层服务</strong></p><ul><li>在发送主机和接收主机对之间传送<em>段（segment）</em></li><li>在发送端将段封装到数据报中</li><li>在接收端，将段上交给传输层实体</li><li>网络层协议存在于<em>每一个</em>主机和路由器</li><li>路由器检查每一个经过它的 IP 数据报的头部</li></ul><p><strong>网络层的关键功能</strong></p><ul><li>转发：将分组从路由器的输入接口转发到合适的输出接口</li><li>路由：使用路由算法来决定分组从发送主机到目标接收主机的路径<ul><li>路由选择算法</li><li>路由选择协议</li></ul></li></ul><p>类比：旅行</p><ul><li>转发：通过单个路口的过程</li><li>路由：从源到目的的路由路径规划过程</li></ul><p><strong>数据平面、控制平面</strong></p><p>数据平面</p><ul><li>本地，每个路由器功能</li><li>决定从路由器输入端口到达的分组如何转发到输出端口</li><li>转发功能<ul><li>传统方式：基于目标地址+转发表</li><li>SDN 方式：基于多个字段+流表</li></ul></li></ul><p>控制平面</p><ul><li>网络范围内的逻辑</li><li>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</li><li>2 个控制平面方法:<ul><li>传统的路由算法: 在路由器中被实现</li><li>software-defined networking (SDN): 在远程的服务器中实现</li></ul></li></ul><p><strong>网络服务模型</strong><br>Q：从发送方主机到接收方主机传输数据报的“通道” ，网络提供什么样的服务模型？</p><p>对于单个数据报的服务:</p><ul><li>可靠传送</li><li>延迟保证，如：少于 40ms 的延迟</li></ul><p>对于数据报流的服务:</p><ul><li>保序数据报传送</li><li>保证流的最小带宽</li><li>分组之间的延迟差</li></ul><h2 id="路由器">路由器</h2><p>路由器结构概况</p><ul><li>运行路由选择算法/协议</li><li>从输入到输出链路交换数据报</li></ul><p><img src="2025060323.png" alt=""></p><p><em>输入端口</em><br><img src="2025060462.png" alt=""></p><p><strong>最长前缀匹配</strong><br>当给定目标地址查找转发表时，采用<strong>最长</strong>地址前缀匹配的目标地址表项</p><p>高效查找匹配：</p><ul><li>利用 二进制串 的 树状结构<br><img src="2025060425.png" alt=""></li></ul><p><strong>交换结构</strong></p><ul><li>将分组从输入缓冲区传输到合适的输出端口</li><li>交换速率：分组可以按照该速率从输入传输到输出<ul><li>运行速度经常是输入/输出链路速率的若干倍</li><li>N 个输入端口：交换机构的交换速度是输入线路速度的 N 倍比较理想，才不会成为瓶颈</li></ul></li></ul><p><img src="2025060447.png" alt=""></p><p><em>通过内存交换</em></p><p>第一代路由器:</p><ul><li>在 CPU 直接控制下的交换，采用传统的计算机</li><li>分组被拷贝到系统内存，CPU 从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li><li>转发速率被内存的带宽限制 (数据报通过 BUS 两遍)</li><li>一次只能转发一个分组</li></ul><p><em>通过总线交换</em></p><ul><li>数据报通过共享总线，从输入端口转发到输出端口</li><li>总线竞争: 交换速度受限于总线带宽</li><li>1 次处理一个分组</li></ul><p><em>通过 Mesh 交换</em></p><ul><li>同时并发转发多个分组，克服总线带宽限制</li><li>Banyan（榕树）网络，crossbar (纵横) 和其它的互联网络被开发，将多个处理器连接成多处理器</li><li>当分组从端口 A 到达，转给端口 Y；控制器短接相应的两个总线</li><li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li></ul><p><strong>输出端口</strong></p><p>功能</p><ul><li>Packet classification</li><li>Buffer management</li><li>Scheduler<ul><li>Chooses among queued packets for transmission</li><li>Select packets to drop when buffer saturates</li></ul></li></ul><p>数据报分类：</p><p><img src="2025060444.png" alt=""></p><p><em>输入端口排队</em></p><ul><li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队<ul><li>排队延迟以及由于输入缓存溢出造成丢失</li></ul></li></ul><p><img src="2025060497.png" alt=""></p><p><em>输出端口排队</em><br>当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存</p><ul><li>数据报（分组）可能会被丢弃， 由于拥塞，缓冲区没有空间</li></ul><p>由调度规则选择排队的数据报进行传输</p><ul><li>优先权调度-谁会获得最优性能， 网络中立</li></ul><p>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存）</p><p>排队带来延迟，由于输出端口缓存溢出则丢弃数据报！</p><p>需要多少缓存<br><img src="2025060440.png" alt=""></p><p>丢弃策略：如果分组到达一个满的队列，哪个分组将会被抛弃</p><ul><li>tail drop: 丢弃刚到达的分组</li><li>priority: 根据优先权丢失/移除分组</li><li>random: 随机地丢弃/移除</li></ul><p><strong>调度策略</strong></p><p><em>FIFO</em><br>First In First Out：按照分组到来的次序发送</p><p><em>优先权</em><br>发送最高优先权的分组<br>多类，不同类别有不同的优先权</p><ul><li>类别可能依赖于标记或者其他的头部字段</li></ul><p><em>Round Robin (RR)</em></p><ul><li>多类</li><li>循环扫描不同类型的队列, 发送完一类的一个分组 ，再发送下一个类的一个分组，循环所有类</li></ul><p><em>Weighted Fair Queuing (WFQ)</em><br><img src="2025060436.png" alt=""></p><h2 id="IP-Packet-Structure">IP Packet Structure</h2><p><img src="2025060470.png" alt=""><br><img src="2025060467.png" alt=""></p><h2 id="IP-Addressing">IP Addressing</h2><p>IP 地址：32 位标示，对主机或者路由器的接口编址<br>接口: 主机/路由器和物理链路的连接处</p><ul><li>路由器通常拥有多个接口</li><li>主机也有可能有多个接口</li><li>IP 地址和每一个接口关联</li></ul><p>-&gt; 一个 IP 地址和一个接口相关联<br><em>IP 地址分类</em></p><p><img src="2025060460.png" alt=""></p><h3 id="子网">子网</h3><p>一个子网内的节点（主机或者路由器）它们的 IP 地址的<em>高位</em>部分相同 ，这些节点构成的网络的一部分叫做子网<br>无需路由器介入，子网内各主机可以在物理上相互直接到达</p><p><strong>内网 IP 地址</strong></p><ul><li>专用地址：地址空间的一部份供专用地址使用</li><li>永远不会被当做公用地址来分配, 不会与公用地址重复<ul><li>只在局部网络中有意义，区分不同的设备</li></ul></li><li>路由器不对目标地址是专用地址的分组进行转发</li></ul><p><strong>CIDR</strong></p><p>Classless InterDomain Routing （无类域间路由）</p><ul><li>子网部分可以在任意的位置</li><li>地址格式: a.b.c.d/x, 其中 x 是地址中<em>子网号的长度</em><br><img src="2025060443.png" alt=""></li></ul><p>主机如何获得 IP 地址</p><ul><li>系统管理员将地址配置在一个文件中</li><li>DHCP: Dynamic Host Configuration Protocol<ul><li>从服务器中动态获得一个 IP 地址</li></ul></li></ul><h3 id="DHCP">DHCP</h3><p>目标：允许主机在加入网络的时候，动态地从服务器那里获得 IP 地址</p><ul><li>可以更新对主机在用 IP 地址的租用期-租期快到了</li><li>重新启动时，允许重新使用以前用过的 IP 地址</li><li>支持移动用户加入到该网络（短期在网）</li></ul><p>DHCP 工作概况:</p><ul><li>主机广播“DHCP discover” 报文[可选]</li><li>DHCP 服务器用 “DHCP offer”提供报文响应[可选]</li><li>主机请求 IP 地址：发送 “DHCP request” 报文</li><li>DHCP 服务器发送地址：“DHCP ack” 报文</li></ul><p><img src="2025060427.png" alt=""><br><img src="2025060472.png" alt=""></p><p>DHCP 返回:</p><ul><li>IP 地址</li><li>第一跳路由器的 IP 地址（默认<em>网关</em>）</li><li><em>DNS 服务器</em>的域名和 IP 地址</li><li><em>子网掩码</em> (指示地址部分的网络号和主机号)</li></ul><p><img src="2025060422.png" alt=""></p><ul><li>DHCP 服务器生成 DHCP ACK， 包含客户端的 IP 地址，第一跳路由器的 IP 地址和 DNS 域名服务器的 IP 地址</li><li>DHCP 服务器封装的报文所在的帧转发到客户端，在客户端解封装成 DHCP 报文</li><li>客户端知道它自己的 IP 地址，DNS 服务器的名字和 IP 地址，第一跳路由器的 IP 地址</li></ul><h2 id="NAT-Network-Address-Translation">NAT: Network Address Translation</h2><p><img src="2025060407.png" alt=""></p><p><img src="2025060487.png" alt=""></p><h2 id="IPv6">IPv6</h2><p>初始动机: 32-bit 地址空间将会被很快用完</p><p>另外的动机:</p><ul><li>头部格式改变帮助加速处理和转发<ul><li>TTL-1</li><li>头部 checksum</li><li>分片</li></ul></li><li>头部格式改变帮助 QoS</li></ul><p>IPv6 数据报格式:</p><ul><li>固定的 40 字节头部</li><li>数据报传输过程中，不允许分片</li></ul><p><img src="2025060454.png" alt=""></p><p>和 IPv4 的其它变化</p><ul><li>Checksum: 被移除掉，降低在每一段中的处理速度</li><li>Options: 允许，但是在头部之外, 被 “Next Header” 字段标示</li><li>ICMPv6: ICMP 的新版本<ul><li>附加了报文类型, e.g. “Packet Too Big”</li><li>多播组管理功能</li></ul></li></ul><p><em>从 IPv4 到 IPv6 的平移</em></p><p>两种方案：</p><ul><li>Dual Stack：两种格式相互转化</li><li>隧道：在 IPv4 路由器之间传输的 IPv4 数据报中携带 IPv6 数据报</li></ul><p><img src="2025060448.png" alt=""></p><h2 id="通用转发和-SDN">通用转发和 SDN</h2><p>通用转发：匹配+动作<br><img src="2025060438.png" alt=""><br><strong>流表抽象</strong><br>泛化转发：简单的数据包处理规则</p><ul><li>匹配：数据包头部字段中的模式值</li><li>动作：对于匹配的数据包：丢弃、转发、修改、匹配的数据包或将匹配的数据包发送到控制器</li><li>优先级：消除重叠模式</li><li>计数器：字节数和包数</li></ul><p><img src="2025060476.png" alt=""></p><p><em>OpenFlow</em></p><p>flow table entries:<br><img src="2025060491.png" alt=""><br>抽象：<br>匹配+动作：抽象统一不同类型的设备<br><img src="2025060484.png" alt=""><br><img src="2025060480.png" alt=""></p><h2 id="Middleboxes">Middleboxes</h2><p><img src="2025060451.png" alt=""><br><img src="2025060491-1.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-all-重点</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-all-%E9%87%8D%E7%82%B9/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-all-%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-抽象封装">1 抽象封装</h2><h3 id="λ-表达式">λ 表达式</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[](<span class="hljs-type">double</span> <span class="hljs-keyword">x</span>)-&gt;<span class="hljs-type">double</span>&#123;return <span class="hljs-keyword">x</span>*<span class="hljs-keyword">x</span>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>参数、返回值类型可省</p><p>环境变量使用：</p><ul><li>&amp; 按引用方式</li><li>= 按值的方式</li><li>&amp;，= 可指定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">&amp;</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\&amp;,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">&amp;</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>=</mo><mo separator="true">,</mo><mi mathvariant="normal">&amp;</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[=,\&amp; n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">&amp;</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">&amp;</mi><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\&amp;k, m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">&amp;</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span> 默认是按值的方式</li></ul><h3 id="数据抽象与封装">数据抽象与封装</h3><p>抽象：程序外部可观察到的行为，使用者不考虑如何实现（复杂度控制）</p><p>封装：把程序实体内部具体的实现细节对使用者隐藏，只提供接口。（信息保护）<br>过程</p><ul><li>抽象：用一个名字代表完成一定功能的代码</li><li>封装：把命名代码的具体实现隐藏起来，数据通过参数来获得</li></ul><p>数据：</p><ul><li>抽象：只描述数据能实施哪些操作，以及操作之间的关系，用户不用知道具体表现形式（链表、数组等）</li><li>封装：把数据及其操作作为一个整体来进行实现，对数据的访问只能通过封装体对外接口中提供的操作进行实现</li></ul><h3 id="面向对象">面向对象</h3><p>程序由若干对象组成，每个对象是由一些数据以及对这些数据所能实施的操作所构成的封装体</p><ol><li>对象/类（类：描述对象的特征）</li><li>继承</li><li>消息的多态与动态绑定<ol><li>多态</li></ol><ul><li>一名多用：函数名重载、操作符重载</li><li>类属：类属函数、类属类型</li></ul><ol start="2"><li>绑定：确定对多态元素的某个使用是多态元素的哪一种形式</li></ol><ul><li>静态：在编译时确定</li><li>动态：在运行时确定</li></ul></li></ol><h2 id="2-对象与类">2 对象与类</h2><h3 id="成员的访问控制">成员的访问控制</h3><p>数据成员：在类中说明一个数据成员的类型时，若未见到相应类型的定义，则该数据成员只能是该类型的指针或引用类型。</p><ul><li>public 不受限制</li><li>private 本类 &amp; 友元</li><li>protected 本类 &amp; 友元 &amp; 派生类</li></ul><p>创建对象</p><ul><li>直接：在相应变量的生命周期创建，结束时对象消亡</li><li>间接（动态）：new 要用 delete 撤销</li></ul><h3 id="this-指针">this 指针</h3><p>类中描述的数据成员（静态除外）对该类的每个对象分别有一个拷贝</p><p><strong>成员函数</strong>对所有对象只有一个拷贝</p><p>除了静态成员函数，有一个隐藏的形参 this (类型：该类对象的指针)</p><p>在成员函数中对类成员的访问是通过 this 进行的，当通过对象访问类的成员函数，会把相应的对象地址传给成员函数的参数 this</p><p>显式使用：要将 this 指向的对象作为整体操作</p><h3 id="构造-析构函数">构造&amp;析构函数</h3><p><strong>构造函数</strong></p><ul><li>创建对象时自动调用</li><li>默认构造函数：不带参数的</li><li>可用于创建临时对象 <code>f(A(10))</code></li></ul><p>成员初始化表 <code>A():z(x),y(1)&#123;x=0;&#125;</code></p><p><strong>析构函数</strong></p><ul><li>不能被重载</li><li>对象消亡时自动调用</li><li>额外申请资源时，可自定义来归还空间</li><li>可在生存期内显示调用，暂时归还资源，不是让对象消亡</li></ul><p>成员对象：先调用本身类的构造函数，在进入函数体前，调用成员对象类的构造函数，然后执行函数体</p><p><strong>拷贝构造函数</strong><br>构造函数的参数类型为本类的引用，在创建对象时，若用另一个同类型的对象对其初始化则调用</p><ol><li>创建时显式指出</li><li>将对象作为值参数传给函数</li><li>把对象作为函数的返回值时</li></ol><p>隐式拷贝构造函数：将逐个成员进行拷贝初始化</p><ul><li>对象成员：调用对象类的拷贝构造函数</li></ul><p>问题：s1, s2 的成员指针 str 指向同一块内存区域，消亡时归还两次</p><p>-&gt; 可自定义拷贝构造函数</p><p><strong>转移构造函数</strong><br>右值引用类型 &amp;&amp;<br><code>f(A&amp;&amp; x)</code> 接受临时对象/即将消亡的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp; x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp;&amp; x)</span></span>;<br>A a;<br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">// 调用f(A&amp; x)</span><br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">A</span>()); <span class="hljs-comment">// 在两者都有定义时，调用f(A&amp;&amp; x)</span><br></code></pre></td></tr></table></figure><p><code>A(A&amp;&amp; x)</code> 用临时对象或即将消亡的对象去初始化另一个对象，若对象类中有转移构造函数则… 否则调用普通拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">A</span>(A&amp;&amp; x)<br>&#123;<br>p=x.p; <span class="hljs-comment">// 把参数对象x的p指向的空间作为新对象p的空间</span><br>x.p=null;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-成员函数-友元">3 成员函数 友元</h2><h3 id="常成员函数">常成员函数</h3><p>防止在获取对象状态中无意修改对象数据成员的值</p><p><code>int get_day() const;</code></p><p>对常量对象只能调用常成员函数</p><h3 id="静态成员">静态成员</h3><p><code>static int x;</code> 可实现同一个类的不同对象之间的数据共享<br><code>int A::x=0</code> 对该类的所有对象只有一份拷贝<br><code>static int get_shared()</code> 调用 a.get_shared () 或者 A.get_shared ()</p><h3 id="友元">友元</h3><p>为提高在类的外部对类数据成员的访问效率</p><p>友元不是一个类的成员，具有不对称性，不具有传递性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-操作符重载">4 操作符重载</h2><h3 id="基本操作符重载">基本操作符重载</h3><p>以成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Conplex&amp; x) <span class="hljs-type">const</span><br>&#123;<br>Complex tmp;<br>tmp.real = real + x.real;<br>tmp.imag = imag + x.imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125;;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按a.operator + (b)实现</span><br></code></pre></td></tr></table></figure><p>以全局函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2);<br>&#125;;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2)<br>&#123;<br>Complex tmp;<br>tmp.real = c<span class="hljs-number">1.</span>real + c<span class="hljs-number">2.</span>real;<br>tmp.imag = c<span class="hljs-number">1.</span>imag + c<span class="hljs-number">2.</span>imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按operator+(a, b)实现</span><br></code></pre></td></tr></table></figure><p>不可重载的：. , .* ?: :: sizeof</p><p>遵循已有操作数的语法：</p><ul><li>不能改变操作数的个数</li><li>原操作符的优先级和结合性不变</li></ul><p>++/–</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 后置用法(int)</span><br>Counter&amp; <span class="hljs-keyword">operator</span> ++()<span class="hljs-comment">// 前置的++重载函数</span><br>&#123;<br>value++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">const</span> Counter <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>) <span class="hljs-comment">// 后置的++重载函数</span><br>&#123;<br>Counter tmp = *<span class="hljs-keyword">this</span>;<br>value++; <span class="hljs-comment">// ++(*this) 调用前置的++重载函数</span><br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特殊操作符的重载">特殊操作符的重载</h3><p>=<br>s1=s2 s1.str 原来指向的空间丢失 s2 的 str 释放两次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br>......<br>String&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> String&amp; s)<br>&#123;<br><span class="hljs-keyword">if</span> (&amp;s == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//防止自身赋值：a=a</span><br><span class="hljs-keyword">delete</span> []str; <span class="hljs-comment">//归还str原来指向的空间</span><br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s.len<span class="hljs-number">+1</span>]; <span class="hljs-comment">//申请新的空间</span><br><span class="hljs-built_in">strcpy</span>(str,s.str); <span class="hljs-comment">//把用于赋值的字符串复制到新空间中</span><br>len = s.len; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>若有成员对象，自定义的赋值操作符重载函数不会自动去调用成员对象类的赋值操作，需要在自定义的赋值操作符重载函数中显式指出。</p><p><code>a = b.a;//调用A类的赋值操作符重载函数来实现成员对象的赋值。</code></p><p><code>A a;</code></p><ul><li><code>A b=a;</code> //初始化，等价于：A b (a);，调用拷贝构造函数。</li><li><code>b = a; </code> //赋值，调用赋值操作符=重载函数。</li></ul><p>若赋值的对象即将消亡：<code>A&amp; operator=(A&amp;&amp; x)</code></p><p>在转移赋值操作符重载函数中实现资源的转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; x)<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span> []p; <span class="hljs-comment">//归还老空间</span><br>p = x.p; <span class="hljs-comment">//使用参数对象的空间（资源转移）</span><br>x.p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//使得参数对象不再拥有该空间</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>[ ]<br><code>char operator [](int i) const&#123;return str[i];&#125; //用于常量对象 </code><br>( )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; value = i; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">//函数调用操作符()的重载函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x*y+value;<br>&#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//a是个对象</span><br>cout &lt;&lt; a.<span class="hljs-built_in">g</span>() &lt;&lt;endl; <span class="hljs-comment">//把a当对象来用</span><br>cout &lt;&lt; <span class="hljs-number">10</span>+<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &lt;&lt; endl;<br><span class="hljs-comment">//把a当函数来用！</span><br><span class="hljs-comment">//a(10,20)等价于：a.operator()(10,20)</span><br></code></pre></td></tr></table></figure><h3 id="λ-表达式原理">λ 表达式原理</h3><p>编译器</p><ul><li>隐式定义一个类<ul><li>数据成员对应 λ 表达式用到的环境变量（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[...]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">...</span><span class="mclose">]</span></span></span></span>）, 在构造函数中用环境变量对它们进行初始化</li><li>按相应 λ 表达式的函数功能重载函数调用操作符</li></ul></li><li>创建上述类的一个临时对象（设为 obj）</li><li>在使用上述 λ 表达式的地方用 obj 来替代<ul><li>作用于实参进行函数调用：<code>cout &lt;&lt; [...](int x)-&gt;int &#123; ....... &#125;(3);</code> 替换成：<code>cout &lt;&lt; obj(3);</code></li><li>传给其它函数：<code>f([...](int x)-&gt;int &#123; ....... &#125;); </code> 替换成：` f (obj);</li></ul></li></ul><h3 id="智能指针">智能指针</h3><p>-&gt;</p><ul><li>第一个操作数：一个指向类或结构的指针</li><li>第二个操作数：第一个指向的类或结构的成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PtrA</span><br>&#123;<br>A* p_a;<br><span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">PtrA</span>(A *p)<br>&#123;<br>p_a=p;count=<span class="hljs-number">0</span>;<br>&#125;<br>A* <span class="hljs-keyword">operator</span>-&gt;()<br>&#123;<br>count++;<br><span class="hljs-keyword">return</span> p_a;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>PtrA b=&amp;a;<br>b-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// b.operator-&gt;()-&gt;f();</span><br></code></pre></td></tr></table></figure><p>库提供：</p><ul><li>shared_ptr 带引用计数，可实现动态对象空间的自动回收</li><li>unique_ptr 独占动态对象</li></ul><p>new</p><p><code>void *operator new(size_t size)</code> size 即所需空间大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(A)];<br>A *p = <span class="hljs-built_in">new</span>(buf) <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>delete</p><p><code>void operator delete(void *p, size_t size)</code> 前者指向对象的内存空间，后者可省略</p><p><code>A *p=new A[10];</code> <code>delete []p</code></p><p>当类中有析构函数，传给 new[] 重载的参数 size 的实际值会比对象数组所需的空间多 4 个字节，用于存储元素个数</p><p>delete 会根据元素个数调用每个元素的析构函数</p><p>自定义类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> x+y;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会有歧义问题：<code>a+i</code></p><ul><li>显示类型转换：<code>(int)a + i</code> 或 <code>a+(A)i</code></li><li>禁止把 A 当作隐式类型转换符 explicit<ul><li><code>explicit A(int i)&#123;&#125;</code></li><li>禁止将 int () 当作隐式类型转换 <code>explicit operator int()&#123;...&#125;</code></li></ul></li></ul><h2 id="5-继承-派生类">5 继承 派生类</h2><h3 id="继承">继承</h3><p>在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出新的功能定义或对已有类的功能进行重新定义</p><p>派生类不能访问基类的私有成员</p><p>Hidden: 如果派生类中定义了与基类同名的成员，则基类的成员名在派生类的作用域中不直接可见</p><p>在派生类中访问基类同名的成员时要基类名受限 <code>A::func()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 可用using声明</span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类创建</p><ul><li>先调用本身类的构造函数，但在进入函数体前会先调用基类的构造函数（默认构造函数）</li></ul><p>消亡时，先调用本身，执行完后，调用基类的</p><p>D 有基类 B 成员对象类 M</p><p>创建 B-&gt;M-&gt;D 消亡 D-&gt;M-&gt;B</p><h3 id="虚函数">虚函数</h3><ol><li>指定消息用动态绑定</li><li>指出基类中可被派生类重新定义的成员函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 前面加上virtual则变为动态绑定</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(A&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>x.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 静态：A::f() 动态：A/B</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(A* p)</span></span><br><span class="hljs-function"></span>&#123;<br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 静态：A::f() 动态：A/B</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类">抽象类</h3><p><code>virtual int f()=0;</code> 纯虚函数</p><p>抽象类不能用于创建对象</p><p>作用</p><ul><li>为派生类提供一个基本框架</li><li>为同一个功能的不同实现提供一个抽象描述（接口）</li></ul><h3 id="多继承">多继承</h3><p>名冲突问题——基类名受限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;A::<span class="hljs-built_in">f</span>(); B::<span class="hljs-built_in">f</span>();&#125;<br>&#125;<br>C c;<br>c.A::<span class="hljs-built_in">f</span>();<br>c.B::<span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure><p>重复继承问题——虚基类</p><p>D 继承自 B, C；B，C 都继承自 A，A 中有数据成员 x, 则 D 的对象 d 中会有两个 x，B:: x, C:: x , 若要 D 中只有一个 x，可将 A 定为 B, C 的虚基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> B&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C&#123;&#125;<br></code></pre></td></tr></table></figure><p>虚基类的构造函数由该类的构造函数直接调用，优先非基类的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>) &#123; y = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>) &#123; z = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> m;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k): <span class="hljs-built_in">B</span>(i), <span class="hljs-built_in">C</span>(j), <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>) &#123; m = k; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> D <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l): <span class="hljs-built_in">D</span>(i,j,k), <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>) &#123; n = l; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>聚合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A *pm;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(A *p)&#123;pm=p;&#125;<br>~B&#123;pm=Null&#125;<br>&#125;<br>A *pa = <span class="hljs-keyword">new</span> A;<br>B *pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(pa);<br><span class="hljs-keyword">delete</span> pb; <span class="hljs-comment">// 聚合类对象消亡其成员对象没有消亡</span><br><span class="hljs-keyword">delete</span> pa;<br></code></pre></td></tr></table></figure><p>组合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br>A a;<br>&#125;<br>C *pc = <span class="hljs-keyword">new</span> C;<br><span class="hljs-keyword">delete</span> pc; <span class="hljs-comment">// 成员对象在组合类对象内部创建并随着组合类对象消亡而消亡</span><br></code></pre></td></tr></table></figure><h2 id="6-IO">6 IO</h2><p>cout cin 优势</p><ul><li>不用专门指定数据的类型和个数，编译时刻根据数据本身来决定数据的类型和个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream <span class="hljs-title">in</span><span class="hljs-params">(...)</span></span>;<br>in.<span class="hljs-built_in">get</span>(ch);<br>in.<span class="hljs-built_in">read</span>(p, <span class="hljs-number">100</span>);<br><br><span class="hljs-function">ostream <span class="hljs-title">out</span><span class="hljs-params">()</span></span>;<br>out.<span class="hljs-built_in">put</span>(ch);<br>out.<span class="hljs-built_in">write</span>(p,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>“&gt;&gt;” 把输入看作字符串，自动进行从字符串到基本数据类型的转换</p><p>cerr (ostream 的对象) 对应着计算机系统用于输出特殊信息的设备，不带缓冲（clog 带缓冲）</p><p>指针：<code>char *p</code> <code>cout&lt;&lt;p</code> 输出 p 指向的字符串 <code>cout&lt;&lt;(void*)p</code> 输出指针 p 本身的值</p><p>输出格式——操纵符 manipulator</p><p>hex 十六进制 oct 八进制 dec 十进制 setprecision (int n) 设置浮点数精度<br>setiosflags (long flags) resetiosflags (long flags) 参数 ios:: scientific 以指数形式显示浮点数 ios:: fixed 小数形式</p><h3 id="面向控制台">面向控制台</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">ostream::put</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span>;<br>cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-function">ostream&amp; <span class="hljs-title">ostream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">int</span> count)</span></span>;<br><span class="hljs-comment">// 输出p指向的内存空间中count个字节。</span><br><span class="hljs-type">char</span> info[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> n;...<br>cout.<span class="hljs-built_in">write</span>(info, n);<br></code></pre></td></tr></table></figure><p>用&gt;&gt; 数据之间会用空白符分开（空格，\t,\n）</p><p><code>cin &gt;&gt; setw(10) &gt;&gt; str</code> 把输入的字符串和一个‘\0’放入 str，即最多 9 个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span> &amp;ch)</span></span>;<br>istream&amp; istream:<span class="hljs-built_in">read</span>(<span class="hljs-type">char</span>* p, <span class="hljs-type">int</span> count);<br><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> count, <span class="hljs-type">char</span> delim=<span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>;<br><span class="hljs-comment">// 输入到count-1或遇到delim指定的字符为止，并自动加入&#x27;\0&#x27;</span><br><span class="hljs-comment">// 空白符也会作为字符输入</span><br></code></pre></td></tr></table></figure><p>跳过 n 个或遇到换行符： <code>cin.ignore(n,'\n')</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin.<span class="hljs-built_in">getline</span>(str,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span>(cin.<span class="hljs-built_in">fail</span>()) <span class="hljs-comment">// 如果本行还有未读的字符</span><br>&#123;<br>cin.<span class="hljs-built_in">clear</span>();<br>cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;&lt; &gt;&gt; 重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">operator</span>&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="hljs-type">const</span> Complex&amp; c)<br>&#123;<br>out &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面向文件">面向文件</h3><p>每个打开的文件都有一个内部的隐藏指针</p><p><code>ofstream out_file(&quot;xx.txt&quot;);</code> <code>out_file.open(&quot;xxx&quot;)</code></p><p>打开方式：</p><ul><li>ios:: out 写 若已经存在则先清除内容，若没有则创建</li><li>ios:: app 添加 指针在末尾，若无则创建</li></ul><p>判断 <code>if(out_file.is_open())</code></p><p>输出到 <code>out_file &lt;&lt; x &lt;&lt; endl</code> 二进制：<code>out_file.write((char*)&amp;s1, sizeof(s1))</code></p><p>关闭 <code>out_file.close()</code></p><ul><li>把文件内存缓冲区的内容写到磁盘中</li><li>归还打开文件时申请的资源</li></ul><p>打开文件 <code>ifstream in_file(&quot;xxx&quot;)</code></p><p>打开方式 ios:: in 读操作</p><h2 id="7-异常处理">7 异常处理</h2><h3 id="异地处理，结构化">异地处理，结构化</h3><p>就地处理 —— exit / abort <code>if(file.fail())&#123;exit(-1);&#125;</code></p><p>异地处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(...)</span></span>&#123;...<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(rc == <span class="hljs-number">-1</span>))&#123;...&#125;<br></code></pre></td></tr></table></figure><p>结构化异常处理机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">fail</span>()) &#123; <span class="hljs-keyword">throw</span> filename; &#125;<br>&#125;<br><span class="hljs-built_in">try</span>(<span class="hljs-built_in">f</span>(str))...<br><span class="hljs-built_in">catch</span>(<span class="hljs-type">char</span> *fn) &#123; ...<span class="hljs-comment">// 处理异常&#125;</span><br></code></pre></td></tr></table></figure><p>一个 try 后可跟多个 catch，采用精准匹配</p><p>嵌套：</p><ul><li>若内层 try 的执行发生异常，内层不存在相应的 catch，逐步向外层找，若在函数调用链上没有捕获，则调用系统的 terminate，一般是 abort</li></ul><p>可能导致内存泄漏问题，比如 throw 前 new 了动态对象</p><ul><li>局部对象会自动消亡</li><li>可用智能指针 <code>uniqu_ptr(A) p(new A) ... throw...</code> p 会消亡，它的析构函数会释放动态对象</li></ul><h2 id="8-泛型-STL-函数式">8 泛型 STL 函数式</h2><h3 id="泛型程序设计">泛型程序设计</h3><p>基于具有类属特性的程序实体进行程序设计的技术</p><p>函数模板 ——带有类型参数的函数定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T element[])</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp; <span class="hljs-comment">// 可作局部变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显式实例化 <code>max&lt;int&gt;(x,m)</code></p><p>带非类型参数的函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp[size];<br>&#125;<br><span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-number">10</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>类模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>....<br>Stack&lt;<span class="hljs-type">int</span>&gt; st1; <span class="hljs-comment">// 必须显式实例化</span><br></code></pre></td></tr></table></figure><p>注意：把类模板的定义和实现都放在头文件中</p><h3 id="STL">STL</h3><p>vector-动态数组 list-双向链表 deque-分段的连续空间结构</p><p>迭代器（属于智能指针）</p><ul><li>vector, deque, basic_string：随机迭代器 RanIt</li><li>list, map, multimap, set：双向迭代器 BidIt</li></ul><p>算法：一个算法能接受的迭代器类型是通过算法模板参数的名字体现的</p><p>template&lt;class InIt, class OutIt&gt;</p><p>OutIt copy (InIt src_first, InIt src_last, Out_It dst_first) // 前两个也就是操作范围的两个迭代器必须属于同一容器</p><p>自定义操作条件</p><ul><li>一元谓词 Pred count_if (v.begin (), v.end (), f)</li><li>二元谓词 BinPred sort (RanIt first, RanIt last, BinPred comp)</li></ul><p>自定义操作</p><ul><li>一元 Op/Fun</li><li>二元 BinOp/BinFun</li></ul><p>e.g. Fun for_each (InIt first, InIt last, Fun f)</p><p><code>void display(int x)&#123;cout &lt;&lt; &quot; &quot; &lt;&lt; x;&#125;</code></p><p><code>for_each(v.begin(), v,end(), display);</code></p><h3 id="函数式程序设计">函数式程序设计</h3><p>命令式程序设计</p><ul><li>过程式程序设计</li><li>面向对象程序设计</li></ul><p>声明式</p><ul><li>函数式</li><li>逻辑式</li></ul><p>Functional Programming：把程序组织成一组数学函数，计算过程体现为基于一系列函数应用的表达式求值。</p><p>基本特征：</p><ol><li>纯函数：以相同的参数调用同一个函数总得到相同的值（引用透明），除了产生计算结果不会改变其他任何东西（无副作用）</li><li>没有状态：计算体现为数据之间的映射，不改变已有数据而是产生新数据（无赋值操作）</li><li>函数也是值：函数的参数和返回值都可以是函数，可由已有函数生成新的函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverse</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(str) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> str;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">substr</span>(str, <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str) - <span class="hljs-number">1</span>)) + <span class="hljs-built_in">substr</span>(str, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尾递归</p><ul><li>函数递归调用深度要受栈空间的限制，并且递归调用效率低</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> b;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>,b,a+b);&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>好处：递归调用回来不用做其它事，从而不会再使用递归调用前的栈空间内容，所以递归调用时不必额外为它分配栈空间，可重用当前栈空间</p><p>转迭代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> b;<br><span class="hljs-keyword">else</span><br>&#123; <span class="hljs-comment">// return fib(n-1,b,a+b)</span><br><span class="hljs-type">int</span> t1 = n<span class="hljs-number">-1</span>, t2=b, t3=a+b;<br>n = t1, a = t2, b = t3;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>部分函数应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br>function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; print10 = [](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(n, <span class="hljs-number">10</span>);&#125;;<br><span class="hljs-built_in">print10</span>(<span class="hljs-number">23</span>) <span class="hljs-comment">// 等价 print(23,10)</span><br></code></pre></td></tr></table></figure><p>用 bind 实现</p><p>Fty2 bind (Fty1 fn, T1 t1, T2 t2, TN, tn);</p><p>fn: 带 n 个参数的函数，t1~tn：参数值 固定 or 未绑定（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">_</mi><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">_</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\_1,\_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9544em;vertical-align:-0.31em;"></span><span class="mord">_1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">_2</span></span></span></span>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> base)</span></span><br><span class="hljs-function">function&lt;<span class="hljs-title">void</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; print10 : bind(print,_1,<span class="hljs-number">10</span>) // n不绑，base绑<span class="hljs-number">10</span></span><br></code></pre></td></tr></table></figure><p>柯里化 currying</p><p>意义</p><ul><li>数学上：对单参数函数的研究模型可用到多参数上</li><li>程序设计上：不必把一个多参数的函数所需要的参数同时提供给它，可逐步提供</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">function&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">add_cd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">bind</span>(add, x, _1);<br><span class="hljs-comment">// [x](int y)-&gt;int&#123;return add(x,y)&#125;</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-built_in">add_cd</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="9-事件驱动的程序设计">9 事件驱动的程序设计</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">WinMain</span>()<br>&#123;<br><span class="hljs-built_in">RegisterClass</span>(); <span class="hljs-comment">// 注册窗口类，定义程序中要创建的窗口类型</span><br><span class="hljs-built_in">CreateWindow</span>(); <span class="hljs-comment">// 创建主窗口</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">GetMessage</span>()) <span class="hljs-comment">// 消息队列</span><br>&#123;<br><span class="hljs-built_in">DispatchMessage</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-5-继承</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1>派生类</h1><p>继承是指：</p><ul><li>在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出新功能的定义或对已有类的某些功能进行重新定义。</li><li>不需要已有软件的源代码，属于目标代码复用！</li></ul><p>在 C++中，定义单继承时，派生类只能有一个直接基类，其定义格式如下：</p><p><code>class &lt;派生类名&gt;:[&lt;继承方式&gt;] &lt;基类名&gt; &#123; &lt;成员说明表&gt; &#125;; </code></p><ul><li>&lt;派生类名&gt;为派生类的名字。</li><li>&lt;基类名&gt;为直接基类的名字。</li><li>&lt;成员说明表&gt;是在派生类中新定义的和对基类重定义的成员。</li><li>&lt;继承方式&gt;用于指出从基类继承来的成员在派生类中对外的访问控制。</li></ul><p>除了拥有新定义的成员外，派生类拥有基类的所有成员（基类的构造函数、析构函数和赋值操作除外）</p><p>定义派生类时一定要见到<strong>基类的定义</strong>.</p><p><strong>友元</strong>：</p><ul><li>如果在派生类中没有显式指出，则基类的友元不是派生类的友元；</li><li>如果基类是另一个类的友元，而该类没有显式指出， 则派生类不是该类的友元。</li></ul><p>派生类不能直接访问基类的<strong>私有成员</strong>。</p><p><strong>protected</strong> 访问控制缓解了封装与继承的矛盾。</p><p>C++类向外界提供两种接口：</p><ul><li>public：供类的实例用户使用（通过对象）</li><li>public+protected：供派生类使用</li></ul><p><img src="2025031541.png" alt=""><br><img src="2025031590-1.png" alt=""><br><img src="2025031546.png" alt=""></p><p><img src="2025031538.png" alt=""></p><p>当创建派生类的对象时，</p><ul><li>是先调用本身类的构造函数，但在进入函数体之前，会去调用基类的构造函数，然后再执行本身类构造函数的函数体！</li><li>默认情况下，调用基类的<strong>默认构造函数</strong>，如果要调用基类的非默认构造函数，则必须在派生类构造函数的成员初始化表中<strong>显式指出</strong>。</li><li>也就是说，构造函数的成员初始化表（即使没显式给出）中有对基类的构造函数的调用代码。</li></ul><p>当派生类对象消亡时，</p><ul><li>是先调用本身类的析构函数，本身类析构函数的函数体执行完之后，再去调用基类的析构函数！</li><li>也就是说，析构函数的函数体最后有对基类析构函数的调用代码。</li></ul><p><img src="2025031501-1.png" alt=""></p><h1>虚函数与消息的动态绑定</h1><p>静态绑定：</p><p><img src="2025031585.png" alt=""></p><p>动态绑定：</p><ul><li>在基类中用虚函数来指出<br><img src="2025031537.png" alt=""><br>虚函数有两个作用：</li><li>指定消息采用动态绑定。</li><li>指出基类中可以被派生类重定义的成员函数<ul><li>对于基类中的一个虚函数，在派生类中定义的、与之具有相同型构的成员函数是对基类该成员函数的重定义（或称覆盖，override）</li></ul></li></ul><h1>抽象类</h1><p>纯虚函数是没给出实现的虚函数，函数体用“=0”表示</p><p><img src="2025031535.png" alt=""></p><p>包含纯虚函数的类称为抽象类。</p><ul><li>抽象类不能用于创建对象。</li><li>抽象类的作用：<ul><li>为派生类提供一个基本框架</li><li>为同一个功能的不同实现提供一个抽象描述（接口）。</li></ul></li></ul><p><img src="2025031553-2.png" alt=""></p><p>C++的类不是抽象数据类型，它是抽象数据类型的实现<br><strong>用抽象类实现类的真正抽象作用</strong><br>问题：</p><p><img src="2025031569-1.png" alt=""></p><p>解决：</p><p><img src="2025031527.png" alt=""></p><h1>多继承</h1><p>多继承是指派生类可以有一个以上的直接基类</p><ul><li>继承方式及访问控制的规定同单继承。</li><li>派生类拥有所有基类的所有成员。</li><li>基类的声明次序决定：<ul><li>对基类数据成员的存储安排。</li><li>对基类构造函数/析构函数的调用次序</li></ul></li></ul><p><img src="2025031568.png" alt=""></p><p>多继承带来的问题</p><ul><li>名冲突问题 —— 基类名受限</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123; ......<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用A的f。</span><br>B::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用B的f。</span><br>&#125;<br>&#125;;<br>......<br>C c;<br>c.A::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用A的f。</span><br>c.B::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用B的f。</span><br></code></pre></td></tr></table></figure><ul><li>重复继承问题</li></ul><p><img src="2025031529.png" alt=""></p><p>如果要求类 D 中只有一个 x，则应把 A 定义为 B 和 C 的<strong>虚基类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">int</span> x; ......&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;......&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;......&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;......&#125;;<br>D d;<br></code></pre></td></tr></table></figure><p>对于拥有虚基类的类，创建该类的对象时：</p><ul><li>虚基类的构造函数由该类的构造函数直接调用。</li><li>虚基类的构造函数优先非虚基类的构造函数执行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>) &#123; y = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>) &#123; z = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> m;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k): <span class="hljs-built_in">B</span>(i), <span class="hljs-built_in">C</span>(j), <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>) &#123; m = k; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> D <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l): <span class="hljs-built_in">D</span>(i,j,k), <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>) &#123; n = l; &#125;<br>&#125;;<br>......<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//这里，A的构造函数由D调用，d.x初始化为3</span><br><span class="hljs-comment">// 调用的构造函数及它们的执行次序是： A(3)、B(1)、C(2)、D(1,2,3)</span><br><span class="hljs-function">E <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//这里， A的构造函数由E调用，e.x初始化为4</span><br><span class="hljs-comment">// 调用的构造函数及它们的执行次序是： A(4)、B(1)、C(2)、D(1,2,3)、E(1,2,3,4)</span><br></code></pre></td></tr></table></figure><h1>聚合与组合</h1><p><strong>聚合</strong></p><p>聚合类的成员对象一般是采用<strong>对象指针</strong>表示，用于指向被包含的成员对象，而被包含的成员对象是在<strong>外部</strong>创建，然后加入到聚合类对象中来的。</p><p><img src="2025031503.png" alt=""></p><p><strong>组合</strong></p><p>组合类的成员对象一般<strong>直接是对象</strong>， 有时也可以采用对象指针表示，但不管是什么表示形式，成员对象一定是在组合类对象内部创建并随着组合类对象的消亡而消亡。</p><p><img src="2025031599-1.png" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-4-操作符重载</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1>操作符重载</h1><h2 id="操作符重载概述">操作符重载概述</h2><p>操作符重载可通过定义一个函数名为 “operator #”（ “#”代表某个可重载的操作符）的函数来实现，该函数可以作为：</p><ul><li>一个类的非静态的成员函数（操作符 new 和 delete 的重载除外）。</li><li>一个全局（友元）函数。</li></ul><p>以成员函数重载复数的“+”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Conplex&amp; x) <span class="hljs-type">const</span><br>&#123;<br>Complex tmp;<br>tmp.real = real + x.real;<br>tmp.imag = imag + x.imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125;;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按a.operator + (b)实现</span><br></code></pre></td></tr></table></figure><p>以全局函数重载复数的“+”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2);<br>&#125;;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2)<br>&#123;<br>Complex tmp;<br>tmp.real = c<span class="hljs-number">1.</span>real + c<span class="hljs-number">2.</span>real;<br>tmp.imag = c<span class="hljs-number">1.</span>imag + c<span class="hljs-number">2.</span>imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按operator+(a, b)实现</span><br></code></pre></td></tr></table></figure><p>操作符重载的基本原则</p><ul><li>只能重载 C++语言中已有的操作符，不可臆造新的操作符。</li><li>可以重载 C++中除下列操作符外的所有操作符： “. ”， “.* ”，“?: ”，“:: ”，“sizeof ”</li><li>需要遵循已有操作符的语法：<ul><li>不能改变操作数的个数。</li><li>原操作符的优先级和结合性不变。</li></ul></li><li>尽量遵循已有操作符原来的语义：<ul><li>语言本身没有对此做任何规定，使用者自己把握 ！</li></ul></li></ul><h2 id="双目操作符重载">双目操作符重载</h2><h3 id="作为成员函数重载">作为成员函数重载</h3><ul><li>只需要提供一个参数，它对应第二个操作数（第一个操作数则由隐藏的参数 this 给出）。</li></ul><p>复数的不等于和等于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-type">double</span> real, imag;<br><span class="hljs-keyword">public</span>:<br>......<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-type">const</span> Complex&amp; x) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-built_in">return</span> (real == x.real) &amp;&amp; (imag == x.imag);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> !=(<span class="hljs-type">const</span> Complex&amp; x) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-built_in">return</span> (real != x.real) || (imag != x.imag);<br>&#125;<br>&#125;;<br>......<br>Complex c1,c2;<br>......<br><span class="hljs-keyword">if</span> (c1 == c2) <span class="hljs-comment">//或 if (c1 != c2) ......</span><br></code></pre></td></tr></table></figure><h3 id="作为全局（友元）函数重载">作为全局（友元）函数重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-type">double</span> real, imag;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Complex</span>() &#123; real = <span class="hljs-number">0</span>; imag = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) &#123; real = r; imag = i; &#125;<br>......<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2);<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c, <span class="hljs-type">double</span> d);<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">double</span> d, <span class="hljs-type">const</span> Complex&amp; c);<br>&#125;;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(c<span class="hljs-number">1.</span>real+c<span class="hljs-number">2.</span>real,c<span class="hljs-number">1.</span>imag+c<span class="hljs-number">2.</span>imag);<br>&#125;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c, <span class="hljs-type">double</span> d)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(c.real+d,c.imag);<br>&#125;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">double</span> d, <span class="hljs-type">const</span> Complex&amp; c)<br><span class="hljs-comment">//“实数+复数”只能作为全局函数重载。为什么？</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(d+c.real,c.imag);<br>&#125;<br>......<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>,c1,c2,c3</span>;<br>c1 = a + b;<br>c2 = b + <span class="hljs-number">21.5</span>;<br>c3 = <span class="hljs-number">10.2</span> + a;<br></code></pre></td></tr></table></figure><h2 id="单目操作符重载">单目操作符重载</h2><h3 id="作为成员函数重载-2">作为成员函数重载</h3><p>复数的取负操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123; ......<br><span class="hljs-keyword">public</span>:<br> ......<br> Complex <span class="hljs-keyword">operator</span> -() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(-real, -imag); &#125;<br> &#125;;<br> ......<br> <span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>,b</span>;<br> b = -a; <span class="hljs-comment">//把a的负数赋值给b</span><br></code></pre></td></tr></table></figure><h3 id="作为全局（友元）函数重载-2">作为全局（友元）函数重载</h3><p>判断复数是否为“零”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123; ......<br><span class="hljs-keyword">public</span>:<br> ......<br> <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> !(<span class="hljs-type">const</span> Complex &amp;c);<br> &#125;;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> !(<span class="hljs-type">const</span> Complex &amp;c)<br>&#123;<br><span class="hljs-keyword">return</span> (c.real == <span class="hljs-number">0.0</span>) &amp;&amp; (c.imag == <span class="hljs-number">0.0</span>);<br>&#125;<br>......<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>......<br><span class="hljs-keyword">if</span> (!a) <span class="hljs-comment">//a为0时true</span><br></code></pre></td></tr></table></figure><h2 id="操作符-和–的重载">操作符++和–的重载</h2><p>单目操作符++（–）：</p><ul><li>它们只有一个操作数，并且该操作数为一个左值表达式</li><li>它们是带<strong>副作用</strong>的操作符：得到一个计算结果的同时会改变操作数的值！</li></ul><p>为了能够区分++（–）的前置与后置用法， 可以为后置用法再写一个重载函数，该重载函数应有一个<strong>额外的 int 型参数</strong>，但函数体中不会使用该参数的值，它只是用于从形式上把后置的重载函数与前置的重载函数区分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Counter</span>() &#123;value = <span class="hljs-number">0</span>;&#125;<br>Counter&amp; <span class="hljs-keyword">operator</span> ++()<span class="hljs-comment">// 前置的++重载函数</span><br>&#123;<br>value++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">const</span> Counter <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>) <span class="hljs-comment">// 后置的++重载函数</span><br>&#123;<br>Counter tmp = *<span class="hljs-keyword">this</span>;<br>value++; <span class="hljs-comment">// ++(*this) 调用前置的++重载函数</span><br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125;;<br>Counter a,b;<br>++a; <span class="hljs-comment">//使用的是不带参数的操作符++重载函数</span><br>a++; <span class="hljs-comment">//使用的是带int型参数的操作符++重载函数</span><br>b = (++a); <span class="hljs-comment">//把加一之后a的值赋值给b</span><br>b = (a++); <span class="hljs-comment">//把加一之前a的值赋值给b</span><br>++(++a);或 (++a)++; <span class="hljs-comment">//OK，a加2</span><br>++(a++);或 (a++)++; <span class="hljs-comment">//Error，编译不通过</span><br></code></pre></td></tr></table></figure><h1>C++特殊操作符的重载</h1><h2 id="赋值操作符“-”">赋值操作符“=”</h2><p>C++编译程序会为每个类定义一个<strong>隐式的</strong>赋值操作，其行为是：逐个成员进行赋值操作。</p><ul><li>对于普通成员，它采用常规的赋值操作。</li><li>对于成员对象，则调用该成员对象类的赋值操作进行成员对象的赋值操作。</li></ul><p>直接赋值，<strong>问题</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;xyz&quot;</span>)</span>,<span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;abcdefg&quot;</span>)</span></span>;<br>.......<br>s1 = s2;<br></code></pre></td></tr></table></figure><ul><li>s 1. str 原来指向的空间丢失了（内存泄露）</li><li>s 1 和 s 2 互相干扰</li><li>s 1 和 s 2 消亡时，&quot;abcdefg&quot;所在的空间将会被释放两次</li></ul><p><img src="2025031569.png" alt=""></p><p><strong>解决</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br>......<br>String&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> String&amp; s)<br>&#123;<br><span class="hljs-keyword">if</span> (&amp;s == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//防止自身赋值：a=a</span><br><span class="hljs-keyword">delete</span> []str; <span class="hljs-comment">//归还str原来指向的空间</span><br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s.len<span class="hljs-number">+1</span>]; <span class="hljs-comment">//申请新的空间</span><br><span class="hljs-built_in">strcpy</span>(str,s.str); <span class="hljs-comment">//把用于赋值的字符串复制到新空间中</span><br>len = s.len; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的返回值类型能是 void 吗？为什么是 String 并且是它的引用？</p><ul><li>为了允许下面的操作： s 1=(s 2=s 3) 和 (s 1=s 2)=s 3</li></ul><p>如果有<strong>成员对象</strong>，自定义的赋值操作符重载函数不会自动去调用成员对象类的赋值操作，需要在自定义的赋值操作符重载函数中显式指出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; ...... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br>......<br>B&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> B&amp; b)<br>&#123;<br><span class="hljs-keyword">if</span> (&amp;b == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>a = b.a;<span class="hljs-comment">//调用A类的赋值操作符重载函数来实现成员对象的赋值。</span><br>x = b.x;<br>y = b.y;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>一般来讲，需要自定义拷贝构造函数的类通常也需要自定义赋值操作符重载函数。<br>注意：要区别下面两个“=”的不同含义:<br><code>A a;</code></li><li><code>A b=a;</code> //初始化，等价于：A b (a);，调用拷贝构造函数。</li><li><code>b = a; </code> //赋值，调用赋值操作符=重载函数。</li></ul><p><strong>赋值操作符重载存在的问题</strong></p><p>当用于赋值的对象是一个<strong>临时或即将消亡</strong>的对象时，目前的赋值操作符重载函数的实现效率有时是不高的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回一个A类的临时对象作为返回值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>; <span class="hljs-comment">//调用构造函数申请空间</span><br>......<br>a = <span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//把函数f返回值对象赋值给对象a：</span><br><span class="hljs-comment">//1. 调用赋值操作符重载函数（为a归还老空间、 申请新空间并进行内容复制）</span><br><span class="hljs-comment">//2. 函数f返回值对象消亡（调用析构函数归还空间）</span><br>......<br>&#125; <span class="hljs-comment">//对象a消亡（调用析构函数归还空间）</span><br></code></pre></td></tr></table></figure><p>-&gt; <strong>转移赋值操作符重载函数</strong> move assignment operator</p><ul><li><code>A&amp; operator=(A&amp;&amp; x)</code> //参数为右值引用类型：&amp;&amp;</li></ul><p>当用于赋值的对象是一个临时的或即将消亡的对象时，</p><ul><li>如果对象类中有转移赋值操作符重载函数，则会去调用它来实现对象的赋值。</li><li>否则将调用普通的赋值操作符重载函数来实现对象的赋值。 （注意：系统不会提供隐式的转移赋值操作符重载函数）</li></ul><p>在转移赋值操作符重载函数中实现资源的转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; x)<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span> []p; <span class="hljs-comment">//归还老空间</span><br>p = x.p; <span class="hljs-comment">//使用参数对象的空间（资源转移）</span><br>x.p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//使得参数对象不再拥有该空间</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组元素访问操作符“-”">数组元素访问操作符“[]”</h2><p>对于由具有线性关系的元素所构成的对象，可通过重载下标操作符“[]”来实现对其元素的<strong>访问</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br>......<br><span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> str[i]; &#125;<br><span class="hljs-type">char</span> <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> str[i];&#125; <span class="hljs-comment">//用于常量对象</span><br>&#125;;<br>......<br><span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>cout &lt;&lt; s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//输出：A</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* data; <span class="hljs-comment">// 存储一行元素的指针</span><br><span class="hljs-type">int</span> size; <span class="hljs-comment">// 当前行的列数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>(<span class="hljs-type">int</span> s) : <span class="hljs-built_in">size</span>(s) &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// 动态分配数组 &#125;</span><br>~<span class="hljs-built_in">Vector</span>() &#123; <span class="hljs-keyword">delete</span>[] data; <span class="hljs-comment">// 释放内存 &#125;</span><br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> data[j]; <span class="hljs-comment">// 返回对应元素的引用 &#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size; <span class="hljs-comment">// 返回当前行的列数 &#125;</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>Vector** p_data; <span class="hljs-comment">// 二维数组，指向行的 Vector 对象</span><br><span class="hljs-type">int</span> row, col; <span class="hljs-comment">// 矩阵的行数和列数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) : <span class="hljs-built_in">row</span>(r), <span class="hljs-built_in">col</span>(c)<br>&#123;<br>p_data = <span class="hljs-keyword">new</span> Vector*[row]; <span class="hljs-comment">// 为行分配内存</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)<br>&#123;<br>p_data[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>(col); <span class="hljs-comment">// 为每一行分配列的内存</span><br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">Matrix</span>()<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)<br>&#123;<br><span class="hljs-keyword">delete</span> p_data[i]; <span class="hljs-comment">// 释放每一行的内存</span><br>&#125;<br><span class="hljs-keyword">delete</span>[] p_data; <span class="hljs-comment">// 释放行的内存</span><br>&#125;<br>Vector&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br><span class="hljs-keyword">return</span> *p_data[i]; <span class="hljs-comment">// 返回对应行的 Vector</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="函数调用操作符“-”">函数调用操作符“()”</h2><p>在 C++中，把函数调用也作为一种操作符来看待：</p><ul><li>操作符为 ()，操作数为函数名及各个实参，结果为函数返回值</li><li>例如：10+f (x, y)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; value = i; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">//函数调用操作符()的重载函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x*y+value;<br>&#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//a是个对象</span><br>cout &lt;&lt; a.<span class="hljs-built_in">g</span>() &lt;&lt;endl; <span class="hljs-comment">//把a当对象来用</span><br>cout &lt;&lt; <span class="hljs-number">10</span>+<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &lt;&lt; endl;<br><span class="hljs-comment">//把a当函数来用！</span><br><span class="hljs-comment">//a(10,20)等价于：a.operator()(10,20)</span><br>......<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A&amp; f)</span> <span class="hljs-comment">//f是个对象</span></span><br><span class="hljs-function"></span>&#123; ... <span class="hljs-number">10</span>+<span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) ...<br><span class="hljs-comment">//把f当函数来使用</span><br><span class="hljs-comment">//f(10,20)等价于：f.operator()(10,20)</span><br>&#125;<br>......<br><span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//把对象a传给f</span><br></code></pre></td></tr></table></figure><p>函数对象除了具有一般函数的行为外，它还可以拥有状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomNum</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed; <span class="hljs-comment">//状态</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">RandomNum</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i) &#123; seed = i; &#125;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-comment">//函数调用操作符重载</span></span><br><span class="hljs-function"></span>&#123;<br>seed = (<span class="hljs-number">25173</span>*seed<span class="hljs-number">+13849</span>)%<span class="hljs-number">65536</span>; <span class="hljs-comment">//修改了状态</span><br><span class="hljs-keyword">return</span> seed;<br>&#125;<br>&#125;;<br>......<br><span class="hljs-function">RandomNum <span class="hljs-title">random_num</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//创建一个函数对象</span><br>... <span class="hljs-built_in">random_num</span>() ... <span class="hljs-comment">//把函数对象当作一个函数，调用它产生一个随机数</span><br></code></pre></td></tr></table></figure><p><strong>λ 表达式</strong><br>编译器：</p><ul><li>首先，隐式定义一个类：<ul><li>数据成员对应 λ 表达式中用到的环境变量（[…]），在构造函数中用环境变量对它们进行初始化。</li><li>按相应 λ 表达式的函数功能重载了函数调用操作符。</li></ul></li><li>然后，创建上述类的一个临时对象（设为 obj）</li><li>最后，在使用上述 λ 表达式的地方用 obj 来替代：<ul><li>作用于实参进行函数调用对于：<code>cout &lt;&lt; [...](int x)-&gt;int &#123; ....... &#125;(3);</code> 替换成：<code>cout &lt;&lt; obj(3);</code></li><li>传给其它函数对于：<code>f([...](int x)-&gt;int &#123; ....... &#125;); </code> 替换成：<code>f (obj);</code></li></ul></li></ul><h2 id="间接类成员访问操作符“-”-智能指针">间接类成员访问操作符“-&gt;” 智能指针</h2><p>“-&gt;”为一个双目操作符：</p><ul><li>第一个操作数为一个指向类或结构的指针。</li><li>第二个操作数为第一个操作数所指向的类或结构的成员。<br>例如:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>A *p = &amp;a;<br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//通过p访问对象a的成员函数f</span><br></code></pre></td></tr></table></figure><p>可以针对某个类重载“-&gt;”操作符，这样就可以把该类的对象当指针来用，实现一种智能指针（smart pointers）</p><ul><li>通过智能指针去访问它指向的对象成员之前能做一些额外的事情。（在操作符-&gt;重载函数中实现）</li></ul><p><img src="2025031586.png" alt=""></p><p>在 C++中，智能指针主要用于对动态对象的空间进行管理。在 C++标准库（基于模板实现）提供了一些智能指针类型，其中包括：</p><ul><li>shared_ptr：带引用计数，利用它能够实现动态对象空间的自动回收。</li><li>unique_ptr：独占动态对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>~<span class="hljs-built_in">A</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;In A&#x27;s destructor\n&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">1</span>))</span></span>; <span class="hljs-comment">//创建第一个动态对象，其引用计数为1</span><br>p1-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用第一个动态对象的成员函数f，输出1</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">2</span>))</span></span>; <span class="hljs-comment">//创建第二个动态对象，其引用计数为1</span><br>p2-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用第二个动态对象的成员函数f，输出2</span><br>p1 = p2; <span class="hljs-comment">//第一个对象的引用计数减1（变成0），第一个对象自动消亡</span><br><span class="hljs-comment">//第二个对象的引用计数加1（变成2）</span><br>......<br>p2 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1（变成1）</span><br>p1-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用第二个动态对象的成员函数f，输出2</span><br>p1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1(变成0)，第二个对象自动消亡</span><br>......<br><span class="hljs-function">unique_ptr&lt;A&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">3</span>))</span></span>; <span class="hljs-comment">//创建第三个动态对象</span><br><span class="hljs-function">unique_ptr&lt;A&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">4</span>))</span></span>; <span class="hljs-comment">//创建第四个动态对象</span><br>p3 = p4; <span class="hljs-comment">//Error，第四个对象被p4独占</span><br>p3 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第三个对象消亡</span><br>p4 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第四个对象消亡</span><br><br></code></pre></td></tr></table></figure><h2 id="操作符-new-与-delete-的重载">操作符 new 与 delete 的重载</h2><p>操作符 new 必须作为静态的成员函数来重载 （static 说明可以不写），其格式为：</p><ul><li><code>void *operator new(size_t size);</code></li><li>返回类型必须为 void *</li><li>参数 size 表示对象所需空间的大小，其类型为 size_t（unsigned int）</li></ul><p>例：把动态对象初始化为全‘0’</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span> *p=<span class="hljs-built_in">malloc</span>(size); <span class="hljs-comment">//调用系统堆空间分配操作。</span><br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,size); <span class="hljs-comment">//把申请到的堆空间初始化为全“0”。</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于 new 的重载函数，除了对象空间大小参数以外，它也可以带有其它参数：</p><ul><li>void *operator new (size_t size,…);</li></ul><p>对带有其它参数的 new 重载函数，其使用格式为：</p><ul><li>p = new (…) A (…);</li><li>前者… 表示提供给 new 重载函数的其它参数</li><li>后者… 表示提供给 A 类构造函数的参数</li></ul><p>例：在非“堆区”为动态对象分配空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; x=i; y=j; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> p; &#125;<br>&#125;;<br>......<br><span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(A)];<br>A *p=<span class="hljs-built_in">new</span> (buf) <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//动态对象的空间分配为buf</span><br>......<br>p-&gt;~<span class="hljs-built_in">A</span>(); <span class="hljs-comment">//使得p所指向的对象消亡。</span><br><span class="hljs-comment">//不能用系统的delete，可以用自己重载的delete</span><br></code></pre></td></tr></table></figure><p>操作符 delete 也必须作为静态的成员函数来重载 （static 说明可以不写），其格式为：</p><ul><li><code>void operator delete (void *p, size_t size);</code></li><li>返回类型必须为 void。</li><li>第一个参数类型为 void *，指向对象的内存空间。</li><li>第二个参数可有可无，如果有，则必须是 size_t 类型。</li><li>重载后，操作符 delete 的使用格式与未重载的相同。</li></ul><p>例：重载操作符 new 与 delete 来管理程序中某类动态对象的堆空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123; ...... <span class="hljs-comment">//类A原有的成员说明</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span></span>;<br> <span class="hljs-keyword">private</span>:<br> A *next; <span class="hljs-comment">//用于组织A类对象自由空间链表</span><br> <span class="hljs-type">static</span> A *p_free; <span class="hljs-comment">//用于指向A类对象的自由空间链表头</span><br>&#125;;<br>A *A::p_free=<span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM=<span class="hljs-number">32</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *A::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (p_free == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//创建第一个A类动态对象</span><br>&#123; <span class="hljs-comment">//申请NUM个A类对象的大空间。</span><br>p_free = (A *)<span class="hljs-built_in">malloc</span>(size*NUM); <span class="hljs-comment">//一个动态数组</span><br><span class="hljs-comment">//在大空间上建立自由空间链表（链表结点初始是连续的）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NUM<span class="hljs-number">-1</span>; i++)<br>p_free[i].next = &amp;p_free[i<span class="hljs-number">+1</span>];<br>p_free[NUM<span class="hljs-number">-1</span>].next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//从链表中给当前动态对象分配空间</span><br> A *p=p_free;<br> p_free = p_free-&gt;next;<br> <span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,size); <span class="hljs-comment">//可由构造函数完成</span><br> <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> A::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//把p指向的空间还到自由空间链表中</span><br>((A *)p)-&gt;next = p_free;<br>p_free = (A *)p;<br>&#125;<br>......<br>A *q1=<span class="hljs-keyword">new</span> A;<br>A *q2=<span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">delete</span> q1;<br></code></pre></td></tr></table></figure><p><img src="2025031509.png" alt=""></p><p>C++标准库（基于模板实现）提供了一个函数 make_shared，它能创建自带引用计数的动态对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; ...... &#125;<br>&#125;;<br><span class="hljs-comment">//创建第一个动态对象（其x为1，由p1指向），该对象的引用计数为1</span><br>shared_ptr&lt;A&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;A&gt;(<span class="hljs-number">1</span>);<br>p1-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用p1指向的对象的成员函数f</span><br><span class="hljs-comment">//创建第二个动态对象（其x为2，由p2指向），该对象的引用计数为1</span><br>shared_ptr&lt;A&gt; p2=<span class="hljs-built_in">make_shared</span>&lt;A&gt;(<span class="hljs-number">2</span>);<br>p1 = p2; <span class="hljs-comment">//第一个对象的引用计数减1（变成0），第一个对象自动消亡</span><br><span class="hljs-comment">//第二个对象的引用计数加1（变成2）</span><br>p2 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1（变成1）</span><br>p1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1(变成0),第二个对象自动消亡</span><br></code></pre></td></tr></table></figure><h2 id="自定义类型转换操作符">自定义类型转换操作符</h2><p><img src="2025031516.png" alt=""><br><img src="2025031504.png" alt=""></p><p>歧义问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j) &#123; x = i; y = j; &#125;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x+y; &#125;<br><span class="hljs-keyword">friend</span> A <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> A &amp;a1, <span class="hljs-type">const</span> A &amp;a2);<br>&#125;;<br>......<br>A a;<br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>... (a + i) ... <span class="hljs-comment">//是把a转换成int呢，还是把i转换成A呢？</span><br></code></pre></td></tr></table></figure><p><img src="2025031564.png" alt=""><br><img src="2025031512-1.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-3-类的成员函数和友元</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h1>常成员函数及静态成员</h1><h2 id="常成员函数">常成员函数</h2><ul><li>为了防止在一个获取对象状态的成员函数中无意中修改对象数据成员的值，可以把它说明成常成员函数</li><li>编译器一旦发现在常成员函数中修改数据成员的值，将会报错</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123; year=y; month=m; day=d; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> day; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> month; &#125;<br></code></pre></td></tr></table></figure><ul><li>对常量对象只能调用类中的常成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>......<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> Date &amp;d)</span> <span class="hljs-comment">//d引用的是个常量对象！</span></span><br><span class="hljs-function"></span>&#123;<br>... d.<span class="hljs-built_in">get_day</span>() ... <span class="hljs-comment">//OK</span><br>... d.<span class="hljs-built_in">get_month</span>() ... <span class="hljs-comment">//OK</span><br>... d.<span class="hljs-built_in">get_year</span>() ... <span class="hljs-comment">//OK</span><br>d.<span class="hljs-built_in">set</span> (<span class="hljs-number">2011</span>,<span class="hljs-number">3</span>,<span class="hljs-number">23</span>); <span class="hljs-comment">//Error</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态数据成员">静态数据成员</h2><ul><li>采用静态数据成员可以更好地实现<strong>同一个类的不同对象之间的数据共享</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">// 静态数据成员声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;y = x; x++; &#125; <span class="hljs-comment">// 访问共享的x</span><br>&#125;;<br><span class="hljs-type">int</span> A::x=<span class="hljs-number">0</span>; <span class="hljs-comment">// 静态数据成员定义及初始化</span><br>A a, b;<br>a.<span class="hljs-built_in">f</span>();<br>b.<span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure><ul><li>类的静态数据成员对该类的所有对象只有一个拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increase_all</span><span class="hljs-params">()</span> </span>&#123; x++; y++; shared++; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_all</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x+y+shared; &#125;<br>......<br>&#125;;<br><span class="hljs-type">int</span> A::shared=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="静态成员函数">静态成员函数</h2><ul><li>静态成员函数只能访问类的静态成员</li><li>静态成员函数没有隐藏的 this 函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123;x = y = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_shared</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> shared;&#125; <span class="hljs-comment">// 静态成员函数</span><br>&#125;;<br><span class="hljs-type">int</span> A::shared = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ul><li>静态成员除了通过对象来访问外，也可以直接通过类来访问。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a;<br>cout &lt;&lt; a.<span class="hljs-built_in">get_shared</span>();<br>cout &lt;&lt; A::<span class="hljs-built_in">get_shared</span>();<br></code></pre></td></tr></table></figure><h1>友元</h1><p>某些情况下，为了提高在类的外部对类数据成员的访问效率，在 C++中，</p><ul><li>可以指定某些与一个类密切相关的、又<strong>不适合</strong>作为该类成员的程序实体能直接访问该类的非 public 成员，这些程序实体称为该类的友元。</li><li>友元是<strong>数据保护和数据访问效率</strong>之间的一种折衷方案。</li></ul><p>友元需要在类中用 friend 显式指出，它们可以是</p><ul><li>全局函数</li><li>其它类的所有成员函数</li><li>其它类的某个成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 全局函数func可访问x</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 类B的所有成员函数可访问x</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 类C的成员函数f可访问x</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>友元不是一个类的成员。</li><li>友元关系具有不对称性。例如：假设 B 是 A 的友元，如果没有显式指出 A 是 B 的友元，则 A 不是 B 的友元。</li><li>友元也不具有传递性。例如：假设 C 是 B 的友元、B 是 A 的友元，如果没有显式指出 C 是 A 的友元，则 C 不是 A 的友元。<br><img src="2025031500.png" alt=""></li></ul><p>multiply 的实现 2<br><img src="2025031501.png" alt=""><br><img src="2025031595-1.png" alt=""></p><h1>类作为模块</h1><p>一个模块包含接口和实现两部分：</p><ul><li>接口：是指在模块中定义的、可以被其它模块使用的一些程序实体的声明描述。</li><li>实现：是指在模块中定义的所有程序实体的具体实现描述。</li></ul><p>在面向对象程序中，类是一个自然的模块划分单位，一个类构成一个模块，模块边界比较清晰。</p><p>C++程序的一个模块由两部分构成：</p><ul><li>接口：类的定义，存放在一个. h 文件中</li><li>实现：类的实现（包括类的定义和在类外定义的成员函数），存放在一个. cpp 文件中。<br><img src="2025031517.png" alt=""></li></ul><h2 id="Demeter-法则">Demeter 法则</h2><p>一个类的成员函数</p><ul><li>除了能访问自身类结构的直接子结构（本类的数据成员）外，不能以任何方式依赖于任何其它类的结构。</li><li>只应向某个有限集合中的对象发送消息。</li></ul><p>核心思想：“仅与你的直接朋友交谈！”<br><img src="2025031587.png" alt=""></p><p>类表达形式</p><p>对于类 C 中的任何成员函数 M，M 中只能向以下类的对象发送消息：</p><ul><li>类 C 本身。</li><li>成员函数 M 的参数类。</li><li>M 或 M 所调用的成员函数中创建的对象所属的类。</li><li>全局对象所属的类。</li><li>类 C 的成员对象所属的类。</li></ul><p>对象表达形式</p><p>对于类 C 中的任何成员函数 M，M 中只能向以下的对象发送消息：</p><ul><li>this 指向的对象。</li><li>成员函数 M 的参数对象。</li><li>M 或 M 所调用的成员函数所创建的对象。</li><li>全局变量中包含的对象。</li><li>类 C 的成员对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-2-对象与类</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1>对象与类</h1><h2 id="类成员">类成员</h2><h3 id="数据成员-：">数据成员 ：</h3><p>对对象所包含的数据描述，它们可以是常量和变量，类型可以是任意的 C++类型（void 除外）</p><p>在类中说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的<strong>指针或引用</strong>类型。<br><img src="2025031556.png" alt=""></p><h3 id="成员函数">成员函数</h3><ul><li>对对象包含的数据所能实施的操作描述。</li><li>成员函数名是可以重载的，它遵循一般函数名的重载规则。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::f</span><span class="hljs-params">()</span> </span>&#123;...&#125; <span class="hljs-comment">// 类名受限</span><br></code></pre></td></tr></table></figure><h3 id="类成员的访问控制">类成员的访问控制</h3><ul><li>public 访问不受限制</li><li>private 只能在本类和友元中访问</li><li>protected 只能在本类、友元和派生类的代码中访问</li></ul><h2 id="对象">对象</h2><ul><li>类属于类型范畴的程序实体，它一般存在于静态的程序（编译程序看到的）中。</li><li>动态的面向对象程序（运行中的）则是由对象构成。</li><li>对象在程序运行时创建。</li></ul><h3 id="创建和标识">创建和标识</h3><p>直接方式：</p><ul><li>对象在进入相应变量的生存期时创建，通过变量名来标识和访问。相应变量的生存期结束时，对象消亡。</li></ul><p>间接方式：</p><ul><li>在程序运行时刻，用 new 操作来创建对象（称为动态对象），用 delete 操作来撤消它（使之消亡）。动态对象需要通过指针来标识和访问。</li></ul><h3 id="成员对象">成员对象</h3><ul><li>对于类的数据成员，其类型可以是另一个类。即， 一个对象可以包含另一个对象，后者称为成员对象。</li><li>成员对象跟随包含它的对象一起创建和消亡。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;...&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a; <span class="hljs-comment">// 成员对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的操作">对象的操作</h3><ul><li>对于创建的一个对象，需要通过向它发送消息（调用对象类中定义的某个 public 成员函数）来对它进行操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br>a.<span class="hljs-built_in">f</span>();<br>A *p = <span class="hljs-keyword">new</span> A; <span class="hljs-comment">// 动态对象</span><br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// (*p).f()</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在类的外部访问类的成员时要受到类成员访问控制的限制</li><li>可以对同类对象进行赋值</li><li>把对象作为参数传给函数</li><li>把对象作为函数的返回值<br><img src="2025031550.png" alt=""></li></ul><h1>this 指针</h1><ul><li>类中描述的数据成员（静态数据成员除外）对该类的每个对象分别有一个拷贝。</li><li>成员函数对该类所有对象只有一个拷贝 - 类的每一个成员函数（静态成员函数除外）都有一个隐藏的形参 this，其类型为该类<strong>对象的指针</strong>；在成员函数中对类成员的访问是通过 this 来进行的。 - 当通过对象访问类的成员函数时，将会把<strong>相应对象的地址</strong>传给成员函数的参数 this。<br>指向成员函数的指针：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>&#125;<br><br><span class="hljs-built_in">void</span> (*p)(<span class="hljs-type">int</span>) = &amp;A::f1; <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">void</span> (A::*p)(<span class="hljs-type">int</span>) = &amp;A::f1; <span class="hljs-comment">// 或者 auto p = &amp;A::f1;</span><br>A a;<br>(a.*p)(<span class="hljs-number">10</span>)； <span class="hljs-comment">// 调用a.f1</span><br>p = &amp;A::f2;<br>(a.*p)(<span class="hljs-number">10</span>); <span class="hljs-comment">// 调用a.f2</span><br></code></pre></td></tr></table></figure><ul><li>一般情况下，在类的成员函数中访问类的成员时不必显式使用 this 指针，编译程序会自动加上</li><li>但如果成员函数中要把 this 所指向的对象作为整体来操作，则需要显式地使用 this 指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A *p)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;x = i; <span class="hljs-built_in">func</span>(<span class="hljs-keyword">this</span>)&#125;<br>&#125;<br>A a, b;<br>a.<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 在g中调用func(&amp;a)</span><br>b.<span class="hljs-built_in">g</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 在g中调用func(&amp;b)</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">A&amp; <span class="hljs-title">inc1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>++x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回对象自己</span><br>&#125;<br><span class="hljs-function">A <span class="hljs-title">inc2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br> ++x;<br> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回对象的备份</span><br> &#125;<br>&#125;<br><br>A a;<br>a.<span class="hljs-built_in">inc1</span>().<span class="hljs-built_in">inc1</span>(); <span class="hljs-comment">//把a.x增加了2，第一个inc1返回的是a</span><br>a.<span class="hljs-built_in">inc2</span>().<span class="hljs-built_in">inc2</span>(); <span class="hljs-comment">//把a.x增加了1，第一个inc2返回的是a的备份</span><br></code></pre></td></tr></table></figure><h1>对象的初始化与消亡</h1><h2 id="构造函数">构造函数</h2><ul><li>它是类的特殊成员函数，名字与类名相同、无返回值类型</li><li>创建对象时，构造函数会被自动调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123;x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数可以重载，其中，不带参数的（或所有参数都有默认值的）构造函数被称为默认构造函数</li><li>在程序中也可以通过类的构造函数来创建一些临时对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A a)</span></span>&#123;...&#125;<br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><ul><li>对象创建后，不能再调用构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a;<br>a.<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><p><strong>成员初始化表</strong></p><ul><li>初始化次序由它们在类定义中的描述次序来决定</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> y;<br><span class="hljs-type">int</span>&amp; z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>():<span class="hljs-built_in">z</span>(x), <span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员初始化表</span><br>&#123;<br>x = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="析构函数">析构函数</h2><ul><li>没有返回类型、不带参数、不能被重载</li><li>一个对象消亡时，系统在收回它的内存空间之前，将会自动调用对象类中的析构函数</li><li>可以在析构函数中完成对象被删除前的一些清理工作</li><li>一般情况下，类中不需要自定义析构函数，但如果对象创建后， 自己又<strong>额外申请</strong>了资源（如：额外申请了内存空间），则可以自定义析构函数来归还它们</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(s);<br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(str, s);<br>&#125;<br>~<span class="hljs-built_in">String</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 归还额外申请的空间</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>除了在对象消亡时会被自动调用外，也可以在对象生存期内显式调用，这时并不是让对象消亡，而是暂时归还对象额外申请的资源</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>s<span class="hljs-number">1.</span>~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//把字符串s1清空，对象并未消亡！</span><br>s1 <span class="hljs-comment">//仍然可以使用对象s1</span><br></code></pre></td></tr></table></figure><h3 id="成员对象的初始化和消亡处理">成员对象的初始化和消亡处理</h3><ul><li>通常是调用成员对象类的默认构造函数</li><li>如果要调用成员对象类的非默认构造函数，需要在包含成员对象的对象类的构造函数成员初始化表中显式指出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()&#123;x = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123;x = i;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123;y = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) &#123;y = i;&#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j): <span class="hljs-built_in">a</span>(j) &#123;y = i;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建时：</p><ul><li>先调用本身类的构造函数，但在<strong>进入函数体之前</strong>， 会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体</li><li>若包含多个成员对象，这些成员对象构造函数的调用次序则按它们在本对象类中的说明次序进行<br>消亡时：</li><li>先调用本身类的析构函数，本身类析构函数的函数体<strong>执行完之后</strong>，再去调用成员对象类的析构函数</li><li>如果有多个成员对象，则成员对象析构函数的调用次序按它们在本对象类中的<strong>说明次序的逆序</strong>进行</li></ul><h1>拷贝构造函数&amp;转移构造函数</h1><h2 id="拷贝构造函数">拷贝构造函数</h2><ul><li>若一个构造函数的参数类型为本类的引用，则称它为拷贝构造函数</li><li>在创建一个对象时，若用另一个同类型的对象对其初始化，将会调用对象类中的拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>();<br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a); <span class="hljs-comment">// 拷贝构造函数</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>调用类的拷贝构造函数的情况：</p><ul><li>创建对象时显式指出</li><li>把对象作为值参数传给函数时</li><li>把对象作为函数的返回值时</li></ul><h3 id="隐式拷贝构造函数">隐式拷贝构造函数</h3><ul><li>在程序中，如果没有为某个类提供拷贝构造函数，则编译器将会为其生成一个隐式拷贝构造函数</li><li>隐式拷贝构造函数将逐个成员进行拷贝初始化<ul><li>对于非对象成员：它采用通常的拷贝操作</li><li>对于成员对象：则调用成员对象类的拷贝构造函数来对成员对象进行初始化（递归定义）</li></ul></li></ul><h3 id="自定义拷贝构造函数">自定义拷贝构造函数</h3><ul><li>在一些特殊情况下，必须要自定义拷贝构造函数，否则，将会产生设计者未意识到的严重的程序错误</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(s);<br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len<span class="hljs-number">+1</span>];<br><span class="hljs-built_in">strcpy</span>(str,s);<br>&#125;<br>~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">delete</span> []str; len=<span class="hljs-number">0</span>; str=<span class="hljs-literal">NULL</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>隐式的拷贝构造函数将会使得 s1 和 s2 的成员指针 str 指向同一块内存区域<br><img src="2025031521.png" alt=""></li></ul><h2 id="转移构造函数">转移构造函数</h2><h3 id="右值引用类型">右值引用类型&amp;&amp;</h3><p>右值引用类型（用&amp;&amp;表示）</p><ul><li>当函数的参数类型为右值引用类型时，它将接受临时对象或即将消亡的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp; x)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp;&amp; x)</span> </span>&#123;...&#125;<br>A a;<br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">// 调用f(A&amp;)</span><br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">A</span>()); <span class="hljs-comment">// 调用f(A&amp;&amp;) 因为A(创建的是一个临时对象)</span><br></code></pre></td></tr></table></figure><h3 id="move-constructor">move constructor</h3><p>转移构造函数其参数类型为右值引用</p><ul><li><code>A(A&amp;&amp; x)</code><br>当用一个临时对象或即将消亡的对象去初始化另一个对象时，</li><li>如果对象类中有转移构造函数，则会去调用转移构造函数进行对象初始化。</li><li>否则去调用普通拷贝构造函数进行对象初始化。（注意： 系统不会提供隐式转移构造函数！）</li></ul><p>可在转移构造函数中实现资源的转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>(A&amp;&amp; x)<br>&#123;<br>p = x.p; <span class="hljs-comment">//把参数对象x的p所指向的空间作为新对象的p所指向的空间（资源转移）</span><br>x.p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//使得参数对象x的p不再拥有原来所指向的空间。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不再为返回值对象额外申请空间和内容复制</li><li>对象 t 消亡时也不再归还原来申请的空间</li></ul><h3 id="move">move</h3><p>如何把一个左值对象传给一个实现资源转移的函数？</p><ul><li>可以用 STL 中的函数 move 把一个左值类型转换成右值类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp; x)</span> </span>&#123; ...... &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp;&amp; x)</span> </span>&#123; ...... &#125; <span class="hljs-comment">//该函数实现资源转移</span><br>......<br>A a; <span class="hljs-comment">//a为一个左值对象</span><br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">//调用f(A&amp;)</span><br><span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">move</span>(a)); <span class="hljs-comment">//把a转成右值，它会调用f(A&amp;&amp;)</span><br><span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">//调用拷贝构造函数实现资源的复制</span><br><span class="hljs-function">A <span class="hljs-title">a2</span><span class="hljs-params">(std::move(a))</span></span>; <span class="hljs-comment">//调用转移构造函数实现资源的转移</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-1-抽象封装</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1>λ 表达式</h1><ul><li>C++11 以后的国际标准为 C++提供了一种匿名函数机制――λ 表达式（lambda expression），利用它可以把函数的定义和使用二者合而为一。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求x^2定积分</span><br><span class="hljs-type">double</span> integrate（<span class="hljs-built_in">double</span>(*fp)(<span class="hljs-type">double</span>), <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b）;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x*x&#125;;<br><span class="hljs-built_in">integrate</span>(square, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// lambda表达式</span><br><span class="hljs-built_in">integrate</span>([](<span class="hljs-type">double</span> x)-&gt;<span class="hljs-type">double</span>&#123;<span class="hljs-keyword">return</span> x*x&#125;, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="2025031590.png" alt=""><br><img src="2025031575.png" alt=""><br><img src="2025031599.png" alt=""><br>使用方式：</p><ul><li>直接调用它定义的函数</li><li>把它定义的函数作为参数传给另一个函数（主要）</li></ul><p>ps: 编译时在内部给 lambda 表达式函数名，再使用时 call</p><h1>数据抽象与封装</h1><p>抽象：该程序实体<strong>外部</strong>可观察到的行为，使用者不考虑该程序实体的内部是如何实现的（复杂度控制）</p><p>封装：把该程序实体内部的具体实现细节对使用者隐藏起来，值对外提供一个接口（信息保护）</p><h2 id="过程抽象与封装">过程抽象与封装</h2><p>过程抽象</p><ul><li>用一个名字来代表一段完成一定功能的程序代码，代码的使用者只需要知道代码的名字以及相应的功能， 而不需要知道对应的程序代码是如何实现的。</li></ul><p>过程封装</p><ul><li>把命名代码的具体实现<strong>隐藏起来</strong>（对使用者不可见， 或不可直接访问），使用者只能通过代码名字来使用相应的代码。</li><li>命名代码所需要的数据是通过<strong>参数</strong>来获得，计算结果通过返回值机制返回。<blockquote><p>[!note]+<br>过程抽象与封装是基于功能分解与复合的过程式程序设计的基础。</p><ul><li>实现了过程抽象与封装</li><li>数据表示是公开的，缺乏保护</li></ul></blockquote></li></ul><h2 id="数据抽象与封装">数据抽象与封装</h2><p>数据抽象</p><ul><li>只描述对数据能实施哪些操作以及这些操作之间的关系，数据的使用者不需要知道数据的具体表示形式 （数组或链表等）。</li></ul><p>数据封装</p><ul><li>把数据及其操作作为一个整体（封装体）来进行实现， 其中，数据的具体表示被隐藏起来（使用者不可见， 或不可直接访问），对数据的访问（使用）只能通过封装体对外接口中提供的操作来完成。<blockquote><p>[!note]+<br>数据抽象与封装是面向对象程序设计的基础， 其中的对象体现了数据抽象与封装。</p></blockquote></li></ul><p>以栈为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> STACK_SIZE=<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> buffer[STACK_SIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125;;<br>Stack::<span class="hljs-built_in">Stack</span>() &#123;<br>    top = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == STACK_SIZE - <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Stack is full&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    buffer[++top] = e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    e = buffer[top--];<br>&#125;<br><br><span class="hljs-comment">// 链表</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack1</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> content;<br>        Node *next;<br>    &#125;;<br>    Node *top;<br>&#125;;<br><br>Stack1::<span class="hljs-built_in">Stack1</span>() &#123;<br>    top = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack1::push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>    Node *p = <span class="hljs-keyword">new</span> Node;<br>    <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Out of space&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    p-&gt;content = e;<br>    p-&gt;next = top;<br>    top = p;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack1::pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node *p = top;<br>    top = top-&gt;next;<br>    e = p-&gt;content;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!note]+<br>改变栈的数据表示对使用者没有任何影响</p></blockquote><h1>面向对象程序设计</h1><p><img src="2025031512.png" alt=""></p><h2 id="基本内容">基本内容</h2><p><img src="2025031520-1.png" alt=""><br><img src="2025031573.png" alt=""><br><img src="2025031519.png" alt=""></p><h2 id="好处">好处</h2><p>影响软件开发效率和软件质量的因素主要包括：</p><ul><li>抽象（控制复杂度）</li><li>封装（保护信息）</li><li>模块化（组织和管理大型程序）</li><li>软件复用（缩短开发周期）</li><li>可维护性（延长软件寿命）</li><li>软件模型的自然度（缩小解题空间与问题空间之间的语义间隙，实现从问题到解决方案的自然过渡</li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-0-Introduction</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-Introduction/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-Introduction/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!tip]+ 考核<br>作业 10% + 上机 25% + 项目 15% + 期末 50%</p></blockquote><h2 id="预备知识">预备知识</h2><p><strong>函数的副作用</strong><br>指在函数执行过程中，除了返回值之外，对外部状态或环境产生的影响。这些影响可能包括：</p><ul><li>修改全局变量：函数可能会改变全局作用域中的变量值。</li><li>修改参数：如果参数是可变对象（如列表或字典），函数可能会直接修改这些对象。</li><li>输入/输出操作：函数可能会进行文件读写、打印输出等操作。</li><li>抛出异常：函数可能会引发异常，影响程序的控制流。</li><li>网络请求：函数可能会进行网络请求，改变外部系统的状态。</li></ul><p>副作用的存在使得函数的行为不再是完全可预测的，因为相同的输入可能导致不同的输出，具体取决于函数执行时的外部状态。这与“纯函数”相对，后者在相同输入下总是返回相同的输出，并且不产生副作用。</p><p><strong>数据类型-联合</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-type">int</span> intValue;<br>    <span class="hljs-type">float</span> floatValue;<br>    <span class="hljs-type">char</span> charValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>特点</p><ul><li>内存节省：由于所有成员<strong>共享同一内存</strong>，联合的大小等于其最大成员的大小。</li><li>只能存储一个值：在任何时刻，联合只能存储一个成员的值，设置一个成员的值会覆盖其他成员的值。</li><li>类型安全：使用联合时，程序员需要小心，以确保在访问联合成员时，所访问的成员是最近设置的成员。</li></ul><p><strong>数据类型-枚举</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Day</span> &#123;</span><br>    Sunday,<br>    Monday,<br>    Tuesday,<br>    Wednesday,<br>    Thursday,<br>    Friday,<br>    Saturday<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>必须用指针的情况</strong>：</p><ul><li>提高参数传递效率（直接传递地址，不用形参）</li><li>访问动态变量</li></ul><p><strong>static 的使用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 局部使用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只初始化一次</span><br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, count);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    function(); <span class="hljs-comment">// 输出 Count: 1</span><br>    function(); <span class="hljs-comment">// 输出 Count: 2</span><br>    function(); <span class="hljs-comment">// 输出 Count: 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 全局使用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalVar = <span class="hljs-number">0</span>; <span class="hljs-comment">// 仅在此文件可见</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    globalVar++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    increment();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Global Variable: %d\n&quot;</span>, globalVar); <span class="hljs-comment">// 输出 Global Variable: 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-对-C-的扩充">C++对 C 的扩充</h2><h3 id="内联函数">内联函数</h3><p>宏定义的不足：</p><ul><li>需要加上很多括号</li><li>有时会出现重复计算</li><li>替换时不进行参数类型检查和转换<br>内联函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议编译程序把该函数的函数体展开到调用点，函数调用时直接执行函数体。<br>P.S 递归函数往往不能作为内联函数；内联函数名具有文件作用域</p><h3 id="名空间作用域">名空间作用域</h3><ul><li>把全局标识符定义在一个名空间中，其作用域为该名空间。</li><li>当在一个名空间外部需要使用该名空间中定义的全局标识符时，需要用该名空间的名字来修饰或受限。</li></ul><h3 id="动态变量">动态变量</h3><p><em>p1</em> = <strong>new</strong> int;</p><p><strong>delete</strong> <em>p1</em>;</p><p>对于普通的动态变量，C++与 C 的做法区别不大，但如果创建的是动态对象，则两者是有差别的：</p><ul><li>除了为对象分配空间外，new 还会去调用<strong>对象类的构造函数进行对象初始化</strong>， malloc（calloc）则否。</li><li>除了收回为对象分配的空间外，delete 还会去调用对象类的析构函数进行对象消亡后的清理，free 则否。</li></ul><p>C/C++动态变量的问题</p><ul><li>没有自动废区收集功能，动态变量需要程序<strong>显式用 free 或 delete 撤销</strong>，否则会出现内存泄漏问题！</li></ul><h3 id="引用类型">引用类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> &amp;y=x; <span class="hljs-comment">//y为引用类型的变量，它是x的别名</span><br>y = <span class="hljs-number">10</span>;  <span class="hljs-comment">//通过y访问x，效果上等价于：x = 10;</span><br></code></pre></td></tr></table></figure><h4 id="用处">用处</h4><p>提高函数参数传递效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A &amp;x)</span></span>&#123;<span class="hljs-comment">// x使用实参的内存空间</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>保证形参访问的永远是实参数据<br>保证通过形参访问的永远是实参数据<br><img src="2025031547.png" alt=""></p><blockquote><p>[!note]<br>即通过引用类型不可以在函数体内指向其他位置，而普通指针可以（但可以通过 const 达到引用类型的效果</p></blockquote><h4 id="如何防止函数通过指针和引用类型的形参修改实参数据">如何防止函数通过指针和引用类型的形参修改实参数据</h4><p><strong>const</strong><br><img src="2025031553.png" alt=""></p><h4 id="函数返回值可以为引用类型">函数返回值可以为引用类型</h4><p><img src="2025031520.png" alt=""></p><blockquote><p>[!warning]+<br>不要把局部量的引用返回给调用者，因为函数返回后，局部量的内存空间已无效，后续操作中可能又分配给其它变量</p></blockquote><p><img src="2025031553-1.png" alt=""></p><h3 id="函数名重载">函数名重载</h3><blockquote><p>[!quote]+ 定义<br>在相同的作用域中，可以用同一个名字定义多个不同的函数，这时，要求定义的这些函数应具有不同的参数（参数个数或类型要有所不同）。</p></blockquote><h4 id="绑定">绑定</h4><p>定义：确定一个对重载函数的调用对应着哪一个重载函数定义的过程</p><h5 id="精确匹配">精确匹配</h5><p>实参与形参的类型完全相同，或者对实参进行“微小”的类型转换后与形参类型相同：</p><ul><li>数组变量名-&gt;数组第一个元素的内存地址</li><li>函数名-&gt;函数的内存首地址</li></ul><h5 id="提升匹配">提升匹配</h5><p>先对实参进行下面的类型提升，然后进行精确匹配：</p><ul><li>按整型提升规则提升实参类型</li><li>把 float 类型实参提升到 double</li><li>把 double 类型实参提升到 long double</li></ul><h5 id="标准转换匹配">标准转换匹配</h5><p>先进行下面的标准转换，然后进行精确匹配：</p><ul><li>任何算术类型可以互相转换</li><li>枚举类型可以转换成任何算术类型</li><li>零可以转换成任何算术类型或指针类型</li><li>任何类型的指针可以转换成 void *<blockquote><p>[!warning]+<br>每个标准转换都是平等的，不存在哪个优先：<br>如果存在多个标准转换后能精确匹配，则失败！ （具有歧义）</p></blockquote></li></ul><h5 id="绑定失败">绑定失败</h5><p>不存在匹配 or 存在多个匹配</p><p>解决办法是：</p><ul><li>对实参进行显式类型转换，如，<ul><li>print ((char) 1) 或 print ((double) 1)</li></ul></li><li>增加额外的重载，如，<ul><li>增加一个重载函数定义： void print (int);</li></ul></li></ul><h3 id="变量初始化">变量初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x&#123;<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// int x(5);</span><br><span class="hljs-type">int</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-type">int</span> x; <span class="hljs-type">int</span> y;&#125; point&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="基于范围的-for">基于范围的 for</h3><p>C++语言注重程序的效率，运行时刻不对数组元素下标越界进行检查，从而造成下面错误代码的执行不会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>], sum;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">10</span>; i++) cin &gt;&gt; a[i]; sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">10</span>; i++) sum += a[i];<br></code></pre></td></tr></table></figure><p>为了方便、可靠地实现一些简单地对一维数组元素进行遍历的操作，在 C++新国际标准（C++11 以后）中提供了一种<strong>基于范围的 for</strong> 语句，它能自动遍历数组元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;n: a) cin &gt;&gt; n;<br></code></pre></td></tr></table></figure><h3 id="类型自动判断：auto">类型自动判断：auto</h3><p>定义一个变量时可以不指定它的类型，由编译器根据初始化的值自动确定它的类型。例如：</p><ul><li>auto x=1+2 * 3.4; //编译程序自动确定 x 的类型为 double</li></ul><p>P.S: 自动生存期的局部变量不能再显式地用 auto 来指出</p><h3 id="字符串常量与字符指针">字符串常量与字符指针</h3><ul><li>按 C 语言，可以；按 C++语言，不可以！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span> *p)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">char</span> x[])</span></span>&#123;...&#125;<br><br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;abcd&quot;</span>; <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;1234&quot;</span>); <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">g</span>(<span class="hljs-string">&quot;1234&quot;</span>); <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><blockquote><p>[!warning]+<br>C++需要指向常量的指针<br>即使用 const char *p = “abcd” 或者 f (const char *p) 是可以的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器配置</title>
    <link href="/2025/03/12/Docker%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/03/12/Docker%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="新建容器">新建容器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-it</span> <span class="hljs-literal">--gpus</span> all <span class="hljs-literal">--name</span> my<span class="hljs-literal">-pytorch-env</span> <span class="hljs-literal">-v</span> ~/:/workspace ubuntu:<span class="hljs-number">22.04</span> /bin/bash<br></code></pre></td></tr></table></figure><ol><li><strong><code>docker run</code></strong><ul><li>此命令用于创建并启动一个新的容器实例。</li></ul></li><li><strong><code>-it</code></strong><ul><li>这是两个参数的组合：<ul><li><code>-i</code> (interactive): 让容器保持标准输入流 (stdin) 打开，允许你与容器进行交互。</li><li><code>-t</code> (tty): 分配一个伪终端，提供一个交互式命令行界面。</li></ul></li></ul></li><li><strong><code>--gpus all</code></strong><ul><li>此参数指定类似于  <code>nvidia-docker</code>  的配置，允许容器访问所有可用的 GPU。确保在宿主机上正确安装了 NVIDIA 驱动和 NVIDIA 容器工具包。</li></ul></li><li><strong><code>--name my-pytorch-env</code></strong><ul><li>为新创建的容器指定一个名称。在这种情况下，容器被命名为  <code>my-pytorch-env</code>。命名容器有助于后续管理，例如停止或删除容器时更容易引用。</li></ul></li><li><strong><code>-v ~/:/workspace</code></strong><ul><li>这是一个卷挂载选项，允许你将宿主机的目录挂载到容器内：<ul><li><code>~/:</code>  指宿主机的用户主目录，将整个主目录的内容挂载到容器内。</li><li><code>/workspace</code>  是容器内的目标路径，指这个挂载点。容器可以在这个路径下访问宿主机的文件。</li></ul></li></ul></li><li><strong><code>ubuntu:22.04</code></strong><ul><li>指定要使用的基础镜像，这里使用的是 Ubuntu 22.04 版本。Docker 会从本地或 Docker Hub 拉取此镜像（如果在本地不存在）。</li></ul></li><li><strong><code>/bin/bash</code></strong><ul><li>指定容器启动后执行的命令。在这种情况下，<code>/bin/bash</code>  启动了一个 Bash shell，让用户能在容器中执行交互式命令。</li></ul></li></ol><h2 id="vscode-连接容器-配置">vscode 连接容器&amp;配置</h2><p>启动容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker start <span class="hljs-keyword">my</span>-pytorch-env<br></code></pre></td></tr></table></figure><ol><li>点击 VSCode 左下角  <strong>&gt;&lt;</strong>  按钮</li><li>选择  <strong>Attach to Running Container</strong>，选择 my-pytorch-env 容器<br>必要扩展</li><li><strong>Python</strong>（Python 代码支持）</li><li><strong>Pylance</strong>（代码补全和类型检查）</li><li><strong>Jupyter</strong>（Jupyter Notebook 支持）</li><li><strong>Docker</strong>（Docker 支持）</li></ol><h2 id="配置-conda-pytorch">配置 conda &amp; pytorch</h2><h3 id="安装-miniconda">安装 miniconda</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt <span class="hljs-keyword">update</span> &amp;&amp; apt install -<span class="hljs-keyword">y</span> wget<br># wget https://repo.anaconda.<span class="hljs-keyword">com</span>/miniconda/Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span><br>wget https://mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span><br>bash Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span> -<span class="hljs-keyword">b</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;/root/miniconda3/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-keyword">source</span> ~/.bashrc<br>conda init<br></code></pre></td></tr></table></figure><blockquote><p>[!warning]<br>conda init 后需要新建一个 bash 终端，否则 conda 环境不会生效。</p></blockquote><h3 id="创建-Pytorch-环境">创建 Pytorch 环境</h3><p>添加镜像源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/main/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/main/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/pytorch/</span><br>conda config --set show_channel_urls yes<br></code></pre></td></tr></table></figure><p>创建并配置环境</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n pytorch python=<span class="hljs-number">3</span>.<span class="hljs-number">10</span> -y<br><span class="hljs-attribute">conda</span> activate pytorch<br></code></pre></td></tr></table></figure><p>安装 pytorch 及实验所需依赖</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> install ipykernel matplotlib numpy<br><span class="hljs-attribute">pip</span> install torch==<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> torchvision torchaudio -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">python -c &quot;import torch; <span class="hljs-built_in">print</span>(torch.__version__); <span class="hljs-built_in">print</span>(torch.cuda.is_available())&quot;<br></code></pre></td></tr></table></figure><h2 id="docker-导出-导入">docker 导出&amp;导入</h2><blockquote><p>[!tip] 为什么需要导出导入</p><ol><li><strong>环境共享</strong>：</li></ol><ul><li>可以将配置好的开发环境分享给团队其他成员</li><li>确保所有人使用完全相同的环境，避免&quot;在我这里能运行&quot;的问题</li></ul><ol start="2"><li><strong>环境备份</strong>：</li></ol><ul><li>保存已配置好的环境状态，防止意外损坏</li><li>在需要时可以快速恢复到之前的状态</li></ul><ol start="3"><li><strong>跨机器迁移</strong>：</li></ol><ul><li>方便在不同机器间转移开发环境</li><li>特别适用于没有稳定网络连接的情况，避免重新下载和配置</li></ul><ol start="4"><li><strong>版本控制</strong>：</li></ol><ul><li>可以保存不同阶段的环境快照</li><li>在需要时回滚到特定版本</li></ul></blockquote><blockquote><p>[!warning] 注意<br>以下命令需要在 Ubuntu 终端（terminal）中运行，而不是容器内部。</p></blockquote><h3 id="导出">导出</h3><p><strong>导出容器为镜像</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker commit <span class="hljs-keyword">my</span>-pytorch-env <span class="hljs-keyword">my</span>-pytorch-image:latest<br></code></pre></td></tr></table></figure><ul><li>将运行中容器的当前状态保存为新的镜像</li><li><code>my-pytorch-env</code>：容器名称</li><li><code>my-pytorch-image:latest</code>：新镜像名称和标签<br><strong>导出镜像为文件</strong></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker <span class="hljs-built_in">save</span> -o my-pytorch-<span class="hljs-built_in">image</span>.tar my-pytorch-<span class="hljs-built_in">image</span>:latest<br></code></pre></td></tr></table></figure><ul><li>将镜像保存为可传输的 tar 文件</li><li><code>-o</code>：指定输出文件</li><li>生成的 tar 文件可以在不同机器间传输</li></ul><h3 id="导入">导入</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> my-pytorch-<span class="hljs-selector-tag">image</span><span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装</title>
    <link href="/2025/03/12/Docker%E5%AE%89%E8%A3%85/"/>
    <url>/2025/03/12/Docker%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-安装-wsl2-Ubuntu20-04">Docker 安装 (wsl2-Ubuntu20.04)</h2><h3 id="安装-docker">安装 docker</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 更新软件包列表，确保我们获得可用的软件包的最新信息</span><br>sudo apt update<br><br><span class="hljs-comment"># 安装必要的软件包：ca-certificates（用于验证SSL证书），curl（用于下载文件），gnupg（用于加密和解密）</span><br>sudo apt install <span class="hljs-literal">-y</span> ca<span class="hljs-literal">-certificates</span> <span class="hljs-built_in">curl</span> gnupg<br><br><span class="hljs-comment"># 下载阿里云的GPG证书并将其添加到系统的密钥管理器中，以便后续验证软件包的来源</span><br><span class="hljs-built_in">curl</span> <span class="hljs-literal">-fsSL</span> https://mirrors.aliyun.com/docker<span class="hljs-literal">-ce</span>/linux/ubuntu/gpg | sudo apt<span class="hljs-literal">-key</span> add<br><br><span class="hljs-comment"># 进入指定目录，这里是用来存储APT源列表的目录</span><br><span class="hljs-built_in">cd</span> /etc/apt/sources.list.d<br><br><span class="hljs-comment"># 创建一个名为docker.list的文件，用于存放Docker的阿里云镜像源</span><br>sudo touch docker.list<br><br><span class="hljs-comment"># 修改docker.list文件的权限，使所有用户都可以读写</span><br>sudo chmod <span class="hljs-number">666</span> docker.list<br><br><span class="hljs-comment"># 将阿里云的Docker镜像源信息写入docker.list文件</span><br>sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-variable">$</span>(lsb_release -cs) stable&quot;</span> &gt; docker.list<br><br><span class="hljs-comment"># 更新软件包列表以包含新添加的镜像源并升级已安装的软件包</span><br>sudo apt<span class="hljs-literal">-get</span> update &amp;&amp; sudo apt<span class="hljs-literal">-get</span> upgrade<br><br><span class="hljs-comment"># 安装Docker及其相关组件，包括Docker引擎、命令行工具、容器运行时、Docker构建插件和Docker Compose插件</span><br>sudo apt install <span class="hljs-literal">-y</span> docker<span class="hljs-literal">-ce</span> docker<span class="hljs-literal">-ce-cli</span> containerd.io docker<span class="hljs-literal">-buildx-plugin</span> docker<span class="hljs-literal">-compose-plugin</span><br></code></pre></td></tr></table></figure><h3 id="配置镜像源-NVIDIA-容器包工具">配置镜像源 NVIDIA 容器包工具</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 将当前用户添加到docker组，以便可以在不使用sudo的情况下运行docker命令</span><br>sudo usermod <span class="hljs-literal">-aG</span> docker <span class="hljs-variable">$USER</span><br><br><span class="hljs-comment"># 立即更新当前shell的组信息，或者可以注销后重新登录</span><br>newgrp docker<br><br><span class="hljs-comment"># 安装NVIDIA容器工具包的步骤</span><br><span class="hljs-comment"># 添加NVIDIA Docker的GPG密钥</span><br><span class="hljs-built_in">curl</span> <span class="hljs-literal">-s</span> <span class="hljs-literal">-L</span> https://nvidia.github.io/nvidia<span class="hljs-literal">-docker</span>/gpgkey | sudo apt<span class="hljs-literal">-key</span> add -<br><br><span class="hljs-comment"># 获取当前操作系统的ID和版本信息</span><br>distribution=<span class="hljs-variable">$</span>(. /etc/os<span class="hljs-literal">-release</span>;<span class="hljs-built_in">echo</span> <span class="hljs-variable">$ID</span><span class="hljs-variable">$VERSION_ID</span>)<br><br><span class="hljs-comment"># 添加NVIDIA Docker的APT源</span><br><span class="hljs-built_in">curl</span> <span class="hljs-literal">-s</span> <span class="hljs-literal">-L</span> https://nvidia.github.io/nvidia<span class="hljs-literal">-docker</span>/<span class="hljs-variable">$distribution</span>/nvidia<span class="hljs-literal">-docker</span>.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia<span class="hljs-literal">-docker</span>.list<br><br><span class="hljs-comment"># 添加CUDA的GPG公钥</span><br><span class="hljs-comment"># ！此处将com改为cn，2204改为2004</span><br>sudo apt<span class="hljs-literal">-key</span> adv <span class="hljs-literal">--fetch-keys</span> https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64/<span class="hljs-number">7</span>fa2af80.pub<br><br><span class="hljs-comment"># ！显示缺少某个公钥 单独获取</span><br>sudo apt<span class="hljs-literal">-key</span> adv <span class="hljs-literal">--keyserver</span> keyserver.ubuntu.com <span class="hljs-literal">--recv-keys</span> A4B469963BF863CC<br><br><span class="hljs-comment"># 添加CUDA的APT源</span><br>sudo <span class="hljs-built_in">add-apt</span><span class="hljs-literal">-repository</span> <span class="hljs-string">&quot;deb https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64/ /&quot;</span><br><br><span class="hljs-comment"># 更新APT包索引</span><br>sudo apt update<br><br><span class="hljs-comment"># 安装NVIDIA容器工具包</span><br>sudo apt install <span class="hljs-literal">-y</span> nvidia<span class="hljs-literal">-container-toolkit</span><br><br><span class="hljs-comment"># 重启Docker服务，以使NVIDIA容器工具包生效</span><br>sudo systemctl restart docker<br><br><span class="hljs-comment"># 配置Docker镜像源</span><br><span class="hljs-comment"># 创建Docker的配置目录（如果不存在）</span><br>sudo mkdir <span class="hljs-literal">-p</span> /etc/docker<br><br><span class="hljs-comment"># 创建或覆盖daemon.json文件，配置Docker的镜像源和默认运行时</span><br>sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>        <span class="hljs-string">&quot;https://docker.1ms.run&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.xuanyuan.me&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.nju.edu.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://do.nark.eu.org&quot;</span>,<br>        <span class="hljs-string">&quot;https://dc.j8.work&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerproxy.com&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;default-runtime&quot;</span>: <span class="hljs-string">&quot;nvidia&quot;</span>,<br>    <span class="hljs-string">&quot;runtimes&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;nvidia&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;nvidia-container-runtime&quot;</span>,<br>        <span class="hljs-string">&quot;runtimeArgs&quot;</span>: []<br>        &#125;<br>    &#125;<br>&#125;<br>EOF<br><br><span class="hljs-comment"># 重新加载systemd管理的配置</span><br>sudo systemctl daemon<span class="hljs-literal">-reload</span><br><br><span class="hljs-comment"># 再次重启Docker服务，以应用新的配置</span><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="验证安装">验证安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run hello<span class="hljs-literal">-world</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-2.2关系代数基本运算</title>
    <link href="/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-2%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/"/>
    <url>/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-2%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="关系代数概述">关系代数概述</h2><p><strong>关系代数</strong>：一种抽象的查询语言，用关系运算来表达对关系的操作</p><ul><li>集合运算符：传统的集合运算从关系的“水平”方向，即行的角度进行</li><li>专门的关系运算符</li></ul><p>常用关系操作：</p><ul><li>集合操作：并、交、差、笛卡尔积</li><li>专门的关系操作：<ul><li>选择、投影</li><li>连接（包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> -连接，自然连接，外连接等）</li><li>除</li></ul></li></ul><p><strong>5 种基本操作</strong>：选择、投影、并、差、笛卡尔积<br><img src="2025030636.png" alt=""><br>记号表示：</p><ul><li>关系设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">t \in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 表示 t 是 R 中的一个元组</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[A_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 表示元组 t 相应于属性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的一个分量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_r,t_s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示元组的连接</li><li>象集 images set:<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>x</mi></msub><mo>=</mo><mrow><mi>t</mi><mo stretchy="false">[</mo><mi>Z</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mtext>且</mtext><mi>t</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi></mrow></mrow><annotation encoding="application/x-tex">Z_x = {t[Z]|t\in R且t[X]=x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">]</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span></span></span></span></span> : 表示 R 中属性组 X 上值为 x 的诸元组在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 上分量的集合</li></ul></li></ul><h2 id="关系代数的基本运算">关系代数的基本运算</h2><ul><li>一般通过属性名来确定一个属性的语义，采用“同名同义、异名异义”</li></ul><p><img src="2025030664.png" alt=""></p><p><strong>并</strong> Union:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∪</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∨</mo><mi>t</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R\cup S=\{t|t\in R \vee t\in S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li><li>满足交换律和结合律</li></ul><p><strong>差</strong> Difference</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>−</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>t</mi><mo mathvariant="normal">∉</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R-S=\{t|t\in R \wedge t\notin S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li><li>不满足交换律和结合律</li></ul><p><strong>笛卡尔积</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi><mo>∧</mo><msub><mi>t</mi><mi>s</mi></msub><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R \times S =\{(t_r,t_s)|t_r\in R \land t_s\in S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li></ul><p><strong>选择</strong> Selection 又称为限制 Restriction</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\sigma_F(R)=\{t|t\in R\land F(t)=true\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mclose">}</span></span></span></span></li></ul><p><strong>投影</strong>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_A(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span></li><li>略去关系 𝐀 中的某些列，并重新安排结果关系中列的排列次序的运算</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><msub><mi>A</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mi>m</mi></msub></msub></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo stretchy="false">[</mo><msub><mi>A</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mi>m</mi></msub></msub><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\pi_{A_{i_1},A_{i_2},...,A_{i_m}}(R)=\{t[A_{i_1},A_{i_2},...,A_{i_m}]|t\in R\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1499em;vertical-align:-0.3999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2996em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.357em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight">2</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2996em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.357em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2306em;"><span style="top:-2.3em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.5em;"></span><span class="mord mathnormal mtight">m</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2859em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">}</span></span></span></span></li></ul><h2 id="关系代数基本运算的应用">关系代数基本运算的应用</h2><p>例</p><p><img src="2025030630.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-数据管理基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-2.1关系数据模型</title>
    <link href="/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="关系数据结构及形式化定义">关系数据结构及形式化定义</h2><h3 id="关系">关系</h3><h4 id="前置概念">前置概念</h4><p><strong>域 Domain</strong>: 一组具有相同数据类型的值的集合。</p><ul><li>例：整数、实数、枚举数据类型（{‘男’，‘女’}）</li><li>每一个域有一个‘域名’，用来区分不同的域。</li><li>同一个域中的元素互不相同。</li></ul><p><strong>笛卡尔积</strong> Cartesian Product:</p><ul><li>给定一组域 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，允许其中某些域是相同的。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的笛卡尔积可表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>×</mo><msub><mi>D</mi><mn>2</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1}\times D_2 \times...\times D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>运算结果也是一个集合，其中的每个元素都是一个具有如下形式的 n 元组：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,...,d_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_i \in D_i(i=1,2,...,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p><strong>元组 Tuple:</strong></p><ul><li>笛卡尔积中每一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,...,d_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 叫作一个 ‘n 元组’ (n-tuple) 或 ‘n 元有序组’ ，简称 ‘元组’</li></ul><p><strong>分量 Component:</strong></p><ul><li>笛卡尔积元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,...,d_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 中的每一个值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 叫作一个 ‘分量’</li></ul><p><strong>基数</strong>：</p><ul><li>一个域允许的不同取值个数称为这个域的‘基数’</li></ul><p>笛卡尔积的结果表示方法：</p><ul><li>集合表示：列举出结果集中的所有元组</li><li>二维表表示：表中每一行对应一个元组，每一列对应一个域。<ul><li>为了区分每一列所对应的域，需要在二维表中添加一个 ‘表头’ (table heading – 二维表第一行)，用于显示每一列对应域的域名</li></ul></li></ul><h4 id="关系的定义">关系的定义</h4><p><strong>关系 Relation</strong>: 给定一个域的序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（其中可能存在相同的域），笛卡尔积 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>×</mo><msub><mi>D</mi><mn>2</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1}\times D_2 \times...\times D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的子集叫做在域 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 上的关系，表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(D_{1},D_2,...,D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 或简写为关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>。</p><ul><li>n 是关系的 ‘目’ 或 ‘度’（Degree）</li></ul><p><strong>属性 Attribute</strong>:</p><ul><li>在一个关系中，不同列可以对应相同的域。为了加以区分，关系所对应的二维表中的每一列，被称为是该关系中的一个‘属性’。</li><li>关系中的每一个属性都有一个名字，称为‘属性名’。在同一个关系中，属性名互不相同。</li></ul><p><strong>码 (Key)、候选码 (Candidate key)</strong>: 若关系中的某一属性组的值能唯一地标识一个元组，而其所有的真子集都不能，则称该属性组为关系的 ‘候选码’，简称 ‘码’。</p><ul><li>简单的情况：一个候选码只包含一个属性；</li><li>最极端的情况：由关系中的所有属性构成的属性组是这个关系的候选码，称为 ‘全码’（All-key）</li></ul><p><strong>主码（Primary key）</strong>：</p><ul><li>在一个关系中，可以选择一个候选码作为该关系的 ‘主码’。</li><li>‘主码’ 是关系数据库管理系统（SQL）中才有的概念。当我们在创建关系对应的 ‘基表’ 时，可以为基表定义‘主码’也可以不定义‘主码’。在一张基表中，最多只能定义一个主码。</li><li>在关系模型理论中，只有 ‘候选码’，不需要为关系定义 ‘主码’。</li></ul><p><strong>主属性</strong> 与 非主属性/非码属性</p><ul><li>候选码中的诸属性称为该关系的 ‘主属性’（Prime attribute）</li><li>不包含在任何侯选码中的属性称为该关系的 ‘非主属性’（NonPrime attribute）或 ‘非码属性’（Non-key attribute）</li></ul><h4 id="关系的类别-性质">关系的类别/性质</h4><p>类型：</p><ul><li><strong>基本关系</strong>（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示。</li><li><strong>查询表</strong>：查询结果对应的表，结果数据不需要持久存储。</li><li><strong>视图表</strong>：由基本表或其他视图表导出的表, 是虚表, 结果数据也不需要持久存储。</li></ul><p>当使用‘关系’来作为<em>关系数据模型的数据结构</em>时，需要添加以下的约束：</p><ul><li>必须是一个有限子集</li><li>笛卡尔积满足交换律（或者说：关系中的列/属性满足‘无序性’）</li></ul><p>关系的性质：</p><ul><li>列是同质的：每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可出自同一个域：其中的每一列称为一个属性；</li><li>列的无序性（属性的无序性）</li><li>行的唯一性（元组的唯一性）</li><li>行的无序性（元组的无序性）</li><li>分量必须取原子值：每一个分量都必须是不可分的数据项</li></ul><h3 id="关系模型">关系模型</h3><p>关系的型与值</p><ul><li>关系是元组的集合</li><li>关系模式是关系的 ‘型’，元组集合是关系的 ‘值’</li></ul><p><strong>关系模式</strong>（Relation Schema）：</p><ul><li>关系模式是对关系的描述</li><li>元组集合的结构<ul><li><em>属性构成</em>（关系模式的核心）</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li><li>完整性约束条件：关系中的元组分量和元组需要满足的约束条件</li></ul><p><strong>形式化表示</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></p><ul><li>R ：关系名</li><li>U ：组成该关系的属性名集合</li><li>D ： U 中属性所来自的域</li><li>DOM ：属性向域的映象集合（描述各个属性对应的域）</li><li>F ：属性间数据的依赖关系的集合（关系上的完整性约束条件）</li></ul><p>关系模式通常可以简记为 R (U) 或 R (A1，A2，…，An)</p><h3 id="关系数据库">关系数据库</h3><p>——在一个给定的应用领域中，所有关系的集合构成一个关系数据库<br>关系数据库的型与值</p><ul><li>关系数据库的型<ul><li>关系数据库模式，是对关系数据库的描述</li><li>包括所有关系的关系模式，以及所有其他数据库对象的定义信息</li></ul></li><li>关系数据库的值<ul><li>关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><h2 id="关系操作">关系操作</h2><p><img src="2025022878.png" alt=""></p><h2 id="关系完整性">关系完整性</h2><p>三类完整性约束：</p><ul><li>实体完整性</li><li>参照完整性<ul><li>实体完整性和参照完整性是关系模型<em>必须满足</em>的完整性约束条件， 被称作是<strong>关系的两个不变性</strong>，由关系系统自动支持。</li></ul></li><li>用户定义的完整性<ul><li>是特定应用领域需要遵循的约束条件，体现了具体领域中的语义约束。</li></ul></li></ul><h3 id="实体完整性">实体完整性</h3><p>—— 指关系中元组（二维表中的行）的唯一性。</p><p>在关系数据库管理系统中，<em>实体完整性规则</em>是指：若属性 A 是基本关系（基表）的主码中的属性，则属性 A 不能去‘空值’（null）</p><ul><li>如果没有为基表定义主码，那么就允许在基表中出现重复的行（元组），这样的基表就不满足实体完整性约束。</li><li>如果为基表定义主码，DBMS 将自动保证“主码中的所有属性都不能取空值”以及“主码值的唯一性”</li></ul><h3 id="参照完整性">参照完整性</h3><p>关系间的引用：例——实体之间的引用</p><p><img src="2025030610.png" alt=""></p><p><strong>参照完整性规则</strong>：若属性（或属性组）F 是基本关系 R 的外码，它与基本关系 S 的主码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中的每个元组在 F 上的值必须为：</p><ul><li>或者取空值（F 的每个属性值均为空值）</li><li>或者等于 S 中某个元组的主码值<br><img src="2025030686.png" alt=""></li></ul><h3 id="用户定义的完整性">用户定义的完整性</h3><p>——针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义</p><p>要求</p><p>例：课程（课程号 课程名 学分）</p><ul><li>课程号属性值的<em>唯一性约束</em></li><li>非主属性课程名的<em>非空约束</em></li><li>学分的<em>取值范围约束</em></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-数据管理基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-03运输层</title>
    <link href="/2025/03/12/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2025/03/12/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="运输层基础">运输层基础</h2><h3 id="网络传输服务">网络传输服务</h3><ul><li>在不同主机上运行的应用程序进程之间提供逻辑通信</li></ul><p>运输层协议在<strong>端系统</strong>（主机）中实现</p><ul><li>发送端：将应用程序消息分成段，传递到网络层</li><li>接收端：将片段重新组装成消息，传递给应用层</li></ul><p>为什么需要运输层：</p><ul><li>IP 数据包被寻址到主机，但端到端通信是在主机上的应用程序进程之间进行的<ul><li>需要一种方法来决定哪些数据包去往哪些应用程序（多路复用/多路分解）</li></ul></li><li>IP 提供了一种弱服务模型（尽力而为）<ul><li>数据包可能被损坏、延迟、丢弃、重新排序、复制</li><li>没有关于发送多少流量和何时发送的指导</li></ul></li></ul><h3 id="运输层的作用">运输层的作用</h3><ul><li>进程之间的通信</li><li>为应用层提供通用的端到端服务[可选]</li><li>TCP 和 UDP 是常见的传输协议</li><li>UDP 是一种极简的传输协议</li><li>TCP 提供了一种可靠、有序的字节流抽象<ul><li>有拥塞控制，但没有性能保证（延迟、b/w 等）</li></ul></li></ul><h3 id="应用与套接字">应用与套接字</h3><p><strong>Socket</strong>：应用程序进程的软件抽象，用于与（操作系统中的传输层）交换网络消息</p><p>运输层寻址：&lt;HostIP, Port&gt;, called a socket</p><p>两种套接字类型：</p><ul><li>UDP socket: SOCK_DGRAM</li><li>TCP socker: SOCK_STREAM</li></ul><p><strong>端口</strong> Port：有助于区分应用程序的 16 位数字</p><ul><li>数据包在传输头中携带 src/dst 端口号</li></ul><p>操作系统存储套接字和端口之间的映射：</p><ul><li>对于 UDP ports (SOCK_DGRAM)<ul><li>OS stores (local port, local IP address)&lt;–&gt; socket</li></ul></li><li>对于 TCP ports (SOCK_STREAM)<ul><li>OS stores (local port, local IP, remote port, remote IP) &lt;–&gt; socket</li></ul></li></ul><h3 id="多路复用与多路分解">多路复用与多路分解</h3><p>多路复用 Multiplexing Mux: 在源主机上收集和组合来自不同应用程序的数据块，并将其传递到网络层</p><p>多路分解 Demultiplexing Demux: 从多路复用的流中向相应的套接字传递正确的数据<br><img src="2025030442.png" alt=""></p><p><strong>多路分解的工作原理</strong>：<br><img src="2025030422.png" alt=""></p><p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。</p><h4 id="无连接的多路分解">无连接的多路分解</h4><p>一个 UDP 套接字由一个二元组全面标识，该二元组包含一个目的 IP 地址和一个目的端口号。因此，如果两个 UDP 报文段有不同的源 IP 地址和/或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到<strong>相同的目的进程</strong>。</p><h4 id="面向连接的多路分解">面向连接的多路分解</h4><p>当一个 TCP 报文段到达主机时，所有 4 个字段（源 IP 地址、源端口、目的 IP 地址、目的端口）被用来将报文段定向（分解）到相应的套接字。</p><h2 id="可靠数据传输设计">可靠数据传输设计</h2><p><strong>数据包损坏</strong>：<br>如何从错误中恢复：</p><ul><li>确认（ACK）：接收方明确地告诉发送方 pkt 接收到 OK</li><li>否定确认（NAK）：接收方明确地“告知”发送方 pkt 有错误</li><li>发送方在收到 NAK 后重新发送 pkt</li></ul><p>What if the ACK/NACK is corrupted?</p><ul><li>Data and ACK packets carry sequence numbers 数据和 ACK 数据包携带序列号</li></ul><p><strong>数据包丢失</strong>：</p><p><em>定时器</em>驱动的丢失检测：在发送数据包时设置定时器；超时时重新传输</p><ul><li>定时器驱动的重传可能会导致<em>重复</em></li></ul><p><img src="2025030450.png" alt=""><br>解决方案的组成：</p><ul><li>Checksums: to detect bit errors</li><li>Timers: to detect loss</li><li>Acknowledgement: positive or negative</li><li>Sequence numbers: to deal with duplicates</li></ul><h2 id="可靠数据传输协议设计">可靠数据传输协议设计</h2><p><strong>Stop and Wait</strong><br><img src="2025030453.png" alt=""></p><p>效率很低，网络协议限制了物理资源的使用</p><p><strong>Pipelined protocols</strong> 流水线</p><p>发送方允许多个“正在进行中”但尚未确认的 pkt</p><ul><li>必须增加序列号的范围</li><li>在发送方和/或接收方进行缓冲</li></ul><p><strong>三个设计决策</strong></p><p>发送方可以发送哪些数据包？</p><ul><li>滑动窗口</li></ul><p>接收方如何接收数据包？</p><ul><li>累积</li><li>选择性</li></ul><p>发送方重新发送哪些数据包？</p><ul><li>Go-Back N (GBN)</li><li>Selective Repeat (SR)</li></ul><h3 id="滑动窗口-Sliding-window">滑动窗口 Sliding window</h3><p>窗口=相邻序列号集</p><ul><li>集合的大小是窗口大小；假设窗口大小为 n</li></ul><p>基本思想：一次最多发送 n 个数据包</p><ul><li>发送方可以在其窗口中发送数据包</li><li>接收方可以在其窗口中接收数据包</li><li>可接受的数据包窗口在成功接收/确认时“滑动”</li><li>窗口包含可能仍在传输中的所有数据包</li></ul><h3 id="Go-Back-N-GBN">Go-Back-N (GBN)</h3><ul><li>接收方仅按顺序接收数据包</li><li>If timeout, retransmit A+1, … , A+n</li></ul><p><img src="2025031825.png" alt=""></p><h3 id="Selective-Repeat-SR">Selective Repeat (SR)</h3><p><img src="2025031841.png" alt=""></p><h2 id="UDP：User-Datagram-Protocol">UDP：User Datagram Protocol</h2><blockquote><p>UDP TCP 进程之间的通信<br>IP 主机之间的通信</p></blockquote><ul><li>进程之间的轻量级通信</li><li>避免开销以及 order&amp;reliability 的延迟</li></ul><p>“<em>Best effort</em>” service: UDP 段可能</p><ul><li>丢失</li><li>乱序交付到 app</li></ul><p>无连接：</p><ul><li>UDP 发送方与接收方之间没有握手</li><li>每个 UDP 段都独立处理</li></ul><p>UDP 使用</p><ul><li>流媒体应用程序（容错、速率敏感）</li><li>DNS</li><li>SNMP</li></ul><p>为什么要用 UDP</p><ul><li>无连接建立（这可能会增加延迟）</li><li>简单：发送方和接收方没有连接状态</li><li>报头大小小</li><li>无拥塞控制：UDP 可以按需快速传输</li></ul><p><img src="2025031867.png" alt=""></p><p><strong>checksum</strong><br>目的：检测传输分段中的“错误”（例如翻转位）</p><p><img src="2025031880.png" alt=""></p><h2 id="TCP：Transmission-Control-Protocol">TCP：Transmission Control Protocol</h2><blockquote><p>TCP 提供可靠、有序的字节流</p></blockquote><ul><li>可靠：TCP 重新发送丢失的数据包（递归），直到它放弃并关闭连接</li><li>有序：TCP 只将连接的数据块交给应用程序</li><li>字节流：TCP 假设由传入的数据流，并尝试将其传递给应用程序</li></ul><p>TCP 包含的内容：</p><ul><li>Most of what we’ve seen<ul><li>Checksum</li><li>Sequence numbers 序列号是字节偏移量</li><li>接收方和发送方保持一个滑动窗口</li><li>接收方发送累计确认（像 GBN）<ul><li>发送方维护一个重传定时器</li></ul></li><li>接收方缓冲乱序数据包（像 SR）</li></ul></li><li>Few more：快速重传、超时估计算法等</li></ul><p><img src="2025031829.png" alt=""></p><p>序列号不是分组编号，是分组类别的字节偏移量<br><img src="2025031881.png" alt=""></p><p><img src="2025031824.png" alt=""></p><p>发送方发送数据包</p><ul><li>数据以序列号 X 开头</li><li>数据包包含 B 个字节[X，X+1，X+2，…X+B-1]</li></ul><p>收到数据包后，接收方发送 ACK</p><ul><li>如果 X 之前所有数据都已收到：ACK 确认 X+B （因为这是下一个预期的字节）</li><li>如果接收到的最高顺序字节是 Y (s.t. Y + 1 &lt; X)<ul><li>ACK 确认 Y+1，即使之前已经确认过</li></ul></li></ul><hr><p>引入快速重传：重复的 ACK 触发 early retransmission</p><p>重复的 ACK 是孤立丢失的标志</p><ul><li>缺乏 ACK 进度意味着 500 个 ACK 尚未送达</li><li>ACK 流意味着一些数据包正在送达</li></ul><p>收到 k 个重复 ACK 时触发重传</p><ul><li>TCP 使用 k=3</li><li>比等待超时更快</li></ul><p>两种<strong>重传</strong>方式：</p><ul><li>发送丢失的数据包并按重复 ACK 的数量移动滑动窗口<ul><li>加快传输速度，但可能是错误的</li></ul></li><li>发送丢失的包，并等待 ACK 移动滑动窗口<ul><li>由于单次数据包丢失而速度缓慢</li></ul></li></ul><p>发送方维护一个<em>重传定时器</em>（如 GBN），并在超时时进行重传</p><ul><li>用 RTT 的值估算 timeout 的时间</li><li>EstimatedRTT = (1- a)*EstimatedRTT + a*SampleRTT</li></ul><h2 id="TCP-Connection-Setup">TCP Connection Setup</h2><p>三次握手建立可靠连接</p><ol><li>主机 A 向主机 B 发送 SYN</li><li>主机 B 返回 SYN 确认 (SYN ACK)</li><li>主机 A 发送 ACK 以确认 SYN ACK</li></ol><p><img src="2025031872.png" alt=""></p><p>如果 SYN Packet 丢失</p><ul><li>假设 SYN 数据包丢失<ul><li>网络丢弃的数据包或服务器正忙</li></ul></li><li>最终，没有 SYN-ACK 到达<ul><li>发送方在超时时重新传输 SYN</li></ul></li><li>TCP 发送方应如何设置计时器？<ul><li>发送者不知道接收者有多远</li><li>很难猜测等待的合理时间长度</li></ul></li></ul><h2 id="TCP-Connection-Teardown">TCP Connection Teardown</h2><p>正常终止，one side at a time<br><img src="2025031863.png" alt=""></p><p>正常终止，both together<br><img src="2025031825-1.png" alt=""></p><p>突发终止<br><img src="2025031867-1.png" alt=""></p><ul><li>A 发送 RESET (RST) 给 B<ul><li>比如：A 的应用程序崩溃</li></ul></li><li>问题：<ul><li>B 不支持 RST</li><li>因此，RST 不能可靠传输，飞行中的任何数据都可能会丢失</li><li>但是：如果 B 再发送任何内容，将引发另一个 RST</li></ul></li></ul><p><strong>TCP Client 生命周期</strong><br><img src="2025031844.png" alt=""></p><p><strong>TCP Server 生命周期</strong><br><img src="2025031853.png" alt=""></p><h2 id="TCP-flow-Control">TCP flow Control</h2><p>固定滑动窗口的问题：</p><ul><li>未能收到 ACK 被视为流量控制指示</li><li>接收器可以通过停止发送 ACK 来实现流量控制，但发送器无法区分丢失的段和流量控制</li></ul><p>解决方法 <em>Advertised Window</em><br>接收者发布 Advertised Window（RWND）以防止发送方溢出窗口</p><ul><li>接收方在 ACK 中指示 RWND 的值</li><li>发送方确保飞行中的总字节数&lt;=RWND</li></ul><p><img src="2025040105.png" alt=""></p><p>发送方：当新数据确认时窗口前进<br>接收方：当接收过程消耗数据时窗口前进<br>接收方向发送方通告接收方窗口当前结束的位置（“右侧边缘”）<br><em>UDP</em> 没有流量控制，数据可能因为缓存溢出丢失。</p><h2 id="TCP-拥塞控制">TCP 拥塞控制</h2><p>考虑因素</p><ul><li>发现可用（bottleneck）带宽</li><li>适应带宽变化</li><li>在流之间共享带宽</li></ul><p>可能的方案</p><ul><li>不顾一切地发送，许多数据包丢失</li><li>Reservations<ul><li>预先安排带宽分配</li><li>发送数据包前需要协商</li><li>低利用率</li></ul></li><li>Pricing<ul><li>不要因为高价出价者而丢弃数据包</li><li>需要支付模式</li></ul></li><li>动态调整<ul><li>主机推断拥塞程度；调整</li><li>网络向主机报告拥塞程度；主机调整</li><li>上述方法的组合</li><li>易于实现但次优，动态混乱</li></ul></li></ul><p>动态调整的普遍性已被证明非常强大</p><ul><li>不预设商业模式、流量特征、应用需求</li><li>但确实假设了良好的公民意识！</li></ul><p>两个基本的问题：</p><ul><li>发送方如何检测拥塞</li><li>发送方如何调整其发送速率<ul><li>解决三个问题<ul><li>查找可用瓶颈带宽</li><li>调整带宽变化</li><li>共享带宽</li></ul></li></ul></li></ul><p><strong>检测拥塞</strong></p><ul><li>数据包延迟<ul><li>复杂：噪声信号（延迟通常变化很大）</li></ul></li><li>路由器告诉终端主机何时拥塞</li><li>数据报丢失<ul><li>故障安全信号，TCP 必须检测到</li><li>复杂性：非拥塞丢失（例如，校验和错误）</li></ul></li></ul><p>并非所有 loss 都是一样的<br><img src="2025060556.png" alt=""><br><strong>Rate 调整</strong></p><ul><li>基本结构<ul><li>收到 ACK（新数据）时：提高速率</li><li>检测到丢包时：降低速率</li></ul></li><li>我们如何提高/降低速率取决于我们处于拥塞控制哪个阶段：<ul><li>发现可用瓶颈带宽（慢启动）</li><li>调整带宽变化（拥塞避免：AIMD）</li></ul></li></ul><p>使用<strong>慢启动</strong>进行带宽发现<br>目标：估算可用带宽</p><ul><li>起始缓慢（安全）</li><li>快速提升（效率）</li></ul><p><strong>阶段</strong><br><em>启动</em></p><ul><li>发送方以慢速开始，但会指数级增加直到首次丢包</li><li>以较小的拥塞窗口开始<ul><li>初始时，CWND = 1</li><li>初始发送速率是 MSS/RT</li></ul></li><li>对于每个无丢包的 RTT，将 CWND 加倍</li></ul><p><em>运行中</em></p><ul><li>对于每个往返时间 (RTT)：CWND 加倍</li><li>即对每个 ACK，CWND += 1</li></ul><p><img src="2025060537.png" alt=""></p><p>什么时候<em>停止</em></p><ul><li>慢启动提供了可用带宽的估计<ul><li>在某个时刻，将会出现丢包</li></ul></li><li>引入“慢启动阈值”（ssthresh）<ul><li>初始化为一个较大的值</li></ul></li><li>如果 <em>CWND &gt; ssthresh</em>，停止慢启动</li></ul><p><em>适应</em>不同带宽</p><ul><li>CWND &gt; ssthresh<ul><li>停止快速增长，专注于维护</li></ul></li><li>现在，想要跟踪可用带宽的变化，围绕其当前值波动<ul><li>重复探测（速率增加）和回退（速率减少</li></ul></li><li>TCP 使用：“加性增加乘性减少”（<em>AIMD</em>）</li></ul><p><strong>AIMD</strong></p><ul><li>增量增加：当 CWND &gt; ssthresh<ul><li>对每个 ACK，CMND = CWND + 1/CWND</li><li>仅在 CWND 中所有段都被确认时才增加一个</li></ul></li><li>乘性减少</li><li>在 3 个<em>重复 ACK</em>（丢包时间）时<ul><li>ssthresh = CWND / 2</li><li>CWND = ssthresh</li><li>进入拥塞避免：cwnd 每次 RTT 后线性增加 1（而不是指数增加）</li></ul></li><li><em>超时</em>事件发生时<ul><li>ssthresh = CWND / 2</li><li>CWND = 1</li><li>启动慢启动</li></ul></li></ul><p><img src="2025060585.png" alt=""></p><p><img src="2025060529-1.png" alt=""></p><p><em>为什么用 AIMD？</em></p><ul><li>每次往返时间 (RTT)，我们可以做<ul><li>乘性增加或减少 CWND -&gt; a * CWND</li><li>加性增加或减少 CWND -&gt; b * CWND</li></ul></li><li>四种选择<ul><li>AIAD：温和增加，温和减少</li><li>AIMD：温和增加，急剧减少</li><li>MIAD：急剧增加，温和减少</li><li>MIMD：急剧增加和减少</li></ul></li></ul><p><img src="2025060593-1.png" alt=""></p><p><strong>快速恢复</strong><br>思路：为每个 dupACK 授予发送者临时的“信用”，以保持数据包在空中<br>如果 dupACKcount =3</p><ul><li>ssthresh = CWND/2</li><li>CWND = ssthresh + 3</li></ul><p>在快速恢复阶段</p><ul><li>CWND = CWND + 1 对每个额外的 dupACK</li></ul><p>接收到新的 ACK 后退出快速恢复</p><ul><li>设置 CWND = ssthresh</li></ul><p>示例<br><img src="2025060505.png" alt=""></p><h2 id="路由器辅助拥塞控制">路由器辅助拥塞控制</h2><p>警告位<br><em>显式拥塞通知 ECN</em></p><ul><li>数据包头部中的一个比特位，由拥塞的路由器设置<ul><li>如果数据包中的比特位被设置，则 ACK 也会设置 ECN 比特位</li></ul></li><li>路由器设置该比特位时有许多选项<ul><li>（链路）利用率和（数据报）延迟之间的权衡</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-02应用层</title>
    <link href="/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-02%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-02%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="网络应用原理">网络应用原理</h2><h3 id="网络应用体系结构">网络应用体系结构</h3><h4 id="客户-服务器体系结构-CS-client-server-achitecture">客户-服务器体系结构 CS client-server achitecture</h4><ul><li>有一个总是打开的主机，称为服务器，它服务于来自许多其它称为客户的主机的请求。</li><li>客户相互不直接通信</li><li>具有固定的、周知的地址，称为 <strong>IP 地址</strong>；客户总是能够通过向该服务器的 IP 地址发送分组来与其联系。</li><li>例：Web/FTP/Telnet/电子邮件</li></ul><h4 id="P2P-体系结构-P2P-architecture">P2P 体系结构 P2P architecture</h4><ul><li>对位于数据中心的专用服务器有最小的（或者没有）依赖。</li><li>应用程序在间断连接的主机对之间直接通信，这些主机称为对等方。</li><li>例：文件共享应用 BitTorrent</li><li><strong>自扩展性</strong> self-scalability：尽管每个对等方都由于请求文件产生工作负载，但每个对等方通过向其它对等方文件也为系统增加服务能力。</li><li>成本效率：不需要庞大的服务器基础设施和服务带宽</li></ul><p>例：及时通讯</p><ul><li>CS: User registers its IP address with central server when it comes online</li><li>P2P: User contacts central server to find IP address of parties</li></ul><h3 id="进程通信">进程通信</h3><p><strong>进程：</strong> 进行通信的实际上是进程 process 而不是程序，一个进程可以被认为是运行在端系统中的一个程序。</p><ul><li>当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。</li><li>在两个不同端系统上的进程，通过跨越计算机网络交换报文 message 而相互通信</li></ul><p><strong>套接字 socket：</strong> 进程通过一个称为套接字的软件结构向网络发送报文和从网络接收报文。由于套接字也是建立网络应用程序的可编程接口，也被称为应用编程接口 Application Programming Interface API</p><h2 id="应用层协议">应用层协议</h2><h3 id="Web-和-HTTP">Web 和 HTTP</h3><h4 id="HTTP-概述">HTTP 概述</h4><p><strong>HTTP</strong> (HyperText Transfer Protocol 超文本传输协议)：Web 的应用层协议，是 Web 的核心。<br>URL 格式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&lt;protocol&gt;<span class="hljs-symbol">://&lt;host&gt;</span><span class="hljs-symbol">:&lt;port&gt;/&lt;path&gt;<span class="hljs-string">?q</span>uery_string</span><br></code></pre></td></tr></table></figure><ul><li>protocol: method for transmission or interpretation of the object</li><li>host: DNS name or IP address of the host where object resides</li><li>path: pathname of the file that contains the object</li><li>query_string: name/value pairs sent to app on the server</li></ul><p>HTTP 连接过程 —— 三次握手：</p><ul><li>客户向服务器发送一个小 TCP 报文段</li><li>服务器用一个小 TCP 报文段做出确认和响应</li><li>客户向服务器返回确认</li></ul><h4 id="cookie">cookie</h4><p><strong>cookie:</strong> HTTP 服务器是无状态的，而 cookie 允许站点对用户进行跟踪<br>4 个组件：</p><ul><li>在 HTTP 响应报文中的一个 cookie 首部行</li><li>在 HTTP 请求报文中的一个 cookie 首部行</li><li>在用户端系统中保留的一个 cookie 文件，并由用户的浏览器进行管理</li><li>位于 Web 站点的一个后端数据库</li></ul><h4 id="持续-非持续连接">持续/非持续连接</h4><p><strong>RTT:</strong> 往返时间 Round-Trip Time 指一个短分组从客户到服务器然后再返回客户所花费的时间。包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延</p><p><em>非持续连接</em>：</p><ul><li>必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配 TCP 的缓冲区和保持 TCP 变量，给服务器带来严重负担。</li><li>每一个对象经受两倍 RTT 的交付时延，即一个 RTT 用于创建 TCP，另一个 RTT 用于请求和接收一个对象。</li></ul><p><em>持续连接</em>：服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。</p><h4 id="Web-缓存">Web 缓存</h4><p>Web 缓存器 - 代理服务器 proxy server：能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p><p><strong>条件 GET</strong> conditional GET</p><p>条件 GET 请求报文：HTTP 请求报文使用 GET 方法，并且请求报文中包含一个&quot;If-modified-since: &quot;首部行</p><h3 id="SMTP">SMTP</h3><p>用于从发送方的邮件服务器发送报文到接收方的邮件服务器<br>传送方式：</p><ol><li>客户 SMTP（运行在发送邮件服务器主机上）在 25 号端口建立一个到服务器 SMTP（运行在接收邮件服务器主机上）的 TCP 连接。</li><li>如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手。</li><li>在 SMTP 握手的阶段，SMTP 客户只是发送方的邮件地址（产生报文的人）和接收方的邮件地址。一旦该 SMTP 客户和服务器彼此介绍后，客户发送该报文。</li><li>SMTP 能依赖 TCP 提供可靠数据传输无差错地将邮件投递到接收服务器。该客户如果有另外的报文要发送到该服务器，就在该相同的 TCP 连接上重复这种处理；否则它指示 TCP 关闭连接。</li></ol><h3 id="DNS-Domain-Name-Service">DNS Domain Name Service</h3><h4 id="基本概念">基本概念</h4><p>识别主机的两种方式:</p><ul><li>主机名</li><li>IP 地址</li></ul><p>——主机名到 IP 地址转换的目录服务：DNS 的主要任务</p><p>DNS：</p><ul><li>一个由分层的 DNS 服务器实现的分布式数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li></ul><p>目标：</p><ul><li>独特性：没有命名冲突</li><li>可扩展性 Many names and frequent updates (secondary)</li><li>分布式、自主管理<ul><li>Ability to update my own (machine’s) names</li><li>Don’t have to track everybody’s updates</li></ul></li><li>Highly available</li><li>Lookups are fast</li><li>Perfect consistency is a non-goal</li></ul><p>How?</p><ul><li>Partition the namespace</li><li>Distribute administration of each partition 分配每个分区的管理<ul><li>Autonomy to update my own (machine’s) names</li><li>Don’t have to track everybody’s updates</li></ul></li><li>Distribute name resolution for each partition 为每个分区分配名称解析</li></ul><h4 id="层次结构">层次结构</h4><p>核心思想：层次结构 <strong>Hierarchy</strong><br>Three intertwined hierarchies</p><ul><li>Hierarchical namespace</li><li>Hierarchical administered</li><li>(Distributed) hierarchy of servers</li></ul><p><img src="2025022587.png" alt=""><br><img src="2025022532.png" alt=""></p><p>DNS 服务器的层次结构：</p><ul><li>根服务器：13 root name “serves” worldwide，还有超多 1000 台的副本。根服务器提供 TLD 服务器的 IP 地址</li><li>顶级域 (TLD Top-Level Domain) DNS 服务器：对每个顶级域和所有国家的顶级域都有 TLD 服务器。TLD 服务器提供权威 DNS 服务器的 IP 地址。</li><li>权威服务器：在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织的权威 DNS 服务器收藏了这些 DNS 记录。</li></ul><p>例：使用户的主机能够将一个 HTTP 请求报文发送到 Web 服务器，该用户主机需获得对应的 IP 地址：</p><ol><li>同一台用户主机上运行着 DNS 应用的客户端</li><li>浏览器从上述 URL 中抽取出主机名 <a href="http://www.someschool.edu">www.someschool.edu</a> ，并将主机名传给 DNS 应用的客户端。</li><li>DNS 客户向 DNS 服务器发送一个包含主机名的请求。</li><li>DNS 客户最终会收到一份回答报文，其中含有对应于该主机名的 IP 地址。</li><li>一旦浏览器接收到来自 DNS 的该 IP 地址，它就向位于该 IP 地址 80 端口的</li></ol><p>HTTP 服务器进程发起一个 TCP 连接。</p><p><strong>本地 DNS 服务器</strong>：每个 ISP 都有一台本地 DNS 服务器，当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址。</p><p><img src="2025030419.png" alt=""></p><p><strong>递归查询</strong> recursive query：从请求主机到本地 DNS 服务器的查询。其余的查询都是迭代的。</p><h4 id="DNS-缓存">DNS 缓存</h4><ul><li>为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量</li><li>原理：在一个请求链中，当某 DNS 服务器接收一个 DNS 回答时（例如，包含某主机名到 IP 地址的映射），它就能将映射缓存在本地存储器中。</li></ul><h4 id="DNS-记录">DNS 记录</h4><p><img src="2025030432.png" alt=""></p><h3 id="FTP-File-Transfer-Protocol">FTP File Transfer Protocol</h3><ul><li>在运输层使用 TCP</li><li>一般端口号为 21/20</li><li>在本地和主机之间传输文件。采用 CS 模型。</li><li>采用异构的操作系统和文件系统</li></ul><p>控制连接：让客户和服务器可以建立连接（比如身份认证）</p><p>数据连接：单独创建一个连接，进行数据的传输。</p><h3 id="CDNs-Content-Distribution-Networks">CDNs Content Distribution Networks</h3><p>挑战：</p><ul><li>实时从单个源服务器流式传输大文件（如视频）</li><li>保护源服务器免受 DDOS 攻击<br>解决方法：</li><li>在互联网上的数百台服务器上复制内容</li><li>CDN 分发节点协调内容分发</li><li>将内容放在用户附近</li></ul><h4 id="内容复制">内容复制</h4><ul><li>内容提供商（源服务器）是 CDN 客户</li><li>CDN 在 CDN 服务器中复制客户的内容</li><li>当提供商更新内容时，CDN 会更新其服务器</li><li>使用权威 DNS 服务器重定向请求</li></ul><h4 id="CDN-操作">CDN 操作</h4><p><img src="2025030477.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-01计算机网络和因特网</title>
    <link href="/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-01%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
    <url>/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-01%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念和问题">基本概念和问题</h2><h3 id="因特网的概念">因特网的概念</h3><h4 id="具体构成">具体构成</h4><ul><li>主机 host / 端系统 end system</li><li>通信链路 communication link<ul><li>链路的传输速率 transmission rate 以比特/秒 bit/s bps 度量</li><li>当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包就是分组 packet。</li></ul></li><li>分组交换机 packet switch<ul><li>路由器 router 用于网络核心</li><li>链路层交换机 link-layer switch 用于接入网</li></ul></li></ul><p><strong>TCP/IP</strong>：端系统、分组交换机和其它因特网部件都要运行多个协议 protocol，这些协议控制因特网中信息的接收和发送。TCP (Transmission Control Protocol 传输控制协议) 和 IP (Internet Protocol 网际协议) 是因特网中最为重要的两个协议，因特网的主要协议统称为 TCP/IP。</p><h4 id="协议-Protocol">协议 Protocol</h4><p><strong>定义：</strong> 在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送/接收或其它事件所采取的操作。</p><h3 id="网络边缘-Network-Edge">网络边缘 Network Edge</h3><p>端系统——也称为主机 host</p><ul><li>客户 client</li><li>服务器 server</li></ul><h4 id="接入网-Access-Networks">接入网 Access Networks</h4><p>——将端系统物理连接到其边缘路由器 edge router 的网络。是端系统到任何其它远程端系统的路径上的第一台路由器。</p><ol><li>家庭接入：DSL、电缆、FTTH 和 5G 固定式无线<ul><li>DSL - Digital Subscirber Line 数字用户线</li><li>HFC - Hybrid Fiber Coax 混合光纤同轴</li><li>FTTH - Fiber To The Home 光纤到户</li></ul></li><li>企业（和家庭）接入：以太网和 WIFI</li><li>广域无线接入：3G、LTE 4G 和 5G</li></ol><h4 id="物理媒介">物理媒介</h4><ul><li>导引型媒介：电波沿着固体媒介前行，如光缆、双绞铜线或同轴电缆</li><li>非导引型媒介：电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中传播</li></ul><h3 id="网络核心-The-Network-Core">网络核心 The Network Core</h3><p><strong>报文 message:</strong> 包含该应用的设计者需要的任何东西。可以执行一种控制功能，也可以包含数据。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为<strong>分组 packet</strong>。</p><h4 id="电路交换-circuit-switching">电路交换 circuit switching</h4><p>在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。<br><img src="2025022638.png" alt=""></p><ol><li><strong>频分复用</strong> Frequency-Division Multiplexing FDM: 链路的频谱由跨越链路创建的所有连接共享。在连接期间链路为每条连接专设一个频段，该频段的宽度称为带宽。</li><li><strong>时分复用</strong> Time-Division Multiplexing TDM: 时间被划分为固定时段的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网路在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用。</li></ol><p>优缺点：<br><img src="2025022670.png" alt=""></p><h4 id="分组交换-packet-switching">分组交换 packet switching</h4><p><strong>存储转发传输</strong> store-and-forward transmission: 在交换机开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。<br><img src="2025022618.png" alt=""><br>排队时延/丢失：<br><img src="2025022686.png" alt=""><br>优缺点：<br><img src="2025022641.png" alt=""></p><h2 id="Network-Performance">Network Performance</h2><h3 id="时延类型">时延类型</h3><ol><li>传输时延 Transmission delay: 用 L 表示分组长度，用 R 表示从路由器 A 到路由器 B 的链路传输速率，传输时延时 L/R。</li><li>传播时延 Propagation delay: 从链路的起点到路由器 B 传播所需要的时间。</li><li>排队时延 Queuing delay: 在队列中，当分组在链路上等待传输时，将经受排队时延。</li><li>处理时延 Processing delay: 检查分组首部/决定该分组导向何处等所需的时间。</li></ol><h3 id="端到端时延">端到端时延</h3><p><img src="2025022692.png" alt=""></p><h2 id="协议层次和服务模型">协议层次和服务模型</h2><h3 id="协议分层">协议分层</h3><h4 id="应用层">应用层</h4><p>网络应用程序及它们的应用层协议存留的地方。<br>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组，这种位于应用层的信息分组称为<strong>报文 message</strong>。</p><h4 id="运输层">运输层</h4><p>在应用程序端点之间传送应用层报文。<br>把运输层的分组称为<strong>报文段 segment</strong>。</p><h4 id="网络层">网络层</h4><p>负责将称为<strong>数据报 datagram</strong> 的网络层分组从一台主机移动到另一台主机。</p><h4 id="链路层">链路层</h4><p>在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点链路层将数据报上传给网络层。<br>链路层的分组称为<strong>帧 frame</strong>。</p><h4 id="物理层">物理层</h4><p>链路层将整个帧从一个网络元素移动到邻近的网络元素，而物理层是将帧中的一个个比特从一个节点移动到下一个节点。</p><h3 id="封装">封装</h3><p><img src="2025022640.png" alt=""><br><img src="2025022651.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
