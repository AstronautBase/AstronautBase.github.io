<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++高级程序设计-all-重点</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-all-%E9%87%8D%E7%82%B9/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-all-%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-抽象封装">1 抽象封装</h2><h3 id="λ-表达式">λ 表达式</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[](<span class="hljs-type">double</span> <span class="hljs-keyword">x</span>)-&gt;<span class="hljs-type">double</span>&#123;return <span class="hljs-keyword">x</span>*<span class="hljs-keyword">x</span>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>参数、返回值类型可省</p><p>环境变量使用：</p><ul><li>&amp; 按引用方式</li><li>= 按值的方式</li><li>&amp;，= 可指定 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">&amp;</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\&amp;,n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">&amp;</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>=</mo><mo separator="true">,</mo><mi mathvariant="normal">&amp;</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[=,\&amp; n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">&amp;</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">&amp;</mi><mi>k</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\&amp;k, m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">&amp;</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mclose">]</span></span></span></span> 默认是按值的方式</li></ul><h3 id="数据抽象与封装">数据抽象与封装</h3><p>抽象：程序外部可观察到的行为，使用者不考虑如何实现（复杂度控制）</p><p>封装：把程序实体内部具体的实现细节对使用者隐藏，只提供接口。（信息保护）<br>过程</p><ul><li>抽象：用一个名字代表完成一定功能的代码</li><li>封装：把命名代码的具体实现隐藏起来，数据通过参数来获得</li></ul><p>数据：</p><ul><li>抽象：只描述数据能实施哪些操作，以及操作之间的关系，用户不用知道具体表现形式（链表、数组等）</li><li>封装：把数据及其操作作为一个整体来进行实现，对数据的访问只能通过封装体对外接口中提供的操作进行实现</li></ul><h3 id="面向对象">面向对象</h3><p>程序由若干对象组成，每个对象是由一些数据以及对这些数据所能实施的操作所构成的封装体</p><ol><li>对象/类（类：描述对象的特征）</li><li>继承</li><li>消息的多态与动态绑定<ol><li>多态</li></ol><ul><li>一名多用：函数名重载、操作符重载</li><li>类属：类属函数、类属类型</li></ul><ol start="2"><li>绑定：确定对多态元素的某个使用是多态元素的哪一种形式</li></ol><ul><li>静态：在编译时确定</li><li>动态：在运行时确定</li></ul></li></ol><h2 id="2-对象与类">2 对象与类</h2><h3 id="成员的访问控制">成员的访问控制</h3><p>数据成员：在类中说明一个数据成员的类型时，若未见到相应类型的定义，则该数据成员只能是该类型的指针或引用类型。</p><ul><li>public 不受限制</li><li>private 本类 &amp; 友元</li><li>protected 本类 &amp; 友元 &amp; 派生类</li></ul><p>创建对象</p><ul><li>直接：在相应变量的生命周期创建，结束时对象消亡</li><li>间接（动态）：new 要用 delete 撤销</li></ul><h3 id="this-指针">this 指针</h3><p>类中描述的数据成员（静态除外）对该类的每个对象分别有一个拷贝</p><p><strong>成员函数</strong>对所有对象只有一个拷贝</p><p>除了静态成员函数，有一个隐藏的形参 this (类型：该类对象的指针)</p><p>在成员函数中对类成员的访问是通过 this 进行的，当通过对象访问类的成员函数，会把相应的对象地址传给成员函数的参数 this</p><p>显式使用：要将 this 指向的对象作为整体操作</p><h3 id="构造-析构函数">构造&amp;析构函数</h3><p><strong>构造函数</strong></p><ul><li>创建对象时自动调用</li><li>默认构造函数：不带参数的</li><li>可用于创建临时对象 <code>f(A(10))</code></li></ul><p>成员初始化表 <code>A():z(x),y(1)&#123;x=0;&#125;</code></p><p><strong>析构函数</strong></p><ul><li>不能被重载</li><li>对象消亡时自动调用</li><li>额外申请资源时，可自定义来归还空间</li><li>可在生存期内显示调用，暂时归还资源，不是让对象消亡</li></ul><p>成员对象：先调用本身类的构造函数，在进入函数体前，调用成员对象类的构造函数，然后执行函数体</p><p><strong>拷贝构造函数</strong><br>构造函数的参数类型为本类的引用，在创建对象时，若用另一个同类型的对象对其初始化则调用</p><ol><li>创建时显式指出</li><li>将对象作为值参数传给函数</li><li>把对象作为函数的返回值时</li></ol><p>隐式拷贝构造函数：将逐个成员进行拷贝初始化</p><ul><li>对象成员：调用对象类的拷贝构造函数</li></ul><p>问题：s1, s2 的成员指针 str 指向同一块内存区域，消亡时归还两次</p><p>-&gt; 可自定义拷贝构造函数</p><p><strong>转移构造函数</strong><br>右值引用类型 &amp;&amp;<br><code>f(A&amp;&amp; x)</code> 接受临时对象/即将消亡的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp; x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp;&amp; x)</span></span>;<br>A a;<br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">// 调用f(A&amp; x)</span><br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">A</span>()); <span class="hljs-comment">// 在两者都有定义时，调用f(A&amp;&amp; x)</span><br></code></pre></td></tr></table></figure><p><code>A(A&amp;&amp; x)</code> 用临时对象或即将消亡的对象去初始化另一个对象，若对象类中有转移构造函数则… 否则调用普通拷贝构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">A</span>(A&amp;&amp; x)<br>&#123;<br>p=x.p; <span class="hljs-comment">// 把参数对象x的p指向的空间作为新对象p的空间</span><br>x.p=null;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-成员函数-友元">3 成员函数 友元</h2><h3 id="常成员函数">常成员函数</h3><p>防止在获取对象状态中无意修改对象数据成员的值</p><p><code>int get_day() const;</code></p><p>对常量对象只能调用常成员函数</p><h3 id="静态成员">静态成员</h3><p><code>static int x;</code> 可实现同一个类的不同对象之间的数据共享<br><code>int A::x=0</code> 对该类的所有对象只有一份拷贝<br><code>static int get_shared()</code> 调用 a.get_shared () 或者 A.get_shared ()</p><h3 id="友元">友元</h3><p>为提高在类的外部对类数据成员的访问效率</p><p>友元不是一个类的成员，具有不对称性，不具有传递性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-操作符重载">4 操作符重载</h2><h3 id="基本操作符重载">基本操作符重载</h3><p>以成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Conplex&amp; x) <span class="hljs-type">const</span><br>&#123;<br>Complex tmp;<br>tmp.real = real + x.real;<br>tmp.imag = imag + x.imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125;;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按a.operator + (b)实现</span><br></code></pre></td></tr></table></figure><p>以全局函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2);<br>&#125;;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2)<br>&#123;<br>Complex tmp;<br>tmp.real = c<span class="hljs-number">1.</span>real + c<span class="hljs-number">2.</span>real;<br>tmp.imag = c<span class="hljs-number">1.</span>imag + c<span class="hljs-number">2.</span>imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按operator+(a, b)实现</span><br></code></pre></td></tr></table></figure><p>不可重载的：. , .* ?: :: sizeof</p><p>遵循已有操作数的语法：</p><ul><li>不能改变操作数的个数</li><li>原操作符的优先级和结合性不变</li></ul><p>++/–</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 后置用法(int)</span><br>Counter&amp; <span class="hljs-keyword">operator</span> ++()<span class="hljs-comment">// 前置的++重载函数</span><br>&#123;<br>value++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">const</span> Counter <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>) <span class="hljs-comment">// 后置的++重载函数</span><br>&#123;<br>Counter tmp = *<span class="hljs-keyword">this</span>;<br>value++; <span class="hljs-comment">// ++(*this) 调用前置的++重载函数</span><br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特殊操作符的重载">特殊操作符的重载</h3><p>=<br>s1=s2 s1.str 原来指向的空间丢失 s2 的 str 释放两次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br>......<br>String&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> String&amp; s)<br>&#123;<br><span class="hljs-keyword">if</span> (&amp;s == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//防止自身赋值：a=a</span><br><span class="hljs-keyword">delete</span> []str; <span class="hljs-comment">//归还str原来指向的空间</span><br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s.len<span class="hljs-number">+1</span>]; <span class="hljs-comment">//申请新的空间</span><br><span class="hljs-built_in">strcpy</span>(str,s.str); <span class="hljs-comment">//把用于赋值的字符串复制到新空间中</span><br>len = s.len; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>若有成员对象，自定义的赋值操作符重载函数不会自动去调用成员对象类的赋值操作，需要在自定义的赋值操作符重载函数中显式指出。</p><p><code>a = b.a;//调用A类的赋值操作符重载函数来实现成员对象的赋值。</code></p><p><code>A a;</code></p><ul><li><code>A b=a;</code> //初始化，等价于：A b (a);，调用拷贝构造函数。</li><li><code>b = a; </code> //赋值，调用赋值操作符=重载函数。</li></ul><p>若赋值的对象即将消亡：<code>A&amp; operator=(A&amp;&amp; x)</code></p><p>在转移赋值操作符重载函数中实现资源的转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; x)<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span> []p; <span class="hljs-comment">//归还老空间</span><br>p = x.p; <span class="hljs-comment">//使用参数对象的空间（资源转移）</span><br>x.p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//使得参数对象不再拥有该空间</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>[ ]<br><code>char operator [](int i) const&#123;return str[i];&#125; //用于常量对象 </code><br>( )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; value = i; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">//函数调用操作符()的重载函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x*y+value;<br>&#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//a是个对象</span><br>cout &lt;&lt; a.<span class="hljs-built_in">g</span>() &lt;&lt;endl; <span class="hljs-comment">//把a当对象来用</span><br>cout &lt;&lt; <span class="hljs-number">10</span>+<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &lt;&lt; endl;<br><span class="hljs-comment">//把a当函数来用！</span><br><span class="hljs-comment">//a(10,20)等价于：a.operator()(10,20)</span><br></code></pre></td></tr></table></figure><h3 id="λ-表达式原理">λ 表达式原理</h3><p>编译器</p><ul><li>隐式定义一个类<ul><li>数据成员对应 λ 表达式用到的环境变量（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[...]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">...</span><span class="mclose">]</span></span></span></span>）, 在构造函数中用环境变量对它们进行初始化</li><li>按相应 λ 表达式的函数功能重载函数调用操作符</li></ul></li><li>创建上述类的一个临时对象（设为 obj）</li><li>在使用上述 λ 表达式的地方用 obj 来替代<ul><li>作用于实参进行函数调用：<code>cout &lt;&lt; [...](int x)-&gt;int &#123; ....... &#125;(3);</code> 替换成：<code>cout &lt;&lt; obj(3);</code></li><li>传给其它函数：<code>f([...](int x)-&gt;int &#123; ....... &#125;); </code> 替换成：` f (obj);</li></ul></li></ul><h3 id="智能指针">智能指针</h3><p>-&gt;</p><ul><li>第一个操作数：一个指向类或结构的指针</li><li>第二个操作数：第一个指向的类或结构的成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PtrA</span><br>&#123;<br>A* p_a;<br><span class="hljs-type">int</span> count;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">PtrA</span>(A *p)<br>&#123;<br>p_a=p;count=<span class="hljs-number">0</span>;<br>&#125;<br>A* <span class="hljs-keyword">operator</span>-&gt;()<br>&#123;<br>count++;<br><span class="hljs-keyword">return</span> p_a;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>PtrA b=&amp;a;<br>b-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// b.operator-&gt;()-&gt;f();</span><br></code></pre></td></tr></table></figure><p>库提供：</p><ul><li>shared_ptr 带引用计数，可实现动态对象空间的自动回收</li><li>unique_ptr 独占动态对象</li></ul><p>new</p><p><code>void *operator new(size_t size)</code> size 即所需空间大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(A)];<br>A *p = <span class="hljs-built_in">new</span>(buf) <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>delete</p><p><code>void operator delete(void *p, size_t size)</code> 前者指向对象的内存空间，后者可省略</p><p><code>A *p=new A[10];</code> <code>delete []p</code></p><p>当类中有析构函数，传给 new[] 重载的参数 size 的实际值会比对象数组所需的空间多 4 个字节，用于存储元素个数</p><p>delete 会根据元素个数调用每个元素的析构函数</p><p>自定义类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> x+y;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会有歧义问题：<code>a+i</code></p><ul><li>显示类型转换：<code>(int)a + i</code> 或 <code>a+(A)i</code></li><li>禁止把 A 当作隐式类型转换符 explicit<ul><li><code>explicit A(int i)&#123;&#125;</code></li><li>禁止将 int () 当作隐式类型转换 <code>explicit operator int()&#123;...&#125;</code></li></ul></li></ul><h2 id="5-继承-派生类">5 继承 派生类</h2><h3 id="继承">继承</h3><p>在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出新的功能定义或对已有类的功能进行重新定义</p><p>派生类不能访问基类的私有成员</p><p>Hidden: 如果派生类中定义了与基类同名的成员，则基类的成员名在派生类的作用域中不直接可见</p><p>在派生类中访问基类同名的成员时要基类名受限 <code>A::func()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 可用using声明</span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-title">A::f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">f</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类创建</p><ul><li>先调用本身类的构造函数，但在进入函数体前会先调用基类的构造函数（默认构造函数）</li></ul><p>消亡时，先调用本身，执行完后，调用基类的</p><p>D 有基类 B 成员对象类 M</p><p>创建 B-&gt;M-&gt;D 消亡 D-&gt;M-&gt;B</p><h3 id="虚函数">虚函数</h3><ol><li>指定消息用动态绑定</li><li>指出基类中可被派生类重新定义的成员函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 前面加上virtual则变为动态绑定</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(A&amp; x)</span></span><br><span class="hljs-function"></span>&#123;<br>x.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 静态：A::f() 动态：A/B</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(A* p)</span></span><br><span class="hljs-function"></span>&#123;<br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 静态：A::f() 动态：A/B</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类">抽象类</h3><p><code>virtual int f()=0;</code> 纯虚函数</p><p>抽象类不能用于创建对象</p><p>作用</p><ul><li>为派生类提供一个基本框架</li><li>为同一个功能的不同实现提供一个抽象描述（接口）</li></ul><h3 id="多继承">多继承</h3><p>名冲突问题——基类名受限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;A::<span class="hljs-built_in">f</span>(); B::<span class="hljs-built_in">f</span>();&#125;<br>&#125;<br>C c;<br>c.A::<span class="hljs-built_in">f</span>();<br>c.B::<span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure><p>重复继承问题——虚基类</p><p>D 继承自 B, C；B，C 都继承自 A，A 中有数据成员 x, 则 D 的对象 d 中会有两个 x，B:: x, C:: x , 若要 D 中只有一个 x，可将 A 定为 B, C 的虚基类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> B&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C&#123;&#125;<br></code></pre></td></tr></table></figure><p>虚基类的构造函数由该类的构造函数直接调用，优先非基类的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>) &#123; y = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>) &#123; z = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> m;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k): <span class="hljs-built_in">B</span>(i), <span class="hljs-built_in">C</span>(j), <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>) &#123; m = k; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> D <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l): <span class="hljs-built_in">D</span>(i,j,k), <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>) &#123; n = l; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>聚合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A *pm;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(A *p)&#123;pm=p;&#125;<br>~B&#123;pm=Null&#125;<br>&#125;<br>A *pa = <span class="hljs-keyword">new</span> A;<br>B *pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>(pa);<br><span class="hljs-keyword">delete</span> pb; <span class="hljs-comment">// 聚合类对象消亡其成员对象没有消亡</span><br><span class="hljs-keyword">delete</span> pa;<br></code></pre></td></tr></table></figure><p>组合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span><br>&#123;<br>A a;<br>&#125;<br>C *pc = <span class="hljs-keyword">new</span> C;<br><span class="hljs-keyword">delete</span> pc; <span class="hljs-comment">// 成员对象在组合类对象内部创建并随着组合类对象消亡而消亡</span><br></code></pre></td></tr></table></figure><h2 id="6-IO">6 IO</h2><p>cout cin 优势</p><ul><li>不用专门指定数据的类型和个数，编译时刻根据数据本身来决定数据的类型和个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream <span class="hljs-title">in</span><span class="hljs-params">(...)</span></span>;<br>in.<span class="hljs-built_in">get</span>(ch);<br>in.<span class="hljs-built_in">read</span>(p, <span class="hljs-number">100</span>);<br><br><span class="hljs-function">ostream <span class="hljs-title">out</span><span class="hljs-params">()</span></span>;<br>out.<span class="hljs-built_in">put</span>(ch);<br>out.<span class="hljs-built_in">write</span>(p,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>“&gt;&gt;” 把输入看作字符串，自动进行从字符串到基本数据类型的转换</p><p>cerr (ostream 的对象) 对应着计算机系统用于输出特殊信息的设备，不带缓冲（clog 带缓冲）</p><p>指针：<code>char *p</code> <code>cout&lt;&lt;p</code> 输出 p 指向的字符串 <code>cout&lt;&lt;(void*)p</code> 输出指针 p 本身的值</p><p>输出格式——操纵符 manipulator</p><p>hex 十六进制 oct 八进制 dec 十进制 setprecision (int n) 设置浮点数精度<br>setiosflags (long flags) resetiosflags (long flags) 参数 ios:: scientific 以指数形式显示浮点数 ios:: fixed 小数形式</p><h3 id="面向控制台">面向控制台</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ostream&amp; <span class="hljs-title">ostream::put</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span>;<br>cout.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-function">ostream&amp; <span class="hljs-title">ostream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">int</span> count)</span></span>;<br><span class="hljs-comment">// 输出p指向的内存空间中count个字节。</span><br><span class="hljs-type">char</span> info[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> n;...<br>cout.<span class="hljs-built_in">write</span>(info, n);<br></code></pre></td></tr></table></figure><p>用&gt;&gt; 数据之间会用空白符分开（空格，\t,\n）</p><p><code>cin &gt;&gt; setw(10) &gt;&gt; str</code> 把输入的字符串和一个‘\0’放入 str，即最多 9 个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span> &amp;ch)</span></span>;<br>istream&amp; istream:<span class="hljs-built_in">read</span>(<span class="hljs-type">char</span>* p, <span class="hljs-type">int</span> count);<br><span class="hljs-function">istream&amp; <span class="hljs-title">istream::get</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> count, <span class="hljs-type">char</span> delim=<span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>;<br><span class="hljs-comment">// 输入到count-1或遇到delim指定的字符为止，并自动加入&#x27;\0&#x27;</span><br><span class="hljs-comment">// 空白符也会作为字符输入</span><br></code></pre></td></tr></table></figure><p>跳过 n 个或遇到换行符： <code>cin.ignore(n,'\n')</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin.<span class="hljs-built_in">getline</span>(str,<span class="hljs-number">5</span>);<br><span class="hljs-keyword">if</span>(cin.<span class="hljs-built_in">fail</span>()) <span class="hljs-comment">// 如果本行还有未读的字符</span><br>&#123;<br>cin.<span class="hljs-built_in">clear</span>();<br>cin.<span class="hljs-built_in">ignore</span>(<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;&lt; &gt;&gt; 重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">operator</span>&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="hljs-type">const</span> Complex&amp; c)<br>&#123;<br>out &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="面向文件">面向文件</h3><p>每个打开的文件都有一个内部的隐藏指针</p><p><code>ofstream out_file(&quot;xx.txt&quot;);</code> <code>out_file.open(&quot;xxx&quot;)</code></p><p>打开方式：</p><ul><li>ios:: out 写 若已经存在则先清除内容，若没有则创建</li><li>ios:: app 添加 指针在末尾，若无则创建</li></ul><p>判断 <code>if(out_file.is_open())</code></p><p>输出到 <code>out_file &lt;&lt; x &lt;&lt; endl</code> 二进制：<code>out_file.write((char*)&amp;s1, sizeof(s1))</code></p><p>关闭 <code>out_file.close()</code></p><ul><li>把文件内存缓冲区的内容写到磁盘中</li><li>归还打开文件时申请的资源</li></ul><p>打开文件 <code>ifstream in_file(&quot;xxx&quot;)</code></p><p>打开方式 ios:: in 读操作</p><h2 id="7-异常处理">7 异常处理</h2><h3 id="异地处理，结构化">异地处理，结构化</h3><p>就地处理 —— exit / abort <code>if(file.fail())&#123;exit(-1);&#125;</code></p><p>异地处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(...)</span></span>&#123;...<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(rc == <span class="hljs-number">-1</span>))&#123;...&#125;<br></code></pre></td></tr></table></figure><p>结构化异常处理机制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (file.<span class="hljs-built_in">fail</span>()) &#123; <span class="hljs-keyword">throw</span> filename; &#125;<br>&#125;<br><span class="hljs-built_in">try</span>(<span class="hljs-built_in">f</span>(str))...<br><span class="hljs-built_in">catch</span>(<span class="hljs-type">char</span> *fn) &#123; ...<span class="hljs-comment">// 处理异常&#125;</span><br></code></pre></td></tr></table></figure><p>一个 try 后可跟多个 catch，采用精准匹配</p><p>嵌套：</p><ul><li>若内层 try 的执行发生异常，内层不存在相应的 catch，逐步向外层找，若在函数调用链上没有捕获，则调用系统的 terminate，一般是 abort</li></ul><p>可能导致内存泄漏问题，比如 throw 前 new 了动态对象</p><ul><li>局部对象会自动消亡</li><li>可用智能指针 <code>uniqu_ptr(A) p(new A) ... throw...</code> p 会消亡，它的析构函数会释放动态对象</li></ul><h2 id="8-泛型-STL-函数式">8 泛型 STL 函数式</h2><h3 id="泛型程序设计">泛型程序设计</h3><p>基于具有类属特性的程序实体进行程序设计的技术</p><p>函数模板 ——带有类型参数的函数定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T element[])</span></span><br><span class="hljs-function"></span>&#123;<br>T tmp; <span class="hljs-comment">// 可作局部变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显式实例化 <code>max&lt;int&gt;(x,m)</code></p><p>带非类型参数的函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-type">int</span> size&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T a)</span></span><br><span class="hljs-function"></span>&#123;<br>T temp[size];<br>&#125;<br><span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-number">10</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>类模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>....<br>Stack&lt;<span class="hljs-type">int</span>&gt; st1; <span class="hljs-comment">// 必须显式实例化</span><br></code></pre></td></tr></table></figure><p>注意：把类模板的定义和实现都放在头文件中</p><h3 id="STL">STL</h3><p>vector-动态数组 list-双向链表 deque-分段的连续空间结构</p><p>迭代器（属于智能指针）</p><ul><li>vector, deque, basic_string：随机迭代器 RanIt</li><li>list, map, multimap, set：双向迭代器 BidIt</li></ul><p>算法：一个算法能接受的迭代器类型是通过算法模板参数的名字体现的</p><p>template&lt;class InIt, class OutIt&gt;</p><p>OutIt copy (InIt src_first, InIt src_last, Out_It dst_first) // 前两个也就是操作范围的两个迭代器必须属于同一容器</p><p>自定义操作条件</p><ul><li>一元谓词 Pred count_if (v.begin (), v.end (), f)</li><li>二元谓词 BinPred sort (RanIt first, RanIt last, BinPred comp)</li></ul><p>自定义操作</p><ul><li>一元 Op/Fun</li><li>二元 BinOp/BinFun</li></ul><p>e.g. Fun for_each (InIt first, InIt last, Fun f)</p><p><code>void display(int x)&#123;cout &lt;&lt; &quot; &quot; &lt;&lt; x;&#125;</code></p><p><code>for_each(v.begin(), v,end(), display);</code></p><h3 id="函数式程序设计">函数式程序设计</h3><p>命令式程序设计</p><ul><li>过程式程序设计</li><li>面向对象程序设计</li></ul><p>声明式</p><ul><li>函数式</li><li>逻辑式</li></ul><p>Functional Programming：把程序组织成一组数学函数，计算过程体现为基于一系列函数应用的表达式求值。</p><p>基本特征：</p><ol><li>纯函数：以相同的参数调用同一个函数总得到相同的值（引用透明），除了产生计算结果不会改变其他任何东西（无副作用）</li><li>没有状态：计算体现为数据之间的映射，不改变已有数据而是产生新数据（无赋值操作）</li><li>函数也是值：函数的参数和返回值都可以是函数，可由已有函数生成新的函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">reverse</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(str) == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> str;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">substr</span>(str, <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(str) - <span class="hljs-number">1</span>)) + <span class="hljs-built_in">substr</span>(str, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>尾递归</p><ul><li>函数递归调用深度要受栈空间的限制，并且递归调用效率低</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> b;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>,b,a+b);&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>好处：递归调用回来不用做其它事，从而不会再使用递归调用前的栈空间内容，所以递归调用时不必额外为它分配栈空间，可重用当前栈空间</p><p>转迭代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> b;<br><span class="hljs-keyword">else</span><br>&#123; <span class="hljs-comment">// return fib(n-1,b,a+b)</span><br><span class="hljs-type">int</span> t1 = n<span class="hljs-number">-1</span>, t2=b, t3=a+b;<br>n = t1, a = t2, b = t3;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>部分函数应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br>function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; print10 = [](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(n, <span class="hljs-number">10</span>);&#125;;<br><span class="hljs-built_in">print10</span>(<span class="hljs-number">23</span>) <span class="hljs-comment">// 等价 print(23,10)</span><br></code></pre></td></tr></table></figure><p>用 bind 实现</p><p>Fty2 bind (Fty1 fn, T1 t1, T2 t2, TN, tn);</p><p>fn: 带 n 个参数的函数，t1~tn：参数值 固定 or 未绑定（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">_</mi><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">_</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\_1,\_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9544em;vertical-align:-0.31em;"></span><span class="mord">_1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">_2</span></span></span></span>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> base)</span></span><br><span class="hljs-function">function&lt;<span class="hljs-title">void</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; print10 : bind(print,_1,<span class="hljs-number">10</span>) // n不绑，base绑<span class="hljs-number">10</span></span><br></code></pre></td></tr></table></figure><p>柯里化 currying</p><p>意义</p><ul><li>数学上：对单参数函数的研究模型可用到多参数上</li><li>程序设计上：不必把一个多参数的函数所需要的参数同时提供给它，可逐步提供</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">function&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>&gt; <span class="hljs-title">add_cd</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">bind</span>(add, x, _1);<br><span class="hljs-comment">// [x](int y)-&gt;int&#123;return add(x,y)&#125;</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-built_in">add_cd</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="9-事件驱动的程序设计">9 事件驱动的程序设计</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">WinMain</span>()<br>&#123;<br><span class="hljs-built_in">RegisterClass</span>(); <span class="hljs-comment">// 注册窗口类，定义程序中要创建的窗口类型</span><br><span class="hljs-built_in">CreateWindow</span>(); <span class="hljs-comment">// 创建主窗口</span><br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">GetMessage</span>()) <span class="hljs-comment">// 消息队列</span><br>&#123;<br><span class="hljs-built_in">DispatchMessage</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-5-继承</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1>派生类</h1><p>继承是指：</p><ul><li>在定义一个新的类时，先把已有的一个或多个类的功能全部包含进来，然后再在新的类中给出新功能的定义或对已有类的某些功能进行重新定义。</li><li>不需要已有软件的源代码，属于目标代码复用！</li></ul><p>在 C++中，定义单继承时，派生类只能有一个直接基类，其定义格式如下：</p><p><code>class &lt;派生类名&gt;:[&lt;继承方式&gt;] &lt;基类名&gt; &#123; &lt;成员说明表&gt; &#125;; </code></p><ul><li>&lt;派生类名&gt;为派生类的名字。</li><li>&lt;基类名&gt;为直接基类的名字。</li><li>&lt;成员说明表&gt;是在派生类中新定义的和对基类重定义的成员。</li><li>&lt;继承方式&gt;用于指出从基类继承来的成员在派生类中对外的访问控制。</li></ul><p>除了拥有新定义的成员外，派生类拥有基类的所有成员（基类的构造函数、析构函数和赋值操作除外）</p><p>定义派生类时一定要见到<strong>基类的定义</strong>.</p><p><strong>友元</strong>：</p><ul><li>如果在派生类中没有显式指出，则基类的友元不是派生类的友元；</li><li>如果基类是另一个类的友元，而该类没有显式指出， 则派生类不是该类的友元。</li></ul><p>派生类不能直接访问基类的<strong>私有成员</strong>。</p><p><strong>protected</strong> 访问控制缓解了封装与继承的矛盾。</p><p>C++类向外界提供两种接口：</p><ul><li>public：供类的实例用户使用（通过对象）</li><li>public+protected：供派生类使用</li></ul><p><img src="2025031541.png" alt=""><br><img src="2025031590-1.png" alt=""><br><img src="2025031546.png" alt=""></p><p><img src="2025031538.png" alt=""></p><p>当创建派生类的对象时，</p><ul><li>是先调用本身类的构造函数，但在进入函数体之前，会去调用基类的构造函数，然后再执行本身类构造函数的函数体！</li><li>默认情况下，调用基类的<strong>默认构造函数</strong>，如果要调用基类的非默认构造函数，则必须在派生类构造函数的成员初始化表中<strong>显式指出</strong>。</li><li>也就是说，构造函数的成员初始化表（即使没显式给出）中有对基类的构造函数的调用代码。</li></ul><p>当派生类对象消亡时，</p><ul><li>是先调用本身类的析构函数，本身类析构函数的函数体执行完之后，再去调用基类的析构函数！</li><li>也就是说，析构函数的函数体最后有对基类析构函数的调用代码。</li></ul><p><img src="2025031501-1.png" alt=""></p><h1>虚函数与消息的动态绑定</h1><p>静态绑定：</p><p><img src="2025031585.png" alt=""></p><p>动态绑定：</p><ul><li>在基类中用虚函数来指出<br><img src="2025031537.png" alt=""><br>虚函数有两个作用：</li><li>指定消息采用动态绑定。</li><li>指出基类中可以被派生类重定义的成员函数<ul><li>对于基类中的一个虚函数，在派生类中定义的、与之具有相同型构的成员函数是对基类该成员函数的重定义（或称覆盖，override）</li></ul></li></ul><h1>抽象类</h1><p>纯虚函数是没给出实现的虚函数，函数体用“=0”表示</p><p><img src="2025031535.png" alt=""></p><p>包含纯虚函数的类称为抽象类。</p><ul><li>抽象类不能用于创建对象。</li><li>抽象类的作用：<ul><li>为派生类提供一个基本框架</li><li>为同一个功能的不同实现提供一个抽象描述（接口）。</li></ul></li></ul><p><img src="2025031553-2.png" alt=""></p><p>C++的类不是抽象数据类型，它是抽象数据类型的实现<br><strong>用抽象类实现类的真正抽象作用</strong><br>问题：</p><p><img src="2025031569-1.png" alt=""></p><p>解决：</p><p><img src="2025031527.png" alt=""></p><h1>多继承</h1><p>多继承是指派生类可以有一个以上的直接基类</p><ul><li>继承方式及访问控制的规定同单继承。</li><li>派生类拥有所有基类的所有成员。</li><li>基类的声明次序决定：<ul><li>对基类数据成员的存储安排。</li><li>对基类构造函数/析构函数的调用次序</li></ul></li></ul><p><img src="2025031568.png" alt=""></p><p>多继承带来的问题</p><ul><li>名冲突问题 —— 基类名受限</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123; ......<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用A的f。</span><br>B::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用B的f。</span><br>&#125;<br>&#125;;<br>......<br>C c;<br>c.A::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用A的f。</span><br>c.B::<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//OK，调用B的f。</span><br></code></pre></td></tr></table></figure><ul><li>重复继承问题</li></ul><p><img src="2025031529.png" alt=""></p><p>如果要求类 D 中只有一个 x，则应把 A 定义为 B 和 C 的<strong>虚基类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-type">int</span> x; ......&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;......&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A &#123;......&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C &#123;......&#125;;<br>D d;<br></code></pre></td></tr></table></figure><p>对于拥有虚基类的类，创建该类的对象时：</p><ul><li>虚基类的构造函数由该类的构造函数直接调用。</li><li>虚基类的构造函数优先非虚基类的构造函数执行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>) &#123; y = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(<span class="hljs-number">2</span>) &#123; z = i; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B, <span class="hljs-keyword">public</span> C <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> m;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k): <span class="hljs-built_in">B</span>(i), <span class="hljs-built_in">C</span>(j), <span class="hljs-built_in">A</span>(<span class="hljs-number">3</span>) &#123; m = k; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>: <span class="hljs-keyword">public</span> D <span class="hljs-comment">//包含虚基类A</span><br>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">E</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l): <span class="hljs-built_in">D</span>(i,j,k), <span class="hljs-built_in">A</span>(<span class="hljs-number">4</span>) &#123; n = l; &#125;<br>&#125;;<br>......<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//这里，A的构造函数由D调用，d.x初始化为3</span><br><span class="hljs-comment">// 调用的构造函数及它们的执行次序是： A(3)、B(1)、C(2)、D(1,2,3)</span><br><span class="hljs-function">E <span class="hljs-title">e</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>; <span class="hljs-comment">//这里， A的构造函数由E调用，e.x初始化为4</span><br><span class="hljs-comment">// 调用的构造函数及它们的执行次序是： A(4)、B(1)、C(2)、D(1,2,3)、E(1,2,3,4)</span><br></code></pre></td></tr></table></figure><h1>聚合与组合</h1><p><strong>聚合</strong></p><p>聚合类的成员对象一般是采用<strong>对象指针</strong>表示，用于指向被包含的成员对象，而被包含的成员对象是在<strong>外部</strong>创建，然后加入到聚合类对象中来的。</p><p><img src="2025031503.png" alt=""></p><p><strong>组合</strong></p><p>组合类的成员对象一般<strong>直接是对象</strong>， 有时也可以采用对象指针表示，但不管是什么表示形式，成员对象一定是在组合类对象内部创建并随着组合类对象的消亡而消亡。</p><p><img src="2025031599-1.png" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-4-操作符重载</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1>操作符重载</h1><h2 id="操作符重载概述">操作符重载概述</h2><p>操作符重载可通过定义一个函数名为 “operator #”（ “#”代表某个可重载的操作符）的函数来实现，该函数可以作为：</p><ul><li>一个类的非静态的成员函数（操作符 new 和 delete 的重载除外）。</li><li>一个全局（友元）函数。</li></ul><p>以成员函数重载复数的“+”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Conplex&amp; x) <span class="hljs-type">const</span><br>&#123;<br>Complex tmp;<br>tmp.real = real + x.real;<br>tmp.imag = imag + x.imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125;;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按a.operator + (b)实现</span><br></code></pre></td></tr></table></figure><p>以全局函数重载复数的“+”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2);<br>&#125;;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2)<br>&#123;<br>Complex tmp;<br>tmp.real = c<span class="hljs-number">1.</span>real + c<span class="hljs-number">2.</span>real;<br>tmp.imag = c<span class="hljs-number">1.</span>imag + c<span class="hljs-number">2.</span>imag;<br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span>, c</span>;<br>c = a + b; <span class="hljs-comment">// 按operator+(a, b)实现</span><br></code></pre></td></tr></table></figure><p>操作符重载的基本原则</p><ul><li>只能重载 C++语言中已有的操作符，不可臆造新的操作符。</li><li>可以重载 C++中除下列操作符外的所有操作符： “. ”， “.* ”，“?: ”，“:: ”，“sizeof ”</li><li>需要遵循已有操作符的语法：<ul><li>不能改变操作数的个数。</li><li>原操作符的优先级和结合性不变。</li></ul></li><li>尽量遵循已有操作符原来的语义：<ul><li>语言本身没有对此做任何规定，使用者自己把握 ！</li></ul></li></ul><h2 id="双目操作符重载">双目操作符重载</h2><h3 id="作为成员函数重载">作为成员函数重载</h3><ul><li>只需要提供一个参数，它对应第二个操作数（第一个操作数则由隐藏的参数 this 给出）。</li></ul><p>复数的不等于和等于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-type">double</span> real, imag;<br><span class="hljs-keyword">public</span>:<br>......<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> ==(<span class="hljs-type">const</span> Complex&amp; x) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-built_in">return</span> (real == x.real) &amp;&amp; (imag == x.imag);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> !=(<span class="hljs-type">const</span> Complex&amp; x) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-built_in">return</span> (real != x.real) || (imag != x.imag);<br>&#125;<br>&#125;;<br>......<br>Complex c1,c2;<br>......<br><span class="hljs-keyword">if</span> (c1 == c2) <span class="hljs-comment">//或 if (c1 != c2) ......</span><br></code></pre></td></tr></table></figure><h3 id="作为全局（友元）函数重载">作为全局（友元）函数重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123;<br><span class="hljs-type">double</span> real, imag;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Complex</span>() &#123; real = <span class="hljs-number">0</span>; imag = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) &#123; real = r; imag = i; &#125;<br>......<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2);<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c, <span class="hljs-type">double</span> d);<br><span class="hljs-keyword">friend</span> Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">double</span> d, <span class="hljs-type">const</span> Complex&amp; c);<br>&#125;;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c1, <span class="hljs-type">const</span> Complex&amp; c2)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(c<span class="hljs-number">1.</span>real+c<span class="hljs-number">2.</span>real,c<span class="hljs-number">1.</span>imag+c<span class="hljs-number">2.</span>imag);<br>&#125;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Complex&amp; c, <span class="hljs-type">double</span> d)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(c.real+d,c.imag);<br>&#125;<br>Complex <span class="hljs-keyword">operator</span> + (<span class="hljs-type">double</span> d, <span class="hljs-type">const</span> Complex&amp; c)<br><span class="hljs-comment">//“实数+复数”只能作为全局函数重载。为什么？</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(d+c.real,c.imag);<br>&#125;<br>......<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>,<span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span>,c1,c2,c3</span>;<br>c1 = a + b;<br>c2 = b + <span class="hljs-number">21.5</span>;<br>c3 = <span class="hljs-number">10.2</span> + a;<br></code></pre></td></tr></table></figure><h2 id="单目操作符重载">单目操作符重载</h2><h3 id="作为成员函数重载-2">作为成员函数重载</h3><p>复数的取负操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123; ......<br><span class="hljs-keyword">public</span>:<br> ......<br> Complex <span class="hljs-keyword">operator</span> -() <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(-real, -imag); &#125;<br> &#125;;<br> ......<br> <span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span>,b</span>;<br> b = -a; <span class="hljs-comment">//把a的负数赋值给b</span><br></code></pre></td></tr></table></figure><h3 id="作为全局（友元）函数重载-2">作为全局（友元）函数重载</h3><p>判断复数是否为“零”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span><br>&#123; ......<br><span class="hljs-keyword">public</span>:<br> ......<br> <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> !(<span class="hljs-type">const</span> Complex &amp;c);<br> &#125;;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> !(<span class="hljs-type">const</span> Complex &amp;c)<br>&#123;<br><span class="hljs-keyword">return</span> (c.real == <span class="hljs-number">0.0</span>) &amp;&amp; (c.imag == <span class="hljs-number">0.0</span>);<br>&#125;<br>......<br><span class="hljs-function">Complex <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</span></span>;<br>......<br><span class="hljs-keyword">if</span> (!a) <span class="hljs-comment">//a为0时true</span><br></code></pre></td></tr></table></figure><h2 id="操作符-和–的重载">操作符++和–的重载</h2><p>单目操作符++（–）：</p><ul><li>它们只有一个操作数，并且该操作数为一个左值表达式</li><li>它们是带<strong>副作用</strong>的操作符：得到一个计算结果的同时会改变操作数的值！</li></ul><p>为了能够区分++（–）的前置与后置用法， 可以为后置用法再写一个重载函数，该重载函数应有一个<strong>额外的 int 型参数</strong>，但函数体中不会使用该参数的值，它只是用于从形式上把后置的重载函数与前置的重载函数区分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span><br>&#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Counter</span>() &#123;value = <span class="hljs-number">0</span>;&#125;<br>Counter&amp; <span class="hljs-keyword">operator</span> ++()<span class="hljs-comment">// 前置的++重载函数</span><br>&#123;<br>value++;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-type">const</span> Counter <span class="hljs-keyword">operator</span> ++(<span class="hljs-type">int</span>) <span class="hljs-comment">// 后置的++重载函数</span><br>&#123;<br>Counter tmp = *<span class="hljs-keyword">this</span>;<br>value++; <span class="hljs-comment">// ++(*this) 调用前置的++重载函数</span><br><span class="hljs-keyword">return</span> tmp;<br>&#125;<br>&#125;;<br>Counter a,b;<br>++a; <span class="hljs-comment">//使用的是不带参数的操作符++重载函数</span><br>a++; <span class="hljs-comment">//使用的是带int型参数的操作符++重载函数</span><br>b = (++a); <span class="hljs-comment">//把加一之后a的值赋值给b</span><br>b = (a++); <span class="hljs-comment">//把加一之前a的值赋值给b</span><br>++(++a);或 (++a)++; <span class="hljs-comment">//OK，a加2</span><br>++(a++);或 (a++)++; <span class="hljs-comment">//Error，编译不通过</span><br></code></pre></td></tr></table></figure><h1>C++特殊操作符的重载</h1><h2 id="赋值操作符“-”">赋值操作符“=”</h2><p>C++编译程序会为每个类定义一个<strong>隐式的</strong>赋值操作，其行为是：逐个成员进行赋值操作。</p><ul><li>对于普通成员，它采用常规的赋值操作。</li><li>对于成员对象，则调用该成员对象类的赋值操作进行成员对象的赋值操作。</li></ul><p>直接赋值，<strong>问题</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;xyz&quot;</span>)</span>,<span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;abcdefg&quot;</span>)</span></span>;<br>.......<br>s1 = s2;<br></code></pre></td></tr></table></figure><ul><li>s 1. str 原来指向的空间丢失了（内存泄露）</li><li>s 1 和 s 2 互相干扰</li><li>s 1 和 s 2 消亡时，&quot;abcdefg&quot;所在的空间将会被释放两次</li></ul><p><img src="2025031569.png" alt=""></p><p><strong>解决</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br>......<br>String&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> String&amp; s)<br>&#123;<br><span class="hljs-keyword">if</span> (&amp;s == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//防止自身赋值：a=a</span><br><span class="hljs-keyword">delete</span> []str; <span class="hljs-comment">//归还str原来指向的空间</span><br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[s.len<span class="hljs-number">+1</span>]; <span class="hljs-comment">//申请新的空间</span><br><span class="hljs-built_in">strcpy</span>(str,s.str); <span class="hljs-comment">//把用于赋值的字符串复制到新空间中</span><br>len = s.len; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的返回值类型能是 void 吗？为什么是 String 并且是它的引用？</p><ul><li>为了允许下面的操作： s 1=(s 2=s 3) 和 (s 1=s 2)=s 3</li></ul><p>如果有<strong>成员对象</strong>，自定义的赋值操作符重载函数不会自动去调用成员对象类的赋值操作，需要在自定义的赋值操作符重载函数中显式指出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; ...... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br>......<br>B&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> B&amp; b)<br>&#123;<br><span class="hljs-keyword">if</span> (&amp;b == <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>a = b.a;<span class="hljs-comment">//调用A类的赋值操作符重载函数来实现成员对象的赋值。</span><br>x = b.x;<br>y = b.y;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>一般来讲，需要自定义拷贝构造函数的类通常也需要自定义赋值操作符重载函数。<br>注意：要区别下面两个“=”的不同含义:<br><code>A a;</code></li><li><code>A b=a;</code> //初始化，等价于：A b (a);，调用拷贝构造函数。</li><li><code>b = a; </code> //赋值，调用赋值操作符=重载函数。</li></ul><p><strong>赋值操作符重载存在的问题</strong></p><p>当用于赋值的对象是一个<strong>临时或即将消亡</strong>的对象时，目前的赋值操作符重载函数的实现效率有时是不高的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">A <span class="hljs-title">f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//返回一个A类的临时对象作为返回值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>; <span class="hljs-comment">//调用构造函数申请空间</span><br>......<br>a = <span class="hljs-built_in">f</span>();<br><span class="hljs-comment">//把函数f返回值对象赋值给对象a：</span><br><span class="hljs-comment">//1. 调用赋值操作符重载函数（为a归还老空间、 申请新空间并进行内容复制）</span><br><span class="hljs-comment">//2. 函数f返回值对象消亡（调用析构函数归还空间）</span><br>......<br>&#125; <span class="hljs-comment">//对象a消亡（调用析构函数归还空间）</span><br></code></pre></td></tr></table></figure><p>-&gt; <strong>转移赋值操作符重载函数</strong> move assignment operator</p><ul><li><code>A&amp; operator=(A&amp;&amp; x)</code> //参数为右值引用类型：&amp;&amp;</li></ul><p>当用于赋值的对象是一个临时的或即将消亡的对象时，</p><ul><li>如果对象类中有转移赋值操作符重载函数，则会去调用它来实现对象的赋值。</li><li>否则将调用普通的赋值操作符重载函数来实现对象的赋值。 （注意：系统不会提供隐式的转移赋值操作符重载函数）</li></ul><p>在转移赋值操作符重载函数中实现资源的转移:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; x)<br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">delete</span> []p; <span class="hljs-comment">//归还老空间</span><br>p = x.p; <span class="hljs-comment">//使用参数对象的空间（资源转移）</span><br>x.p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//使得参数对象不再拥有该空间</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组元素访问操作符“-”">数组元素访问操作符“[]”</h2><p>对于由具有线性关系的元素所构成的对象，可通过重载下标操作符“[]”来实现对其元素的<strong>访问</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br>......<br><span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> str[i]; &#125;<br><span class="hljs-type">char</span> <span class="hljs-keyword">operator</span> [](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> str[i];&#125; <span class="hljs-comment">//用于常量对象</span><br>&#125;;<br>......<br><span class="hljs-function">String <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>cout &lt;&lt; s[<span class="hljs-number">0</span>]; <span class="hljs-comment">//输出：A</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* data; <span class="hljs-comment">// 存储一行元素的指针</span><br><span class="hljs-type">int</span> size; <span class="hljs-comment">// 当前行的列数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Vector</span>(<span class="hljs-type">int</span> s) : <span class="hljs-built_in">size</span>(s) &#123; data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// 动态分配数组 &#125;</span><br>~<span class="hljs-built_in">Vector</span>() &#123; <span class="hljs-keyword">delete</span>[] data; <span class="hljs-comment">// 释放内存 &#125;</span><br><span class="hljs-type">int</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> data[j]; <span class="hljs-comment">// 返回对应元素的引用 &#125;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> size; <span class="hljs-comment">// 返回当前行的列数 &#125;</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Matrix</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>Vector** p_data; <span class="hljs-comment">// 二维数组，指向行的 Vector 对象</span><br><span class="hljs-type">int</span> row, col; <span class="hljs-comment">// 矩阵的行数和列数</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) : <span class="hljs-built_in">row</span>(r), <span class="hljs-built_in">col</span>(c)<br>&#123;<br>p_data = <span class="hljs-keyword">new</span> Vector*[row]; <span class="hljs-comment">// 为行分配内存</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)<br>&#123;<br>p_data[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Vector</span>(col); <span class="hljs-comment">// 为每一行分配列的内存</span><br>&#125;<br>&#125;<br><br>~<span class="hljs-built_in">Matrix</span>()<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)<br>&#123;<br><span class="hljs-keyword">delete</span> p_data[i]; <span class="hljs-comment">// 释放每一行的内存</span><br>&#125;<br><span class="hljs-keyword">delete</span>[] p_data; <span class="hljs-comment">// 释放行的内存</span><br>&#125;<br>Vector&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i)<br>&#123;<br><span class="hljs-keyword">return</span> *p_data[i]; <span class="hljs-comment">// 返回对应行的 Vector</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="函数调用操作符“-”">函数调用操作符“()”</h2><p>在 C++中，把函数调用也作为一种操作符来看待：</p><ul><li>操作符为 ()，操作数为函数名及各个实参，结果为函数返回值</li><li>例如：10+f (x, y)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; value = i; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span> <span class="hljs-comment">//函数调用操作符()的重载函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x*y+value;<br>&#125;<br>&#125;;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//a是个对象</span><br>cout &lt;&lt; a.<span class="hljs-built_in">g</span>() &lt;&lt;endl; <span class="hljs-comment">//把a当对象来用</span><br>cout &lt;&lt; <span class="hljs-number">10</span>+<span class="hljs-built_in">a</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) &lt;&lt; endl;<br><span class="hljs-comment">//把a当函数来用！</span><br><span class="hljs-comment">//a(10,20)等价于：a.operator()(10,20)</span><br>......<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A&amp; f)</span> <span class="hljs-comment">//f是个对象</span></span><br><span class="hljs-function"></span>&#123; ... <span class="hljs-number">10</span>+<span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>) ...<br><span class="hljs-comment">//把f当函数来使用</span><br><span class="hljs-comment">//f(10,20)等价于：f.operator()(10,20)</span><br>&#125;<br>......<br><span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//把对象a传给f</span><br></code></pre></td></tr></table></figure><p>函数对象除了具有一般函数的行为外，它还可以拥有状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomNum</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> seed; <span class="hljs-comment">//状态</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">RandomNum</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i) &#123; seed = i; &#125;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-comment">//函数调用操作符重载</span></span><br><span class="hljs-function"></span>&#123;<br>seed = (<span class="hljs-number">25173</span>*seed<span class="hljs-number">+13849</span>)%<span class="hljs-number">65536</span>; <span class="hljs-comment">//修改了状态</span><br><span class="hljs-keyword">return</span> seed;<br>&#125;<br>&#125;;<br>......<br><span class="hljs-function">RandomNum <span class="hljs-title">random_num</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">//创建一个函数对象</span><br>... <span class="hljs-built_in">random_num</span>() ... <span class="hljs-comment">//把函数对象当作一个函数，调用它产生一个随机数</span><br></code></pre></td></tr></table></figure><p><strong>λ 表达式</strong><br>编译器：</p><ul><li>首先，隐式定义一个类：<ul><li>数据成员对应 λ 表达式中用到的环境变量（[…]），在构造函数中用环境变量对它们进行初始化。</li><li>按相应 λ 表达式的函数功能重载了函数调用操作符。</li></ul></li><li>然后，创建上述类的一个临时对象（设为 obj）</li><li>最后，在使用上述 λ 表达式的地方用 obj 来替代：<ul><li>作用于实参进行函数调用对于：<code>cout &lt;&lt; [...](int x)-&gt;int &#123; ....... &#125;(3);</code> 替换成：<code>cout &lt;&lt; obj(3);</code></li><li>传给其它函数对于：<code>f([...](int x)-&gt;int &#123; ....... &#125;); </code> 替换成：<code>f (obj);</code></li></ul></li></ul><h2 id="间接类成员访问操作符“-”-智能指针">间接类成员访问操作符“-&gt;” 智能指针</h2><p>“-&gt;”为一个双目操作符：</p><ul><li>第一个操作数为一个指向类或结构的指针。</li><li>第二个操作数为第一个操作数所指向的类或结构的成员。<br>例如:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br>A *p = &amp;a;<br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//通过p访问对象a的成员函数f</span><br></code></pre></td></tr></table></figure><p>可以针对某个类重载“-&gt;”操作符，这样就可以把该类的对象当指针来用，实现一种智能指针（smart pointers）</p><ul><li>通过智能指针去访问它指向的对象成员之前能做一些额外的事情。（在操作符-&gt;重载函数中实现）</li></ul><p><img src="2025031586.png" alt=""></p><p>在 C++中，智能指针主要用于对动态对象的空间进行管理。在 C++标准库（基于模板实现）提供了一些智能指针类型，其中包括：</p><ul><li>shared_ptr：带引用计数，利用它能够实现动态对象空间的自动回收。</li><li>unique_ptr：独占动态对象。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br>~<span class="hljs-built_in">A</span>()&#123; cout &lt;&lt; <span class="hljs-string">&quot;In A&#x27;s destructor\n&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">1</span>))</span></span>; <span class="hljs-comment">//创建第一个动态对象，其引用计数为1</span><br>p1-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用第一个动态对象的成员函数f，输出1</span><br><span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">2</span>))</span></span>; <span class="hljs-comment">//创建第二个动态对象，其引用计数为1</span><br>p2-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用第二个动态对象的成员函数f，输出2</span><br>p1 = p2; <span class="hljs-comment">//第一个对象的引用计数减1（变成0），第一个对象自动消亡</span><br><span class="hljs-comment">//第二个对象的引用计数加1（变成2）</span><br>......<br>p2 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1（变成1）</span><br>p1-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用第二个动态对象的成员函数f，输出2</span><br>p1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1(变成0)，第二个对象自动消亡</span><br>......<br><span class="hljs-function">unique_ptr&lt;A&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">3</span>))</span></span>; <span class="hljs-comment">//创建第三个动态对象</span><br><span class="hljs-function">unique_ptr&lt;A&gt; <span class="hljs-title">p4</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A(<span class="hljs-number">4</span>))</span></span>; <span class="hljs-comment">//创建第四个动态对象</span><br>p3 = p4; <span class="hljs-comment">//Error，第四个对象被p4独占</span><br>p3 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第三个对象消亡</span><br>p4 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第四个对象消亡</span><br><br></code></pre></td></tr></table></figure><h2 id="操作符-new-与-delete-的重载">操作符 new 与 delete 的重载</h2><p>操作符 new 必须作为静态的成员函数来重载 （static 说明可以不写），其格式为：</p><ul><li><code>void *operator new(size_t size);</code></li><li>返回类型必须为 void *</li><li>参数 size 表示对象所需空间的大小，其类型为 size_t（unsigned int）</li></ul><p>例：把动态对象初始化为全‘0’</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">void</span> *p=<span class="hljs-built_in">malloc</span>(size); <span class="hljs-comment">//调用系统堆空间分配操作。</span><br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,size); <span class="hljs-comment">//把申请到的堆空间初始化为全“0”。</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于 new 的重载函数，除了对象空间大小参数以外，它也可以带有其它参数：</p><ul><li>void *operator new (size_t size,…);</li></ul><p>对带有其它参数的 new 重载函数，其使用格式为：</p><ul><li>p = new (…) A (…);</li><li>前者… 表示提供给 new 重载函数的其它参数</li><li>后者… 表示提供给 A 类构造函数的参数</li></ul><p>例：在非“堆区”为动态对象分配空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; x=i; y=j; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> p; &#125;<br>&#125;;<br>......<br><span class="hljs-type">char</span> buf[<span class="hljs-built_in">sizeof</span>(A)];<br>A *p=<span class="hljs-built_in">new</span> (buf) <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//动态对象的空间分配为buf</span><br>......<br>p-&gt;~<span class="hljs-built_in">A</span>(); <span class="hljs-comment">//使得p所指向的对象消亡。</span><br><span class="hljs-comment">//不能用系统的delete，可以用自己重载的delete</span><br></code></pre></td></tr></table></figure><p>操作符 delete 也必须作为静态的成员函数来重载 （static 说明可以不写），其格式为：</p><ul><li><code>void operator delete (void *p, size_t size);</code></li><li>返回类型必须为 void。</li><li>第一个参数类型为 void *，指向对象的内存空间。</li><li>第二个参数可有可无，如果有，则必须是 size_t 类型。</li><li>重载后，操作符 delete 的使用格式与未重载的相同。</li></ul><p>例：重载操作符 new 与 delete 来管理程序中某类动态对象的堆空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123; ...... <span class="hljs-comment">//类A原有的成员说明</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span></span>;<br> <span class="hljs-keyword">private</span>:<br> A *next; <span class="hljs-comment">//用于组织A类对象自由空间链表</span><br> <span class="hljs-type">static</span> A *p_free; <span class="hljs-comment">//用于指向A类对象的自由空间链表头</span><br>&#125;;<br>A *A::p_free=<span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM=<span class="hljs-number">32</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *A::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (p_free == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//创建第一个A类动态对象</span><br>&#123; <span class="hljs-comment">//申请NUM个A类对象的大空间。</span><br>p_free = (A *)<span class="hljs-built_in">malloc</span>(size*NUM); <span class="hljs-comment">//一个动态数组</span><br><span class="hljs-comment">//在大空间上建立自由空间链表（链表结点初始是连续的）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NUM<span class="hljs-number">-1</span>; i++)<br>p_free[i].next = &amp;p_free[i<span class="hljs-number">+1</span>];<br>p_free[NUM<span class="hljs-number">-1</span>].next = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//从链表中给当前动态对象分配空间</span><br> A *p=p_free;<br> p_free = p_free-&gt;next;<br> <span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0</span>,size); <span class="hljs-comment">//可由构造函数完成</span><br> <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> A::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *p)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">//把p指向的空间还到自由空间链表中</span><br>((A *)p)-&gt;next = p_free;<br>p_free = (A *)p;<br>&#125;<br>......<br>A *q1=<span class="hljs-keyword">new</span> A;<br>A *q2=<span class="hljs-keyword">new</span> A;<br><span class="hljs-keyword">delete</span> q1;<br></code></pre></td></tr></table></figure><p><img src="2025031509.png" alt=""></p><p>C++标准库（基于模板实现）提供了一个函数 make_shared，它能创建自带引用计数的动态对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; ...... &#125;<br>&#125;;<br><span class="hljs-comment">//创建第一个动态对象（其x为1，由p1指向），该对象的引用计数为1</span><br>shared_ptr&lt;A&gt; p1=<span class="hljs-built_in">make_shared</span>&lt;A&gt;(<span class="hljs-number">1</span>);<br>p1-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">//调用p1指向的对象的成员函数f</span><br><span class="hljs-comment">//创建第二个动态对象（其x为2，由p2指向），该对象的引用计数为1</span><br>shared_ptr&lt;A&gt; p2=<span class="hljs-built_in">make_shared</span>&lt;A&gt;(<span class="hljs-number">2</span>);<br>p1 = p2; <span class="hljs-comment">//第一个对象的引用计数减1（变成0），第一个对象自动消亡</span><br><span class="hljs-comment">//第二个对象的引用计数加1（变成2）</span><br>p2 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1（变成1）</span><br>p1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//第二个对象的引用计数减1(变成0),第二个对象自动消亡</span><br></code></pre></td></tr></table></figure><h2 id="自定义类型转换操作符">自定义类型转换操作符</h2><p><img src="2025031516.png" alt=""><br><img src="2025031504.png" alt=""></p><p>歧义问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123; x = i; y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j) &#123; x = i; y = j; &#125;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x+y; &#125;<br><span class="hljs-keyword">friend</span> A <span class="hljs-keyword">operator</span> +(<span class="hljs-type">const</span> A &amp;a1, <span class="hljs-type">const</span> A &amp;a2);<br>&#125;;<br>......<br>A a;<br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>... (a + i) ... <span class="hljs-comment">//是把a转换成int呢，还是把i转换成A呢？</span><br></code></pre></td></tr></table></figure><p><img src="2025031564.png" alt=""><br><img src="2025031512-1.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-3-类的成员函数和友元</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h1>常成员函数及静态成员</h1><h2 id="常成员函数">常成员函数</h2><ul><li>为了防止在一个获取对象状态的成员函数中无意中修改对象数据成员的值，可以把它说明成常成员函数</li><li>编译器一旦发现在常成员函数中修改数据成员的值，将会报错</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span> </span>&#123; year=y; month=m; day=d; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> day; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Date::get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> month; &#125;<br></code></pre></td></tr></table></figure><ul><li>对常量对象只能调用类中的常成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> y, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> d)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_day</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_month</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_year</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>......<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> Date &amp;d)</span> <span class="hljs-comment">//d引用的是个常量对象！</span></span><br><span class="hljs-function"></span>&#123;<br>... d.<span class="hljs-built_in">get_day</span>() ... <span class="hljs-comment">//OK</span><br>... d.<span class="hljs-built_in">get_month</span>() ... <span class="hljs-comment">//OK</span><br>... d.<span class="hljs-built_in">get_year</span>() ... <span class="hljs-comment">//OK</span><br>d.<span class="hljs-built_in">set</span> (<span class="hljs-number">2011</span>,<span class="hljs-number">3</span>,<span class="hljs-number">23</span>); <span class="hljs-comment">//Error</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="静态数据成员">静态数据成员</h2><ul><li>采用静态数据成员可以更好地实现<strong>同一个类的不同对象之间的数据共享</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> x; <span class="hljs-comment">// 静态数据成员声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;y = x; x++; &#125; <span class="hljs-comment">// 访问共享的x</span><br>&#125;;<br><span class="hljs-type">int</span> A::x=<span class="hljs-number">0</span>; <span class="hljs-comment">// 静态数据成员定义及初始化</span><br>A a, b;<br>a.<span class="hljs-built_in">f</span>();<br>b.<span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure><ul><li>类的静态数据成员对该类的所有对象只有一个拷贝</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x,y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123; x = y = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increase_all</span><span class="hljs-params">()</span> </span>&#123; x++; y++; shared++; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_all</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x+y+shared; &#125;<br>......<br>&#125;;<br><span class="hljs-type">int</span> A::shared=<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h2 id="静态成员函数">静态成员函数</h2><ul><li>静态成员函数只能访问类的静态成员</li><li>静态成员函数没有隐藏的 this 函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123;x = y = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get_shared</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> shared;&#125; <span class="hljs-comment">// 静态成员函数</span><br>&#125;;<br><span class="hljs-type">int</span> A::shared = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><ul><li>静态成员除了通过对象来访问外，也可以直接通过类来访问。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a;<br>cout &lt;&lt; a.<span class="hljs-built_in">get_shared</span>();<br>cout &lt;&lt; A::<span class="hljs-built_in">get_shared</span>();<br></code></pre></td></tr></table></figure><h1>友元</h1><p>某些情况下，为了提高在类的外部对类数据成员的访问效率，在 C++中，</p><ul><li>可以指定某些与一个类密切相关的、又<strong>不适合</strong>作为该类成员的程序实体能直接访问该类的非 public 成员，这些程序实体称为该类的友元。</li><li>友元是<strong>数据保护和数据访问效率</strong>之间的一种折衷方案。</li></ul><p>友元需要在类中用 friend 显式指出，它们可以是</p><ul><li>全局函数</li><li>其它类的所有成员函数</li><li>其它类的某个成员函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 全局函数func可访问x</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 类B的所有成员函数可访问x</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">C::f</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 类C的成员函数f可访问x</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>友元不是一个类的成员。</li><li>友元关系具有不对称性。例如：假设 B 是 A 的友元，如果没有显式指出 A 是 B 的友元，则 A 不是 B 的友元。</li><li>友元也不具有传递性。例如：假设 C 是 B 的友元、B 是 A 的友元，如果没有显式指出 C 是 A 的友元，则 C 不是 A 的友元。<br><img src="2025031500.png" alt=""></li></ul><p>multiply 的实现 2<br><img src="2025031501.png" alt=""><br><img src="2025031595-1.png" alt=""></p><h1>类作为模块</h1><p>一个模块包含接口和实现两部分：</p><ul><li>接口：是指在模块中定义的、可以被其它模块使用的一些程序实体的声明描述。</li><li>实现：是指在模块中定义的所有程序实体的具体实现描述。</li></ul><p>在面向对象程序中，类是一个自然的模块划分单位，一个类构成一个模块，模块边界比较清晰。</p><p>C++程序的一个模块由两部分构成：</p><ul><li>接口：类的定义，存放在一个. h 文件中</li><li>实现：类的实现（包括类的定义和在类外定义的成员函数），存放在一个. cpp 文件中。<br><img src="2025031517.png" alt=""></li></ul><h2 id="Demeter-法则">Demeter 法则</h2><p>一个类的成员函数</p><ul><li>除了能访问自身类结构的直接子结构（本类的数据成员）外，不能以任何方式依赖于任何其它类的结构。</li><li>只应向某个有限集合中的对象发送消息。</li></ul><p>核心思想：“仅与你的直接朋友交谈！”<br><img src="2025031587.png" alt=""></p><p>类表达形式</p><p>对于类 C 中的任何成员函数 M，M 中只能向以下类的对象发送消息：</p><ul><li>类 C 本身。</li><li>成员函数 M 的参数类。</li><li>M 或 M 所调用的成员函数中创建的对象所属的类。</li><li>全局对象所属的类。</li><li>类 C 的成员对象所属的类。</li></ul><p>对象表达形式</p><p>对于类 C 中的任何成员函数 M，M 中只能向以下的对象发送消息：</p><ul><li>this 指向的对象。</li><li>成员函数 M 的参数对象。</li><li>M 或 M 所调用的成员函数所创建的对象。</li><li>全局变量中包含的对象。</li><li>类 C 的成员对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-2-对象与类</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1>对象与类</h1><h2 id="类成员">类成员</h2><h3 id="数据成员-：">数据成员 ：</h3><p>对对象所包含的数据描述，它们可以是常量和变量，类型可以是任意的 C++类型（void 除外）</p><p>在类中说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的<strong>指针或引用</strong>类型。<br><img src="2025031556.png" alt=""></p><h3 id="成员函数">成员函数</h3><ul><li>对对象包含的数据所能实施的操作描述。</li><li>成员函数名是可以重载的，它遵循一般函数名的重载规则。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">B::f</span><span class="hljs-params">()</span> </span>&#123;...&#125; <span class="hljs-comment">// 类名受限</span><br></code></pre></td></tr></table></figure><h3 id="类成员的访问控制">类成员的访问控制</h3><ul><li>public 访问不受限制</li><li>private 只能在本类和友元中访问</li><li>protected 只能在本类、友元和派生类的代码中访问</li></ul><h2 id="对象">对象</h2><ul><li>类属于类型范畴的程序实体，它一般存在于静态的程序（编译程序看到的）中。</li><li>动态的面向对象程序（运行中的）则是由对象构成。</li><li>对象在程序运行时创建。</li></ul><h3 id="创建和标识">创建和标识</h3><p>直接方式：</p><ul><li>对象在进入相应变量的生存期时创建，通过变量名来标识和访问。相应变量的生存期结束时，对象消亡。</li></ul><p>间接方式：</p><ul><li>在程序运行时刻，用 new 操作来创建对象（称为动态对象），用 delete 操作来撤消它（使之消亡）。动态对象需要通过指针来标识和访问。</li></ul><h3 id="成员对象">成员对象</h3><ul><li>对于类的数据成员，其类型可以是另一个类。即， 一个对象可以包含另一个对象，后者称为成员对象。</li><li>成员对象跟随包含它的对象一起创建和消亡。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;...&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a; <span class="hljs-comment">// 成员对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象的操作">对象的操作</h3><ul><li>对于创建的一个对象，需要通过向它发送消息（调用对象类中定义的某个 public 成员函数）来对它进行操作</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br>a.<span class="hljs-built_in">f</span>();<br>A *p = <span class="hljs-keyword">new</span> A; <span class="hljs-comment">// 动态对象</span><br>p-&gt;<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// (*p).f()</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在类的外部访问类的成员时要受到类成员访问控制的限制</li><li>可以对同类对象进行赋值</li><li>把对象作为参数传给函数</li><li>把对象作为函数的返回值<br><img src="2025031550.png" alt=""></li></ul><h1>this 指针</h1><ul><li>类中描述的数据成员（静态数据成员除外）对该类的每个对象分别有一个拷贝。</li><li>成员函数对该类所有对象只有一个拷贝 - 类的每一个成员函数（静态成员函数除外）都有一个隐藏的形参 this，其类型为该类<strong>对象的指针</strong>；在成员函数中对类成员的访问是通过 this 来进行的。 - 当通过对象访问类的成员函数时，将会把<strong>相应对象的地址</strong>传给成员函数的参数 this。<br>指向成员函数的指针：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>&#125;<br><br><span class="hljs-built_in">void</span> (*p)(<span class="hljs-type">int</span>) = &amp;A::f1; <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">void</span> (A::*p)(<span class="hljs-type">int</span>) = &amp;A::f1; <span class="hljs-comment">// 或者 auto p = &amp;A::f1;</span><br>A a;<br>(a.*p)(<span class="hljs-number">10</span>)； <span class="hljs-comment">// 调用a.f1</span><br>p = &amp;A::f2;<br>(a.*p)(<span class="hljs-number">10</span>); <span class="hljs-comment">// 调用a.f2</span><br></code></pre></td></tr></table></figure><ul><li>一般情况下，在类的成员函数中访问类的成员时不必显式使用 this 指针，编译程序会自动加上</li><li>但如果成员函数中要把 this 所指向的对象作为整体来操作，则需要显式地使用 this 指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A *p)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;x = i; <span class="hljs-built_in">func</span>(<span class="hljs-keyword">this</span>)&#125;<br>&#125;<br>A a, b;<br>a.<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 在g中调用func(&amp;a)</span><br>b.<span class="hljs-built_in">g</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 在g中调用func(&amp;b)</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">A&amp; <span class="hljs-title">inc1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>++x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回对象自己</span><br>&#125;<br><span class="hljs-function">A <span class="hljs-title">inc2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br> ++x;<br> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 返回对象的备份</span><br> &#125;<br>&#125;<br><br>A a;<br>a.<span class="hljs-built_in">inc1</span>().<span class="hljs-built_in">inc1</span>(); <span class="hljs-comment">//把a.x增加了2，第一个inc1返回的是a</span><br>a.<span class="hljs-built_in">inc2</span>().<span class="hljs-built_in">inc2</span>(); <span class="hljs-comment">//把a.x增加了1，第一个inc2返回的是a的备份</span><br></code></pre></td></tr></table></figure><h1>对象的初始化与消亡</h1><h2 id="构造函数">构造函数</h2><ul><li>它是类的特殊成员函数，名字与类名相同、无返回值类型</li><li>创建对象时，构造函数会被自动调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>() &#123;x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数可以重载，其中，不带参数的（或所有参数都有默认值的）构造函数被称为默认构造函数</li><li>在程序中也可以通过类的构造函数来创建一些临时对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A a)</span></span>&#123;...&#125;<br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><ul><li>对象创建后，不能再调用构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">A a;<br>a.<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><p><strong>成员初始化表</strong></p><ul><li>初始化次序由它们在类定义中的描述次序来决定</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> y;<br><span class="hljs-type">int</span>&amp; z;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>():<span class="hljs-built_in">z</span>(x), <span class="hljs-built_in">y</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 成员初始化表</span><br>&#123;<br>x = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="析构函数">析构函数</h2><ul><li>没有返回类型、不带参数、不能被重载</li><li>一个对象消亡时，系统在收回它的内存空间之前，将会自动调用对象类中的析构函数</li><li>可以在析构函数中完成对象被删除前的一些清理工作</li><li>一般情况下，类中不需要自定义析构函数，但如果对象创建后， 自己又<strong>额外申请</strong>了资源（如：额外申请了内存空间），则可以自定义析构函数来归还它们</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(s);<br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(str, s);<br>&#125;<br>~<span class="hljs-built_in">String</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 归还额外申请的空间</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>除了在对象消亡时会被自动调用外，也可以在对象生存期内显式调用，这时并不是让对象消亡，而是暂时归还对象额外申请的资源</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br>s<span class="hljs-number">1.</span>~<span class="hljs-built_in">String</span>(); <span class="hljs-comment">//把字符串s1清空，对象并未消亡！</span><br>s1 <span class="hljs-comment">//仍然可以使用对象s1</span><br></code></pre></td></tr></table></figure><h3 id="成员对象的初始化和消亡处理">成员对象的初始化和消亡处理</h3><ul><li>通常是调用成员对象类的默认构造函数</li><li>如果要调用成员对象类的非默认构造函数，需要在包含成员对象的对象类的构造函数成员初始化表中显式指出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>()&#123;x = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i) &#123;x = i;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>() &#123;y = <span class="hljs-number">0</span>;&#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) &#123;y = i;&#125;<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j): <span class="hljs-built_in">a</span>(j) &#123;y = i;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>创建时：</p><ul><li>先调用本身类的构造函数，但在<strong>进入函数体之前</strong>， 会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体</li><li>若包含多个成员对象，这些成员对象构造函数的调用次序则按它们在本对象类中的说明次序进行<br>消亡时：</li><li>先调用本身类的析构函数，本身类析构函数的函数体<strong>执行完之后</strong>，再去调用成员对象类的析构函数</li><li>如果有多个成员对象，则成员对象析构函数的调用次序按它们在本对象类中的<strong>说明次序的逆序</strong>进行</li></ul><h1>拷贝构造函数&amp;转移构造函数</h1><h2 id="拷贝构造函数">拷贝构造函数</h2><ul><li>若一个构造函数的参数类型为本类的引用，则称它为拷贝构造函数</li><li>在创建一个对象时，若用另一个同类型的对象对其初始化，将会调用对象类中的拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>();<br><span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a); <span class="hljs-comment">// 拷贝构造函数</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>调用类的拷贝构造函数的情况：</p><ul><li>创建对象时显式指出</li><li>把对象作为值参数传给函数时</li><li>把对象作为函数的返回值时</li></ul><h3 id="隐式拷贝构造函数">隐式拷贝构造函数</h3><ul><li>在程序中，如果没有为某个类提供拷贝构造函数，则编译器将会为其生成一个隐式拷贝构造函数</li><li>隐式拷贝构造函数将逐个成员进行拷贝初始化<ul><li>对于非对象成员：它采用通常的拷贝操作</li><li>对于成员对象：则调用成员对象类的拷贝构造函数来对成员对象进行初始化（递归定义）</li></ul></li></ul><h3 id="自定义拷贝构造函数">自定义拷贝构造函数</h3><ul><li>在一些特殊情况下，必须要自定义拷贝构造函数，否则，将会产生设计者未意识到的严重的程序错误</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">char</span> *str;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(s);<br>str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len<span class="hljs-number">+1</span>];<br><span class="hljs-built_in">strcpy</span>(str,s);<br>&#125;<br>~<span class="hljs-built_in">String</span>() &#123; <span class="hljs-keyword">delete</span> []str; len=<span class="hljs-number">0</span>; str=<span class="hljs-literal">NULL</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;abcd&quot;</span>)</span></span>;<br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>隐式的拷贝构造函数将会使得 s1 和 s2 的成员指针 str 指向同一块内存区域<br><img src="2025031521.png" alt=""></li></ul><h2 id="转移构造函数">转移构造函数</h2><h3 id="右值引用类型">右值引用类型&amp;&amp;</h3><p>右值引用类型（用&amp;&amp;表示）</p><ul><li>当函数的参数类型为右值引用类型时，它将接受临时对象或即将消亡的对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp; x)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp;&amp; x)</span> </span>&#123;...&#125;<br>A a;<br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">// 调用f(A&amp;)</span><br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">A</span>()); <span class="hljs-comment">// 调用f(A&amp;&amp;) 因为A(创建的是一个临时对象)</span><br></code></pre></td></tr></table></figure><h3 id="move-constructor">move constructor</h3><p>转移构造函数其参数类型为右值引用</p><ul><li><code>A(A&amp;&amp; x)</code><br>当用一个临时对象或即将消亡的对象去初始化另一个对象时，</li><li>如果对象类中有转移构造函数，则会去调用转移构造函数进行对象初始化。</li><li>否则去调用普通拷贝构造函数进行对象初始化。（注意： 系统不会提供隐式转移构造函数！）</li></ul><p>可在转移构造函数中实现资源的转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">A</span>(A&amp;&amp; x)<br>&#123;<br>p = x.p; <span class="hljs-comment">//把参数对象x的p所指向的空间作为新对象的p所指向的空间（资源转移）</span><br>x.p = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//使得参数对象x的p不再拥有原来所指向的空间。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>不再为返回值对象额外申请空间和内容复制</li><li>对象 t 消亡时也不再归还原来申请的空间</li></ul><h3 id="move">move</h3><p>如何把一个左值对象传给一个实现资源转移的函数？</p><ul><li>可以用 STL 中的函数 move 把一个左值类型转换成右值类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp; x)</span> </span>&#123; ...... &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A&amp;&amp; x)</span> </span>&#123; ...... &#125; <span class="hljs-comment">//该函数实现资源转移</span><br>......<br>A a; <span class="hljs-comment">//a为一个左值对象</span><br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">//调用f(A&amp;)</span><br><span class="hljs-built_in">f</span>(std::<span class="hljs-built_in">move</span>(a)); <span class="hljs-comment">//把a转成右值，它会调用f(A&amp;&amp;)</span><br><span class="hljs-function">A <span class="hljs-title">a1</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">//调用拷贝构造函数实现资源的复制</span><br><span class="hljs-function">A <span class="hljs-title">a2</span><span class="hljs-params">(std::move(a))</span></span>; <span class="hljs-comment">//调用转移构造函数实现资源的转移</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-1-抽象封装</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1>λ 表达式</h1><ul><li>C++11 以后的国际标准为 C++提供了一种匿名函数机制――λ 表达式（lambda expression），利用它可以把函数的定义和使用二者合而为一。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求x^2定积分</span><br><span class="hljs-type">double</span> integrate（<span class="hljs-built_in">double</span>(*fp)(<span class="hljs-type">double</span>), <span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b）;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> x*x&#125;;<br><span class="hljs-built_in">integrate</span>(square, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// lambda表达式</span><br><span class="hljs-built_in">integrate</span>([](<span class="hljs-type">double</span> x)-&gt;<span class="hljs-type">double</span>&#123;<span class="hljs-keyword">return</span> x*x&#125;, <span class="hljs-number">0</span> , <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="2025031590.png" alt=""><br><img src="2025031575.png" alt=""><br><img src="2025031599.png" alt=""><br>使用方式：</p><ul><li>直接调用它定义的函数</li><li>把它定义的函数作为参数传给另一个函数（主要）</li></ul><p>ps: 编译时在内部给 lambda 表达式函数名，再使用时 call</p><h1>数据抽象与封装</h1><p>抽象：该程序实体<strong>外部</strong>可观察到的行为，使用者不考虑该程序实体的内部是如何实现的（复杂度控制）</p><p>封装：把该程序实体内部的具体实现细节对使用者隐藏起来，值对外提供一个接口（信息保护）</p><h2 id="过程抽象与封装">过程抽象与封装</h2><p>过程抽象</p><ul><li>用一个名字来代表一段完成一定功能的程序代码，代码的使用者只需要知道代码的名字以及相应的功能， 而不需要知道对应的程序代码是如何实现的。</li></ul><p>过程封装</p><ul><li>把命名代码的具体实现<strong>隐藏起来</strong>（对使用者不可见， 或不可直接访问），使用者只能通过代码名字来使用相应的代码。</li><li>命名代码所需要的数据是通过<strong>参数</strong>来获得，计算结果通过返回值机制返回。<blockquote><p>[!note]+<br>过程抽象与封装是基于功能分解与复合的过程式程序设计的基础。</p><ul><li>实现了过程抽象与封装</li><li>数据表示是公开的，缺乏保护</li></ul></blockquote></li></ul><h2 id="数据抽象与封装">数据抽象与封装</h2><p>数据抽象</p><ul><li>只描述对数据能实施哪些操作以及这些操作之间的关系，数据的使用者不需要知道数据的具体表示形式 （数组或链表等）。</li></ul><p>数据封装</p><ul><li>把数据及其操作作为一个整体（封装体）来进行实现， 其中，数据的具体表示被隐藏起来（使用者不可见， 或不可直接访问），对数据的访问（使用）只能通过封装体对外接口中提供的操作来完成。<blockquote><p>[!note]+<br>数据抽象与封装是面向对象程序设计的基础， 其中的对象体现了数据抽象与封装。</p></blockquote></li></ul><p>以栈为例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> STACK_SIZE=<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> buffer[STACK_SIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125;;<br>Stack::<span class="hljs-built_in">Stack</span>() &#123;<br>    top = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == STACK_SIZE - <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Stack is full&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    buffer[++top] = e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack::pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    e = buffer[top--];<br>&#125;<br><br><span class="hljs-comment">// 链表</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stack1</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> content;<br>        Node *next;<br>    &#125;;<br>    Node *top;<br>&#125;;<br><br>Stack1::<span class="hljs-built_in">Stack1</span>() &#123;<br>    top = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack1::push</span><span class="hljs-params">(<span class="hljs-type">int</span> e)</span> </span>&#123;<br>    Node *p = <span class="hljs-keyword">new</span> Node;<br>    <span class="hljs-keyword">if</span> (p==<span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Out of space&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    p-&gt;content = e;<br>    p-&gt;next = top;<br>    top = p;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack1::pop</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (top == <span class="hljs-literal">NULL</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Node *p = top;<br>    top = top-&gt;next;<br>    e = p-&gt;content;<br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!note]+<br>改变栈的数据表示对使用者没有任何影响</p></blockquote><h1>面向对象程序设计</h1><p><img src="2025031512.png" alt=""></p><h2 id="基本内容">基本内容</h2><p><img src="2025031520-1.png" alt=""><br><img src="2025031573.png" alt=""><br><img src="2025031519.png" alt=""></p><h2 id="好处">好处</h2><p>影响软件开发效率和软件质量的因素主要包括：</p><ul><li>抽象（控制复杂度）</li><li>封装（保护信息）</li><li>模块化（组织和管理大型程序）</li><li>软件复用（缩短开发周期）</li><li>可维护性（延长软件寿命）</li><li>软件模型的自然度（缩小解题空间与问题空间之间的语义间隙，实现从问题到解决方案的自然过渡</li></ul>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++高级程序设计-0-Introduction</title>
    <link href="/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-Introduction/"/>
    <url>/2025/03/15/C-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-Introduction/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!tip]+ 考核<br>作业 10% + 上机 25% + 项目 15% + 期末 50%</p></blockquote><h2 id="预备知识">预备知识</h2><p><strong>函数的副作用</strong><br>指在函数执行过程中，除了返回值之外，对外部状态或环境产生的影响。这些影响可能包括：</p><ul><li>修改全局变量：函数可能会改变全局作用域中的变量值。</li><li>修改参数：如果参数是可变对象（如列表或字典），函数可能会直接修改这些对象。</li><li>输入/输出操作：函数可能会进行文件读写、打印输出等操作。</li><li>抛出异常：函数可能会引发异常，影响程序的控制流。</li><li>网络请求：函数可能会进行网络请求，改变外部系统的状态。</li></ul><p>副作用的存在使得函数的行为不再是完全可预测的，因为相同的输入可能导致不同的输出，具体取决于函数执行时的外部状态。这与“纯函数”相对，后者在相同输入下总是返回相同的输出，并且不产生副作用。</p><p><strong>数据类型-联合</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-type">int</span> intValue;<br>    <span class="hljs-type">float</span> floatValue;<br>    <span class="hljs-type">char</span> charValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>特点</p><ul><li>内存节省：由于所有成员<strong>共享同一内存</strong>，联合的大小等于其最大成员的大小。</li><li>只能存储一个值：在任何时刻，联合只能存储一个成员的值，设置一个成员的值会覆盖其他成员的值。</li><li>类型安全：使用联合时，程序员需要小心，以确保在访问联合成员时，所访问的成员是最近设置的成员。</li></ul><p><strong>数据类型-枚举</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Day</span> &#123;</span><br>    Sunday,<br>    Monday,<br>    Tuesday,<br>    Wednesday,<br>    Thursday,<br>    Friday,<br>    Saturday<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>必须用指针的情况</strong>：</p><ul><li>提高参数传递效率（直接传递地址，不用形参）</li><li>访问动态变量</li></ul><p><strong>static 的使用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 局部使用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只初始化一次</span><br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Count: %d\n&quot;</span>, count);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    function(); <span class="hljs-comment">// 输出 Count: 1</span><br>    function(); <span class="hljs-comment">// 输出 Count: 2</span><br>    function(); <span class="hljs-comment">// 输出 Count: 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 全局使用</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalVar = <span class="hljs-number">0</span>; <span class="hljs-comment">// 仅在此文件可见</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>    globalVar++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    increment();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Global Variable: %d\n&quot;</span>, globalVar); <span class="hljs-comment">// 输出 Global Variable: 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-对-C-的扩充">C++对 C 的扩充</h2><h3 id="内联函数">内联函数</h3><p>宏定义的不足：</p><ul><li>需要加上很多括号</li><li>有时会出现重复计算</li><li>替换时不进行参数类型检查和转换<br>内联函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br></code></pre></td></tr></table></figure><p>建议编译程序把该函数的函数体展开到调用点，函数调用时直接执行函数体。<br>P.S 递归函数往往不能作为内联函数；内联函数名具有文件作用域</p><h3 id="名空间作用域">名空间作用域</h3><ul><li>把全局标识符定义在一个名空间中，其作用域为该名空间。</li><li>当在一个名空间外部需要使用该名空间中定义的全局标识符时，需要用该名空间的名字来修饰或受限。</li></ul><h3 id="动态变量">动态变量</h3><p><em>p1</em> = <strong>new</strong> int;</p><p><strong>delete</strong> <em>p1</em>;</p><p>对于普通的动态变量，C++与 C 的做法区别不大，但如果创建的是动态对象，则两者是有差别的：</p><ul><li>除了为对象分配空间外，new 还会去调用<strong>对象类的构造函数进行对象初始化</strong>， malloc（calloc）则否。</li><li>除了收回为对象分配的空间外，delete 还会去调用对象类的析构函数进行对象消亡后的清理，free 则否。</li></ul><p>C/C++动态变量的问题</p><ul><li>没有自动废区收集功能，动态变量需要程序<strong>显式用 free 或 delete 撤销</strong>，否则会出现内存泄漏问题！</li></ul><h3 id="引用类型">引用类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> &amp;y=x; <span class="hljs-comment">//y为引用类型的变量，它是x的别名</span><br>y = <span class="hljs-number">10</span>;  <span class="hljs-comment">//通过y访问x，效果上等价于：x = 10;</span><br></code></pre></td></tr></table></figure><h4 id="用处">用处</h4><p>提高函数参数传递效率</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(A &amp;x)</span></span>&#123;<span class="hljs-comment">// x使用实参的内存空间</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>保证形参访问的永远是实参数据<br>保证通过形参访问的永远是实参数据<br><img src="2025031547.png" alt=""></p><blockquote><p>[!note]<br>即通过引用类型不可以在函数体内指向其他位置，而普通指针可以（但可以通过 const 达到引用类型的效果</p></blockquote><h4 id="如何防止函数通过指针和引用类型的形参修改实参数据">如何防止函数通过指针和引用类型的形参修改实参数据</h4><p><strong>const</strong><br><img src="2025031553.png" alt=""></p><h4 id="函数返回值可以为引用类型">函数返回值可以为引用类型</h4><p><img src="2025031520.png" alt=""></p><blockquote><p>[!warning]+<br>不要把局部量的引用返回给调用者，因为函数返回后，局部量的内存空间已无效，后续操作中可能又分配给其它变量</p></blockquote><p><img src="2025031553-1.png" alt=""></p><h3 id="函数名重载">函数名重载</h3><blockquote><p>[!quote]+ 定义<br>在相同的作用域中，可以用同一个名字定义多个不同的函数，这时，要求定义的这些函数应具有不同的参数（参数个数或类型要有所不同）。</p></blockquote><h4 id="绑定">绑定</h4><p>定义：确定一个对重载函数的调用对应着哪一个重载函数定义的过程</p><h5 id="精确匹配">精确匹配</h5><p>实参与形参的类型完全相同，或者对实参进行“微小”的类型转换后与形参类型相同：</p><ul><li>数组变量名-&gt;数组第一个元素的内存地址</li><li>函数名-&gt;函数的内存首地址</li></ul><h5 id="提升匹配">提升匹配</h5><p>先对实参进行下面的类型提升，然后进行精确匹配：</p><ul><li>按整型提升规则提升实参类型</li><li>把 float 类型实参提升到 double</li><li>把 double 类型实参提升到 long double</li></ul><h5 id="标准转换匹配">标准转换匹配</h5><p>先进行下面的标准转换，然后进行精确匹配：</p><ul><li>任何算术类型可以互相转换</li><li>枚举类型可以转换成任何算术类型</li><li>零可以转换成任何算术类型或指针类型</li><li>任何类型的指针可以转换成 void *<blockquote><p>[!warning]+<br>每个标准转换都是平等的，不存在哪个优先：<br>如果存在多个标准转换后能精确匹配，则失败！ （具有歧义）</p></blockquote></li></ul><h5 id="绑定失败">绑定失败</h5><p>不存在匹配 or 存在多个匹配</p><p>解决办法是：</p><ul><li>对实参进行显式类型转换，如，<ul><li>print ((char) 1) 或 print ((double) 1)</li></ul></li><li>增加额外的重载，如，<ul><li>增加一个重载函数定义： void print (int);</li></ul></li></ul><h3 id="变量初始化">变量初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x&#123;<span class="hljs-number">5</span>&#125;; <span class="hljs-comment">// int x(5);</span><br><span class="hljs-type">int</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123; <span class="hljs-type">int</span> x; <span class="hljs-type">int</span> y;&#125; point&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;<br><span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br></code></pre></td></tr></table></figure><h3 id="基于范围的-for">基于范围的 for</h3><p>C++语言注重程序的效率，运行时刻不对数组元素下标越界进行检查，从而造成下面错误代码的执行不会报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>], sum;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">10</span>; i++) cin &gt;&gt; a[i]; sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">10</span>; i++) sum += a[i];<br></code></pre></td></tr></table></figure><p>为了方便、可靠地实现一些简单地对一维数组元素进行遍历的操作，在 C++新国际标准（C++11 以后）中提供了一种<strong>基于范围的 for</strong> 语句，它能自动遍历数组元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;n: a) cin &gt;&gt; n;<br></code></pre></td></tr></table></figure><h3 id="类型自动判断：auto">类型自动判断：auto</h3><p>定义一个变量时可以不指定它的类型，由编译器根据初始化的值自动确定它的类型。例如：</p><ul><li>auto x=1+2 * 3.4; //编译程序自动确定 x 的类型为 double</li></ul><p>P.S: 自动生存期的局部变量不能再显式地用 auto 来指出</p><h3 id="字符串常量与字符指针">字符串常量与字符指针</h3><ul><li>按 C 语言，可以；按 C++语言，不可以！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span> *p)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">char</span> x[])</span></span>&#123;...&#125;<br><br><span class="hljs-type">char</span> *p = <span class="hljs-string">&quot;abcd&quot;</span>; <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">f</span>(<span class="hljs-string">&quot;1234&quot;</span>); <span class="hljs-comment">// ERROR</span><br><span class="hljs-built_in">g</span>(<span class="hljs-string">&quot;1234&quot;</span>); <span class="hljs-comment">// ERROR</span><br></code></pre></td></tr></table></figure><blockquote><p>[!warning]+<br>C++需要指向常量的指针<br>即使用 const char *p = “abcd” 或者 f (const char *p) 是可以的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>2024秋-C++高级程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker容器配置</title>
    <link href="/2025/03/12/Docker%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/03/12/Docker%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="新建容器">新建容器</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-it</span> <span class="hljs-literal">--gpus</span> all <span class="hljs-literal">--name</span> my<span class="hljs-literal">-pytorch-env</span> <span class="hljs-literal">-v</span> ~/:/workspace ubuntu:<span class="hljs-number">22.04</span> /bin/bash<br></code></pre></td></tr></table></figure><ol><li><strong><code>docker run</code></strong><ul><li>此命令用于创建并启动一个新的容器实例。</li></ul></li><li><strong><code>-it</code></strong><ul><li>这是两个参数的组合：<ul><li><code>-i</code> (interactive): 让容器保持标准输入流 (stdin) 打开，允许你与容器进行交互。</li><li><code>-t</code> (tty): 分配一个伪终端，提供一个交互式命令行界面。</li></ul></li></ul></li><li><strong><code>--gpus all</code></strong><ul><li>此参数指定类似于  <code>nvidia-docker</code>  的配置，允许容器访问所有可用的 GPU。确保在宿主机上正确安装了 NVIDIA 驱动和 NVIDIA 容器工具包。</li></ul></li><li><strong><code>--name my-pytorch-env</code></strong><ul><li>为新创建的容器指定一个名称。在这种情况下，容器被命名为  <code>my-pytorch-env</code>。命名容器有助于后续管理，例如停止或删除容器时更容易引用。</li></ul></li><li><strong><code>-v ~/:/workspace</code></strong><ul><li>这是一个卷挂载选项，允许你将宿主机的目录挂载到容器内：<ul><li><code>~/:</code>  指宿主机的用户主目录，将整个主目录的内容挂载到容器内。</li><li><code>/workspace</code>  是容器内的目标路径，指这个挂载点。容器可以在这个路径下访问宿主机的文件。</li></ul></li></ul></li><li><strong><code>ubuntu:22.04</code></strong><ul><li>指定要使用的基础镜像，这里使用的是 Ubuntu 22.04 版本。Docker 会从本地或 Docker Hub 拉取此镜像（如果在本地不存在）。</li></ul></li><li><strong><code>/bin/bash</code></strong><ul><li>指定容器启动后执行的命令。在这种情况下，<code>/bin/bash</code>  启动了一个 Bash shell，让用户能在容器中执行交互式命令。</li></ul></li></ol><h2 id="vscode-连接容器-配置">vscode 连接容器&amp;配置</h2><p>启动容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker start <span class="hljs-keyword">my</span>-pytorch-env<br></code></pre></td></tr></table></figure><ol><li>点击 VSCode 左下角  <strong>&gt;&lt;</strong>  按钮</li><li>选择  <strong>Attach to Running Container</strong>，选择 my-pytorch-env 容器<br>必要扩展</li><li><strong>Python</strong>（Python 代码支持）</li><li><strong>Pylance</strong>（代码补全和类型检查）</li><li><strong>Jupyter</strong>（Jupyter Notebook 支持）</li><li><strong>Docker</strong>（Docker 支持）</li></ol><h2 id="配置-conda-pytorch">配置 conda &amp; pytorch</h2><h3 id="安装-miniconda">安装 miniconda</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim">apt <span class="hljs-keyword">update</span> &amp;&amp; apt install -<span class="hljs-keyword">y</span> wget<br># wget https://repo.anaconda.<span class="hljs-keyword">com</span>/miniconda/Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span><br>wget https://mirrors.tuna.tsinghua.edu.<span class="hljs-keyword">cn</span>/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span><br>bash Miniconda3-latest-Linux-x86_64.<span class="hljs-keyword">sh</span> -<span class="hljs-keyword">b</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;export PATH=&quot;/root/miniconda3/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-keyword">source</span> ~/.bashrc<br>conda init<br></code></pre></td></tr></table></figure><blockquote><p>[!warning]<br>conda init 后需要新建一个 bash 终端，否则 conda 环境不会生效。</p></blockquote><h3 id="创建-Pytorch-环境">创建 Pytorch 环境</h3><p>添加镜像源：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.ustc.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/main/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/free/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>pkgs<span class="hljs-regexp">/main/</span><br>conda config --add channels https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/anaconda/</span>cloud<span class="hljs-regexp">/pytorch/</span><br>conda config --set show_channel_urls yes<br></code></pre></td></tr></table></figure><p>创建并配置环境</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n pytorch python=<span class="hljs-number">3</span>.<span class="hljs-number">10</span> -y<br><span class="hljs-attribute">conda</span> activate pytorch<br></code></pre></td></tr></table></figure><p>安装 pytorch 及实验所需依赖</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> install ipykernel matplotlib numpy<br><span class="hljs-attribute">pip</span> install torch==<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> torchvision torchaudio -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple<br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">python -c &quot;import torch; <span class="hljs-built_in">print</span>(torch.__version__); <span class="hljs-built_in">print</span>(torch.cuda.is_available())&quot;<br></code></pre></td></tr></table></figure><h2 id="docker-导出-导入">docker 导出&amp;导入</h2><blockquote><p>[!tip] 为什么需要导出导入</p><ol><li><strong>环境共享</strong>：</li></ol><ul><li>可以将配置好的开发环境分享给团队其他成员</li><li>确保所有人使用完全相同的环境，避免&quot;在我这里能运行&quot;的问题</li></ul><ol start="2"><li><strong>环境备份</strong>：</li></ol><ul><li>保存已配置好的环境状态，防止意外损坏</li><li>在需要时可以快速恢复到之前的状态</li></ul><ol start="3"><li><strong>跨机器迁移</strong>：</li></ol><ul><li>方便在不同机器间转移开发环境</li><li>特别适用于没有稳定网络连接的情况，避免重新下载和配置</li></ul><ol start="4"><li><strong>版本控制</strong>：</li></ol><ul><li>可以保存不同阶段的环境快照</li><li>在需要时回滚到特定版本</li></ul></blockquote><blockquote><p>[!warning] 注意<br>以下命令需要在 Ubuntu 终端（terminal）中运行，而不是容器内部。</p></blockquote><h3 id="导出">导出</h3><p><strong>导出容器为镜像</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker commit <span class="hljs-keyword">my</span>-pytorch-env <span class="hljs-keyword">my</span>-pytorch-image:latest<br></code></pre></td></tr></table></figure><ul><li>将运行中容器的当前状态保存为新的镜像</li><li><code>my-pytorch-env</code>：容器名称</li><li><code>my-pytorch-image:latest</code>：新镜像名称和标签<br><strong>导出镜像为文件</strong></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">docker <span class="hljs-built_in">save</span> -o my-pytorch-<span class="hljs-built_in">image</span>.tar my-pytorch-<span class="hljs-built_in">image</span>:latest<br></code></pre></td></tr></table></figure><ul><li>将镜像保存为可传输的 tar 文件</li><li><code>-o</code>：指定输出文件</li><li>生成的 tar 文件可以在不同机器间传输</li></ul><h3 id="导入">导入</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> my-pytorch-<span class="hljs-selector-tag">image</span><span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装</title>
    <link href="/2025/03/12/Docker%E5%AE%89%E8%A3%85/"/>
    <url>/2025/03/12/Docker%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-安装-wsl2-Ubuntu20-04">Docker 安装 (wsl2-Ubuntu20.04)</h2><h3 id="安装-docker">安装 docker</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 更新软件包列表，确保我们获得可用的软件包的最新信息</span><br>sudo apt update<br><br><span class="hljs-comment"># 安装必要的软件包：ca-certificates（用于验证SSL证书），curl（用于下载文件），gnupg（用于加密和解密）</span><br>sudo apt install <span class="hljs-literal">-y</span> ca<span class="hljs-literal">-certificates</span> <span class="hljs-built_in">curl</span> gnupg<br><br><span class="hljs-comment"># 下载阿里云的GPG证书并将其添加到系统的密钥管理器中，以便后续验证软件包的来源</span><br><span class="hljs-built_in">curl</span> <span class="hljs-literal">-fsSL</span> https://mirrors.aliyun.com/docker<span class="hljs-literal">-ce</span>/linux/ubuntu/gpg | sudo apt<span class="hljs-literal">-key</span> add<br><br><span class="hljs-comment"># 进入指定目录，这里是用来存储APT源列表的目录</span><br><span class="hljs-built_in">cd</span> /etc/apt/sources.list.d<br><br><span class="hljs-comment"># 创建一个名为docker.list的文件，用于存放Docker的阿里云镜像源</span><br>sudo touch docker.list<br><br><span class="hljs-comment"># 修改docker.list文件的权限，使所有用户都可以读写</span><br>sudo chmod <span class="hljs-number">666</span> docker.list<br><br><span class="hljs-comment"># 将阿里云的Docker镜像源信息写入docker.list文件</span><br>sudo <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-variable">$</span>(lsb_release -cs) stable&quot;</span> &gt; docker.list<br><br><span class="hljs-comment"># 更新软件包列表以包含新添加的镜像源并升级已安装的软件包</span><br>sudo apt<span class="hljs-literal">-get</span> update &amp;&amp; sudo apt<span class="hljs-literal">-get</span> upgrade<br><br><span class="hljs-comment"># 安装Docker及其相关组件，包括Docker引擎、命令行工具、容器运行时、Docker构建插件和Docker Compose插件</span><br>sudo apt install <span class="hljs-literal">-y</span> docker<span class="hljs-literal">-ce</span> docker<span class="hljs-literal">-ce-cli</span> containerd.io docker<span class="hljs-literal">-buildx-plugin</span> docker<span class="hljs-literal">-compose-plugin</span><br></code></pre></td></tr></table></figure><h3 id="配置镜像源-NVIDIA-容器包工具">配置镜像源 NVIDIA 容器包工具</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 将当前用户添加到docker组，以便可以在不使用sudo的情况下运行docker命令</span><br>sudo usermod <span class="hljs-literal">-aG</span> docker <span class="hljs-variable">$USER</span><br><br><span class="hljs-comment"># 立即更新当前shell的组信息，或者可以注销后重新登录</span><br>newgrp docker<br><br><span class="hljs-comment"># 安装NVIDIA容器工具包的步骤</span><br><span class="hljs-comment"># 添加NVIDIA Docker的GPG密钥</span><br><span class="hljs-built_in">curl</span> <span class="hljs-literal">-s</span> <span class="hljs-literal">-L</span> https://nvidia.github.io/nvidia<span class="hljs-literal">-docker</span>/gpgkey | sudo apt<span class="hljs-literal">-key</span> add -<br><br><span class="hljs-comment"># 获取当前操作系统的ID和版本信息</span><br>distribution=<span class="hljs-variable">$</span>(. /etc/os<span class="hljs-literal">-release</span>;<span class="hljs-built_in">echo</span> <span class="hljs-variable">$ID</span><span class="hljs-variable">$VERSION_ID</span>)<br><br><span class="hljs-comment"># 添加NVIDIA Docker的APT源</span><br><span class="hljs-built_in">curl</span> <span class="hljs-literal">-s</span> <span class="hljs-literal">-L</span> https://nvidia.github.io/nvidia<span class="hljs-literal">-docker</span>/<span class="hljs-variable">$distribution</span>/nvidia<span class="hljs-literal">-docker</span>.list | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/nvidia<span class="hljs-literal">-docker</span>.list<br><br><span class="hljs-comment"># 添加CUDA的GPG公钥</span><br><span class="hljs-comment"># ！此处将com改为cn，2204改为2004</span><br>sudo apt<span class="hljs-literal">-key</span> adv <span class="hljs-literal">--fetch-keys</span> https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64/<span class="hljs-number">7</span>fa2af80.pub<br><br><span class="hljs-comment"># ！显示缺少某个公钥 单独获取</span><br>sudo apt<span class="hljs-literal">-key</span> adv <span class="hljs-literal">--keyserver</span> keyserver.ubuntu.com <span class="hljs-literal">--recv-keys</span> A4B469963BF863CC<br><br><span class="hljs-comment"># 添加CUDA的APT源</span><br>sudo <span class="hljs-built_in">add-apt</span><span class="hljs-literal">-repository</span> <span class="hljs-string">&quot;deb https://developer.download.nvidia.cn/compute/cuda/repos/ubuntu2004/x86_64/ /&quot;</span><br><br><span class="hljs-comment"># 更新APT包索引</span><br>sudo apt update<br><br><span class="hljs-comment"># 安装NVIDIA容器工具包</span><br>sudo apt install <span class="hljs-literal">-y</span> nvidia<span class="hljs-literal">-container-toolkit</span><br><br><span class="hljs-comment"># 重启Docker服务，以使NVIDIA容器工具包生效</span><br>sudo systemctl restart docker<br><br><span class="hljs-comment"># 配置Docker镜像源</span><br><span class="hljs-comment"># 创建Docker的配置目录（如果不存在）</span><br>sudo mkdir <span class="hljs-literal">-p</span> /etc/docker<br><br><span class="hljs-comment"># 创建或覆盖daemon.json文件，配置Docker的镜像源和默认运行时</span><br>sudo <span class="hljs-built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>        <span class="hljs-string">&quot;https://docker.1ms.run&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.xuanyuan.me&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.nju.edu.cn&quot;</span>,<br>        <span class="hljs-string">&quot;https://do.nark.eu.org&quot;</span>,<br>        <span class="hljs-string">&quot;https://dc.j8.work&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>,<br>        <span class="hljs-string">&quot;https://dockerproxy.com&quot;</span>,<br>        <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;default-runtime&quot;</span>: <span class="hljs-string">&quot;nvidia&quot;</span>,<br>    <span class="hljs-string">&quot;runtimes&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;nvidia&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;nvidia-container-runtime&quot;</span>,<br>        <span class="hljs-string">&quot;runtimeArgs&quot;</span>: []<br>        &#125;<br>    &#125;<br>&#125;<br>EOF<br><br><span class="hljs-comment"># 重新加载systemd管理的配置</span><br>sudo systemctl daemon<span class="hljs-literal">-reload</span><br><br><span class="hljs-comment"># 再次重启Docker服务，以应用新的配置</span><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h3 id="验证安装">验证安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run hello<span class="hljs-literal">-world</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-2.2关系代数基本运算</title>
    <link href="/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-2%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/"/>
    <url>/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-2%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="关系代数概述">关系代数概述</h2><p><strong>关系代数</strong>：一种抽象的查询语言，用关系运算来表达对关系的操作</p><ul><li>集合运算符：传统的集合运算从关系的“水平”方向，即行的角度进行</li><li>专门的关系运算符</li></ul><p>常用关系操作：</p><ul><li>集合操作：并、交、差、笛卡尔积</li><li>专门的关系操作：<ul><li>选择、投影</li><li>连接（包括 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> -连接，自然连接，外连接等）</li><li>除</li></ul></li></ul><p><strong>5 种基本操作</strong>：选择、投影、并、差、笛卡尔积<br><img src="2025030636.png" alt=""><br>记号表示：</p><ul><li>关系设为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">t \in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> 表示 t 是 R 中的一个元组</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo stretchy="false">[</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">t[A_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span> 表示元组 t 相应于属性 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">A_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的一个分量</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_r,t_s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示元组的连接</li><li>象集 images set:<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mi>x</mi></msub><mo>=</mo><mrow><mi>t</mi><mo stretchy="false">[</mo><mi>Z</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mtext>且</mtext><mi>t</mi><mo stretchy="false">[</mo><mi>X</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi></mrow></mrow><annotation encoding="application/x-tex">Z_x = {t[Z]|t\in R且t[X]=x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">]</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord cjk_fallback">且</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">x</span></span></span></span></span> : 表示 R 中属性组 X 上值为 x 的诸元组在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> 上分量的集合</li></ul></li></ul><h2 id="关系代数的基本运算">关系代数的基本运算</h2><ul><li>一般通过属性名来确定一个属性的语义，采用“同名同义、异名异义”</li></ul><p><img src="2025030664.png" alt=""></p><p><strong>并</strong> Union:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∪</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∨</mo><mi>t</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R\cup S=\{t|t\in R \vee t\in S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6542em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li><li>满足交换律和结合律</li></ul><p><strong>差</strong> Difference</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>−</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>t</mi><mo mathvariant="normal">∉</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R-S=\{t|t\in R \wedge t\notin S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.0556em;"></span></span></span><span class="fix"></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li><li>不满足交换律和结合律</li></ul><p><strong>笛卡尔积</strong></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>r</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msub><mi>t</mi><mi>r</mi></msub><mo>∈</mo><mi>R</mi><mo>∧</mo><msub><mi>t</mi><mi>s</mi></msub><mo>∈</mo><mi>S</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">R \times S =\{(t_r,t_s)|t_r\in R \land t_s\in S\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">}</span></span></span></span></li></ul><p><strong>选择</strong> Selection 又称为限制 Restriction</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo>∧</mo><mi>F</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\sigma_F(R)=\{t|t\in R\land F(t)=true\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mclose">}</span></span></span></span></li></ul><p><strong>投影</strong>：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_A(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">R[A]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">[</span><span class="mord mathnormal">A</span><span class="mclose">]</span></span></span></span></li><li>略去关系 𝐀 中的某些列，并重新安排结果关系中列的排列次序的运算</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><msub><mi>A</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mi>m</mi></msub></msub></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>t</mi><mo stretchy="false">[</mo><msub><mi>A</mi><msub><mi>i</mi><mn>1</mn></msub></msub><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mn>2</mn></msub></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>A</mi><msub><mi>i</mi><mi>m</mi></msub></msub><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>t</mi><mo>∈</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\pi_{A_{i_1},A_{i_2},...,A_{i_m}}(R)=\{t[A_{i_1},A_{i_2},...,A_{i_m}]|t\in R\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1499em;vertical-align:-0.3999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2996em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.357em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3448em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.6444em;"></span><span class="mord mtight">2</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2996em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.357em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight">...</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2306em;"><span style="top:-2.3em;margin-left:0em;margin-right:0.1em;"><span class="pstrut" style="height:2.5em;"></span><span class="mord mathnormal mtight">m</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2859em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0001em;vertical-align:-0.2501em;"></span><span class="mopen">{</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3173em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord">∣</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">}</span></span></span></span></li></ul><h2 id="关系代数基本运算的应用">关系代数基本运算的应用</h2><p>例</p><p><img src="2025030630.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-数据管理基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据管理基础-2.1关系数据模型</title>
    <link href="/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/12/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-2-1%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="关系数据结构及形式化定义">关系数据结构及形式化定义</h2><h3 id="关系">关系</h3><h4 id="前置概念">前置概念</h4><p><strong>域 Domain</strong>: 一组具有相同数据类型的值的集合。</p><ul><li>例：整数、实数、枚举数据类型（{‘男’，‘女’}）</li><li>每一个域有一个‘域名’，用来区分不同的域。</li><li>同一个域中的元素互不相同。</li></ul><p><strong>笛卡尔积</strong> Cartesian Product:</p><ul><li>给定一组域 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，允许其中某些域是相同的。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的笛卡尔积可表示为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>×</mo><msub><mi>D</mi><mn>2</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1}\times D_2 \times...\times D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>运算结果也是一个集合，其中的每个元素都是一个具有如下形式的 n 元组：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,...,d_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>∈</mo><msub><mi>D</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_i \in D_i(i=1,2,...,n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li></ul><p><strong>元组 Tuple:</strong></p><ul><li>笛卡尔积中每一个元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,...,d_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 叫作一个 ‘n 元组’ (n-tuple) 或 ‘n 元有序组’ ，简称 ‘元组’</li></ul><p><strong>分量 Component:</strong></p><ul><li>笛卡尔积元素 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(d_1,d_2,...,d_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 中的每一个值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 叫作一个 ‘分量’</li></ul><p><strong>基数</strong>：</p><ul><li>一个域允许的不同取值个数称为这个域的‘基数’</li></ul><p>笛卡尔积的结果表示方法：</p><ul><li>集合表示：列举出结果集中的所有元组</li><li>二维表表示：表中每一行对应一个元组，每一列对应一个域。<ul><li>为了区分每一列所对应的域，需要在二维表中添加一个 ‘表头’ (table heading – 二维表第一行)，用于显示每一列对应域的域名</li></ul></li></ul><h4 id="关系的定义">关系的定义</h4><p><strong>关系 Relation</strong>: 给定一个域的序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（其中可能存在相同的域），笛卡尔积 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo>×</mo><msub><mi>D</mi><mn>2</mn></msub><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1}\times D_2 \times...\times D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的子集叫做在域 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">D_{1},D_2,...,D_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 上的关系，表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>D</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(D_{1},D_2,...,D_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, 或简写为关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>。</p><ul><li>n 是关系的 ‘目’ 或 ‘度’（Degree）</li></ul><p><strong>属性 Attribute</strong>:</p><ul><li>在一个关系中，不同列可以对应相同的域。为了加以区分，关系所对应的二维表中的每一列，被称为是该关系中的一个‘属性’。</li><li>关系中的每一个属性都有一个名字，称为‘属性名’。在同一个关系中，属性名互不相同。</li></ul><p><strong>码 (Key)、候选码 (Candidate key)</strong>: 若关系中的某一属性组的值能唯一地标识一个元组，而其所有的真子集都不能，则称该属性组为关系的 ‘候选码’，简称 ‘码’。</p><ul><li>简单的情况：一个候选码只包含一个属性；</li><li>最极端的情况：由关系中的所有属性构成的属性组是这个关系的候选码，称为 ‘全码’（All-key）</li></ul><p><strong>主码（Primary key）</strong>：</p><ul><li>在一个关系中，可以选择一个候选码作为该关系的 ‘主码’。</li><li>‘主码’ 是关系数据库管理系统（SQL）中才有的概念。当我们在创建关系对应的 ‘基表’ 时，可以为基表定义‘主码’也可以不定义‘主码’。在一张基表中，最多只能定义一个主码。</li><li>在关系模型理论中，只有 ‘候选码’，不需要为关系定义 ‘主码’。</li></ul><p><strong>主属性</strong> 与 非主属性/非码属性</p><ul><li>候选码中的诸属性称为该关系的 ‘主属性’（Prime attribute）</li><li>不包含在任何侯选码中的属性称为该关系的 ‘非主属性’（NonPrime attribute）或 ‘非码属性’（Non-key attribute）</li></ul><h4 id="关系的类别-性质">关系的类别/性质</h4><p>类型：</p><ul><li><strong>基本关系</strong>（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示。</li><li><strong>查询表</strong>：查询结果对应的表，结果数据不需要持久存储。</li><li><strong>视图表</strong>：由基本表或其他视图表导出的表, 是虚表, 结果数据也不需要持久存储。</li></ul><p>当使用‘关系’来作为<em>关系数据模型的数据结构</em>时，需要添加以下的约束：</p><ul><li>必须是一个有限子集</li><li>笛卡尔积满足交换律（或者说：关系中的列/属性满足‘无序性’）</li></ul><p>关系的性质：</p><ul><li>列是同质的：每一列中的分量是同一类型的数据，来自同一个域</li><li>不同的列可出自同一个域：其中的每一列称为一个属性；</li><li>列的无序性（属性的无序性）</li><li>行的唯一性（元组的唯一性）</li><li>行的无序性（元组的无序性）</li><li>分量必须取原子值：每一个分量都必须是不可分的数据项</li></ul><h3 id="关系模型">关系模型</h3><p>关系的型与值</p><ul><li>关系是元组的集合</li><li>关系模式是关系的 ‘型’，元组集合是关系的 ‘值’</li></ul><p><strong>关系模式</strong>（Relation Schema）：</p><ul><li>关系模式是对关系的描述</li><li>元组集合的结构<ul><li><em>属性构成</em>（关系模式的核心）</li><li>属性来自的域</li><li>属性与域之间的映象关系</li></ul></li><li>完整性约束条件：关系中的元组分量和元组需要满足的约束条件</li></ul><p><strong>形式化表示</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>U</mi><mo separator="true">,</mo><mi>D</mi><mo separator="true">,</mo><mi>D</mi><mi>O</mi><mi>M</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R(U,D,DOM,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal" style="margin-right:0.10903em;">OM</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span></p><ul><li>R ：关系名</li><li>U ：组成该关系的属性名集合</li><li>D ： U 中属性所来自的域</li><li>DOM ：属性向域的映象集合（描述各个属性对应的域）</li><li>F ：属性间数据的依赖关系的集合（关系上的完整性约束条件）</li></ul><p>关系模式通常可以简记为 R (U) 或 R (A1，A2，…，An)</p><h3 id="关系数据库">关系数据库</h3><p>——在一个给定的应用领域中，所有关系的集合构成一个关系数据库<br>关系数据库的型与值</p><ul><li>关系数据库的型<ul><li>关系数据库模式，是对关系数据库的描述</li><li>包括所有关系的关系模式，以及所有其他数据库对象的定义信息</li></ul></li><li>关系数据库的值<ul><li>关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><h2 id="关系操作">关系操作</h2><p><img src="2025022878.png" alt=""></p><h2 id="关系完整性">关系完整性</h2><p>三类完整性约束：</p><ul><li>实体完整性</li><li>参照完整性<ul><li>实体完整性和参照完整性是关系模型<em>必须满足</em>的完整性约束条件， 被称作是<strong>关系的两个不变性</strong>，由关系系统自动支持。</li></ul></li><li>用户定义的完整性<ul><li>是特定应用领域需要遵循的约束条件，体现了具体领域中的语义约束。</li></ul></li></ul><h3 id="实体完整性">实体完整性</h3><p>—— 指关系中元组（二维表中的行）的唯一性。</p><p>在关系数据库管理系统中，<em>实体完整性规则</em>是指：若属性 A 是基本关系（基表）的主码中的属性，则属性 A 不能去‘空值’（null）</p><ul><li>如果没有为基表定义主码，那么就允许在基表中出现重复的行（元组），这样的基表就不满足实体完整性约束。</li><li>如果为基表定义主码，DBMS 将自动保证“主码中的所有属性都不能取空值”以及“主码值的唯一性”</li></ul><h3 id="参照完整性">参照完整性</h3><p>关系间的引用：例——实体之间的引用</p><p><img src="2025030610.png" alt=""></p><p><strong>参照完整性规则</strong>：若属性（或属性组）F 是基本关系 R 的外码，它与基本关系 S 的主码 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">K_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 相对应（基本关系 R 和 S 不一定是不同的关系），则对于 R 中的每个元组在 F 上的值必须为：</p><ul><li>或者取空值（F 的每个属性值均为空值）</li><li>或者等于 S 中某个元组的主码值<br><img src="2025030686.png" alt=""></li></ul><h3 id="用户定义的完整性">用户定义的完整性</h3><p>——针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义</p><p>要求</p><p>例：课程（课程号 课程名 学分）</p><ul><li>课程号属性值的<em>唯一性约束</em></li><li>非主属性课程名的<em>非空约束</em></li><li>学分的<em>取值范围约束</em></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-数据管理基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-03运输层</title>
    <link href="/2025/03/12/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2025/03/12/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="运输层基础">运输层基础</h2><h3 id="网络传输服务">网络传输服务</h3><ul><li>在不同主机上运行的应用程序进程之间提供逻辑通信</li></ul><p>运输层协议在<strong>端系统</strong>（主机）中实现</p><ul><li>发送端：将应用程序消息分成段，传递到网络层</li><li>接收端：将片段重新组装成消息，传递给应用层</li></ul><p>为什么需要运输层：</p><ul><li>IP 数据包被寻址到主机，但端到端通信是在主机上的应用程序进程之间进行的<ul><li>需要一种方法来决定哪些数据包去往哪些应用程序（多路复用/多路分解）</li></ul></li><li>IP 提供了一种弱服务模型（尽力而为）<ul><li>数据包可能被损坏、延迟、丢弃、重新排序、复制</li><li>没有关于发送多少流量和何时发送的指导</li></ul></li></ul><h3 id="运输层的作用">运输层的作用</h3><ul><li>进程之间的通信</li><li>为应用层提供通用的端到端服务[可选]</li><li>TCP 和 UDP 是常见的传输协议</li><li>UDP 是一种极简的传输协议</li><li>TCP 提供了一种可靠、有序的字节流抽象<ul><li>有拥塞控制，但没有性能保证（延迟、b/w 等）</li></ul></li></ul><h3 id="应用与套接字">应用与套接字</h3><p><strong>Socket</strong>：应用程序进程的软件抽象，用于与（操作系统中的传输层）交换网络消息</p><p>运输层寻址：&lt;HostIP, Port&gt;, called a socket</p><p>两种套接字类型：</p><ul><li>UDP socket: SOCK_DGRAM</li><li>TCP socker: SOCK_STREAM</li></ul><p><strong>端口</strong> Port：有助于区分应用程序的 16 位数字</p><ul><li>数据包在传输头中携带 src/dst 端口号</li></ul><p>操作系统存储套接字和端口之间的映射：</p><ul><li>对于 UDP ports (SOCK_DGRAM)<ul><li>OS stores (local port, local IP address)&lt;–&gt; socket</li></ul></li><li>对于 TCP ports (SOCK_STREAM)<ul><li>OS stores (local port, local IP, remote port, remote IP) &lt;–&gt; socket</li></ul></li></ul><h3 id="多路复用与多路分解">多路复用与多路分解</h3><p>多路复用 Multiplexing Mux: 在源主机上收集和组合来自不同应用程序的数据块，并将其传递到网络层</p><p>多路分解 Demultiplexing Demux: 从多路复用的流中向相应的套接字传递正确的数据<br><img src="2025030442.png" alt=""></p><p><strong>多路分解的工作原理</strong>：<br><img src="2025030422.png" alt=""></p><p>在主机上的每个套接字能够分配一个端口号，当报文段到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。然后报文段中的数据通过套接字进入其所连接的进程。</p><h4 id="无连接的多路分解">无连接的多路分解</h4><p>一个 UDP 套接字由一个二元组全面标识，该二元组包含一个目的 IP 地址和一个目的端口号。因此，如果两个 UDP 报文段有不同的源 IP 地址和/或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到<strong>相同的目的进程</strong>。</p><h4 id="面向连接的多路分解">面向连接的多路分解</h4><p>当一个 TCP 报文段到达主机时，所有 4 个字段（源 IP 地址、源端口、目的 IP 地址、目的端口）被用来将报文段定向（分解）到相应的套接字。</p><h2 id="可靠数据传输设计">可靠数据传输设计</h2><p><strong>数据包损坏</strong>：<br>如何从错误中恢复：</p><ul><li>确认（ACK）：接收方明确地告诉发送方 pkt 接收到 OK</li><li>否定确认（NAK）：接收方明确地“告知”发送方 pkt 有错误</li><li>发送方在收到 NAK 后重新发送 pkt</li></ul><p>What if the ACK/NACK is corrupted?</p><ul><li>Data and ACK packets carry sequence numbers 数据和 ACK 数据包携带序列号</li></ul><p><strong>数据包丢失</strong>：</p><p><em>定时器</em>驱动的丢失检测：在发送数据包时设置定时器；超时时重新传输</p><ul><li>定时器驱动的重传可能会导致<em>重复</em></li></ul><p><img src="2025030450.png" alt=""><br>解决方案的组成：</p><ul><li>Checksums: to detect bit errors</li><li>Timers: to detect loss</li><li>Acknowledgement: positive or negative</li><li>Sequence numbers: to deal with duplicates</li></ul><h2 id="可靠数据传输协议设计">可靠数据传输协议设计</h2><p><strong>Stop and Wait</strong><br><img src="2025030453.png" alt=""></p><p>效率很低，网络协议限制了物理资源的使用</p><p><strong>Pipelined protocols</strong> 流水线</p><p>发送方允许多个“正在进行中”但尚未确认的 pkt</p><ul><li>必须增加序列号的范围</li><li>在发送方和/或接收方进行缓冲</li></ul><p><strong>三个设计决策</strong></p><p>发送方可以发送哪些数据包？</p><ul><li>滑动窗口</li></ul><p>接收方如何接收数据包？</p><ul><li>累积</li><li>选择性</li></ul><p>发送方重新发送哪些数据包？</p><ul><li>Go-Back N (GBN)</li><li>Selective Repeat (SR)</li></ul><h3 id="滑动窗口-Sliding-window">滑动窗口 Sliding window</h3><p>窗口=相邻序列号集</p><ul><li>集合的大小是窗口大小；假设窗口大小为 n</li></ul><p>基本思想：一次最多发送 n 个数据包</p><ul><li>发送方可以在其窗口中发送数据包</li><li>接收方可以在其窗口中接收数据包</li><li>可接受的数据包窗口在成功接收/确认时“滑动”</li><li>窗口包含可能仍在传输中的所有数据包</li></ul>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-02应用层</title>
    <link href="/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-02%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-02%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="网络应用原理">网络应用原理</h2><h3 id="网络应用体系结构">网络应用体系结构</h3><h4 id="客户-服务器体系结构-CS-client-server-achitecture">客户-服务器体系结构 CS client-server achitecture</h4><ul><li>有一个总是打开的主机，称为服务器，它服务于来自许多其它称为客户的主机的请求。</li><li>客户相互不直接通信</li><li>具有固定的、周知的地址，称为 <strong>IP 地址</strong>；客户总是能够通过向该服务器的 IP 地址发送分组来与其联系。</li><li>例：Web/FTP/Telnet/电子邮件</li></ul><h4 id="P2P-体系结构-P2P-architecture">P2P 体系结构 P2P architecture</h4><ul><li>对位于数据中心的专用服务器有最小的（或者没有）依赖。</li><li>应用程序在间断连接的主机对之间直接通信，这些主机称为对等方。</li><li>例：文件共享应用 BitTorrent</li><li><strong>自扩展性</strong> self-scalability：尽管每个对等方都由于请求文件产生工作负载，但每个对等方通过向其它对等方文件也为系统增加服务能力。</li><li>成本效率：不需要庞大的服务器基础设施和服务带宽</li></ul><p>例：及时通讯</p><ul><li>CS: User registers its IP address with central server when it comes online</li><li>P2P: User contacts central server to find IP address of parties</li></ul><h3 id="进程通信">进程通信</h3><p><strong>进程：</strong> 进行通信的实际上是进程 process 而不是程序，一个进程可以被认为是运行在端系统中的一个程序。</p><ul><li>当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。</li><li>在两个不同端系统上的进程，通过跨越计算机网络交换报文 message 而相互通信</li></ul><p><strong>套接字 socket：</strong> 进程通过一个称为套接字的软件结构向网络发送报文和从网络接收报文。由于套接字也是建立网络应用程序的可编程接口，也被称为应用编程接口 Application Programming Interface API</p><h2 id="应用层协议">应用层协议</h2><h3 id="Web-和-HTTP">Web 和 HTTP</h3><h4 id="HTTP-概述">HTTP 概述</h4><p><strong>HTTP</strong> (HyperText Transfer Protocol 超文本传输协议)：Web 的应用层协议，是 Web 的核心。<br>URL 格式：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">&lt;protocol&gt;<span class="hljs-symbol">://&lt;host&gt;</span><span class="hljs-symbol">:&lt;port&gt;/&lt;path&gt;<span class="hljs-string">?q</span>uery_string</span><br></code></pre></td></tr></table></figure><ul><li>protocol: method for transmission or interpretation of the object</li><li>host: DNS name or IP address of the host where object resides</li><li>path: pathname of the file that contains the object</li><li>query_string: name/value pairs sent to app on the server</li></ul><p>HTTP 连接过程 —— 三次握手：</p><ul><li>客户向服务器发送一个小 TCP 报文段</li><li>服务器用一个小 TCP 报文段做出确认和响应</li><li>客户向服务器返回确认</li></ul><h4 id="cookie">cookie</h4><p><strong>cookie:</strong> HTTP 服务器是无状态的，而 cookie 允许站点对用户进行跟踪<br>4 个组件：</p><ul><li>在 HTTP 响应报文中的一个 cookie 首部行</li><li>在 HTTP 请求报文中的一个 cookie 首部行</li><li>在用户端系统中保留的一个 cookie 文件，并由用户的浏览器进行管理</li><li>位于 Web 站点的一个后端数据库</li></ul><h4 id="持续-非持续连接">持续/非持续连接</h4><p><strong>RTT:</strong> 往返时间 Round-Trip Time 指一个短分组从客户到服务器然后再返回客户所花费的时间。包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延</p><p><em>非持续连接</em>：</p><ul><li>必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配 TCP 的缓冲区和保持 TCP 变量，给服务器带来严重负担。</li><li>每一个对象经受两倍 RTT 的交付时延，即一个 RTT 用于创建 TCP，另一个 RTT 用于请求和接收一个对象。</li></ul><p><em>持续连接</em>：服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。</p><h4 id="Web-缓存">Web 缓存</h4><p>Web 缓存器 - 代理服务器 proxy server：能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。</p><p><strong>条件 GET</strong> conditional GET</p><p>条件 GET 请求报文：HTTP 请求报文使用 GET 方法，并且请求报文中包含一个&quot;If-modified-since: &quot;首部行</p><h3 id="SMTP">SMTP</h3><p>用于从发送方的邮件服务器发送报文到接收方的邮件服务器<br>传送方式：</p><ol><li>客户 SMTP（运行在发送邮件服务器主机上）在 25 号端口建立一个到服务器 SMTP（运行在接收邮件服务器主机上）的 TCP 连接。</li><li>如果服务器没有开机，客户会在稍后继续尝试连接。一旦连接建立，服务器和客户执行某些应用层的握手。</li><li>在 SMTP 握手的阶段，SMTP 客户只是发送方的邮件地址（产生报文的人）和接收方的邮件地址。一旦该 SMTP 客户和服务器彼此介绍后，客户发送该报文。</li><li>SMTP 能依赖 TCP 提供可靠数据传输无差错地将邮件投递到接收服务器。该客户如果有另外的报文要发送到该服务器，就在该相同的 TCP 连接上重复这种处理；否则它指示 TCP 关闭连接。</li></ol><h3 id="DNS-Domain-Name-Service">DNS Domain Name Service</h3><h4 id="基本概念">基本概念</h4><p>识别主机的两种方式:</p><ul><li>主机名</li><li>IP 地址</li></ul><p>——主机名到 IP 地址转换的目录服务：DNS 的主要任务</p><p>DNS：</p><ul><li>一个由分层的 DNS 服务器实现的分布式数据库</li><li>一个使得主机能够查询分布式数据库的应用层协议</li></ul><p>目标：</p><ul><li>独特性：没有命名冲突</li><li>可扩展性 Many names and frequent updates (secondary)</li><li>分布式、自主管理<ul><li>Ability to update my own (machine’s) names</li><li>Don’t have to track everybody’s updates</li></ul></li><li>Highly available</li><li>Lookups are fast</li><li>Perfect consistency is a non-goal</li></ul><p>How?</p><ul><li>Partition the namespace</li><li>Distribute administration of each partition 分配每个分区的管理<ul><li>Autonomy to update my own (machine’s) names</li><li>Don’t have to track everybody’s updates</li></ul></li><li>Distribute name resolution for each partition 为每个分区分配名称解析</li></ul><h4 id="层次结构">层次结构</h4><p>核心思想：层次结构 <strong>Hierarchy</strong><br>Three intertwined hierarchies</p><ul><li>Hierarchical namespace</li><li>Hierarchical administered</li><li>(Distributed) hierarchy of servers</li></ul><p><img src="2025022587.png" alt=""><br><img src="2025022532.png" alt=""></p><p>DNS 服务器的层次结构：</p><ul><li>根服务器：13 root name “serves” worldwide，还有超多 1000 台的副本。根服务器提供 TLD 服务器的 IP 地址</li><li>顶级域 (TLD Top-Level Domain) DNS 服务器：对每个顶级域和所有国家的顶级域都有 TLD 服务器。TLD 服务器提供权威 DNS 服务器的 IP 地址。</li><li>权威服务器：在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。一个组织的权威 DNS 服务器收藏了这些 DNS 记录。</li></ul><p>例：使用户的主机能够将一个 HTTP 请求报文发送到 Web 服务器，该用户主机需获得对应的 IP 地址：</p><ol><li>同一台用户主机上运行着 DNS 应用的客户端</li><li>浏览器从上述 URL 中抽取出主机名 <a href="http://www.someschool.edu">www.someschool.edu</a> ，并将主机名传给 DNS 应用的客户端。</li><li>DNS 客户向 DNS 服务器发送一个包含主机名的请求。</li><li>DNS 客户最终会收到一份回答报文，其中含有对应于该主机名的 IP 地址。</li><li>一旦浏览器接收到来自 DNS 的该 IP 地址，它就向位于该 IP 地址 80 端口的</li></ol><p>HTTP 服务器进程发起一个 TCP 连接。</p><p><strong>本地 DNS 服务器</strong>：每个 ISP 都有一台本地 DNS 服务器，当主机与某个 ISP 连接时，该 ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址。</p><p><img src="2025030419.png" alt=""></p><p><strong>递归查询</strong> recursive query：从请求主机到本地 DNS 服务器的查询。其余的查询都是迭代的。</p><h4 id="DNS-缓存">DNS 缓存</h4><ul><li>为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量</li><li>原理：在一个请求链中，当某 DNS 服务器接收一个 DNS 回答时（例如，包含某主机名到 IP 地址的映射），它就能将映射缓存在本地存储器中。</li></ul><h4 id="DNS-记录">DNS 记录</h4><p><img src="2025030432.png" alt=""></p><h3 id="FTP-File-Transfer-Protocol">FTP File Transfer Protocol</h3><ul><li>在运输层使用 TCP</li><li>一般端口号为 21/20</li><li>在本地和主机之间传输文件。采用 CS 模型。</li><li>采用异构的操作系统和文件系统</li></ul><p>控制连接：让客户和服务器可以建立连接（比如身份认证）</p><p>数据连接：单独创建一个连接，进行数据的传输。</p><h3 id="CDNs-Content-Distribution-Networks">CDNs Content Distribution Networks</h3><p>挑战：</p><ul><li>实时从单个源服务器流式传输大文件（如视频）</li><li>保护源服务器免受 DDOS 攻击<br>解决方法：</li><li>在互联网上的数百台服务器上复制内容</li><li>CDN 分发节点协调内容分发</li><li>将内容放在用户附近</li></ul><h4 id="内容复制">内容复制</h4><ul><li>内容提供商（源服务器）是 CDN 客户</li><li>CDN 在 CDN 服务器中复制客户的内容</li><li>当提供商更新内容时，CDN 会更新其服务器</li><li>使用权威 DNS 服务器重定向请求</li></ul><h4 id="CDN-操作">CDN 操作</h4><p><img src="2025030477.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网计算-01计算机网络和因特网</title>
    <link href="/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-01%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/"/>
    <url>/2025/02/25/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-01%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念和问题">基本概念和问题</h2><h3 id="因特网的概念">因特网的概念</h3><h4 id="具体构成">具体构成</h4><ul><li>主机 host / 端系统 end system</li><li>通信链路 communication link<ul><li>链路的传输速率 transmission rate 以比特/秒 bit/s bps 度量</li><li>当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包就是分组 packet。</li></ul></li><li>分组交换机 packet switch<ul><li>路由器 router 用于网络核心</li><li>链路层交换机 link-layer switch 用于接入网</li></ul></li></ul><p><strong>TCP/IP</strong>：端系统、分组交换机和其它因特网部件都要运行多个协议 protocol，这些协议控制因特网中信息的接收和发送。TCP (Transmission Control Protocol 传输控制协议) 和 IP (Internet Protocol 网际协议) 是因特网中最为重要的两个协议，因特网的主要协议统称为 TCP/IP。</p><h4 id="协议-Protocol">协议 Protocol</h4><p><strong>定义：</strong> 在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送/接收或其它事件所采取的操作。</p><h3 id="网络边缘-Network-Edge">网络边缘 Network Edge</h3><p>端系统——也称为主机 host</p><ul><li>客户 client</li><li>服务器 server</li></ul><h4 id="接入网-Access-Networks">接入网 Access Networks</h4><p>——将端系统物理连接到其边缘路由器 edge router 的网络。是端系统到任何其它远程端系统的路径上的第一台路由器。</p><ol><li>家庭接入：DSL、电缆、FTTH 和 5G 固定式无线<ul><li>DSL - Digital Subscirber Line 数字用户线</li><li>HFC - Hybrid Fiber Coax 混合光纤同轴</li><li>FTTH - Fiber To The Home 光纤到户</li></ul></li><li>企业（和家庭）接入：以太网和 WIFI</li><li>广域无线接入：3G、LTE 4G 和 5G</li></ol><h4 id="物理媒介">物理媒介</h4><ul><li>导引型媒介：电波沿着固体媒介前行，如光缆、双绞铜线或同轴电缆</li><li>非导引型媒介：电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中传播</li></ul><h3 id="网络核心-The-Network-Core">网络核心 The Network Core</h3><p><strong>报文 message:</strong> 包含该应用的设计者需要的任何东西。可以执行一种控制功能，也可以包含数据。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称为<strong>分组 packet</strong>。</p><h4 id="电路交换-circuit-switching">电路交换 circuit switching</h4><p>在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。<br><img src="2025022638.png" alt=""></p><ol><li><strong>频分复用</strong> Frequency-Division Multiplexing FDM: 链路的频谱由跨越链路创建的所有连接共享。在连接期间链路为每条连接专设一个频段，该频段的宽度称为带宽。</li><li><strong>时分复用</strong> Time-Division Multiplexing TDM: 时间被划分为固定时段的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网路在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用。</li></ol><p>优缺点：<br><img src="2025022670.png" alt=""></p><h4 id="分组交换-packet-switching">分组交换 packet switching</h4><p><strong>存储转发传输</strong> store-and-forward transmission: 在交换机开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。<br><img src="2025022618.png" alt=""><br>排队时延/丢失：<br><img src="2025022686.png" alt=""><br>优缺点：<br><img src="2025022641.png" alt=""></p><h2 id="Network-Performance">Network Performance</h2><h3 id="时延类型">时延类型</h3><ol><li>传输时延 Transmission delay: 用 L 表示分组长度，用 R 表示从路由器 A 到路由器 B 的链路传输速率，传输时延时 L/R。</li><li>传播时延 Propagation delay: 从链路的起点到路由器 B 传播所需要的时间。</li><li>排队时延 Queuing delay: 在队列中，当分组在链路上等待传输时，将经受排队时延。</li><li>处理时延 Processing delay: 检查分组首部/决定该分组导向何处等所需的时间。</li></ol><h3 id="端到端时延">端到端时延</h3><p><img src="2025022692.png" alt=""></p><h2 id="协议层次和服务模型">协议层次和服务模型</h2><h3 id="协议分层">协议分层</h3><h4 id="应用层">应用层</h4><p>网络应用程序及它们的应用层协议存留的地方。<br>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组，这种位于应用层的信息分组称为<strong>报文 message</strong>。</p><h4 id="运输层">运输层</h4><p>在应用程序端点之间传送应用层报文。<br>把运输层的分组称为<strong>报文段 segment</strong>。</p><h4 id="网络层">网络层</h4><p>负责将称为<strong>数据报 datagram</strong> 的网络层分组从一台主机移动到另一台主机。</p><h4 id="链路层">链路层</h4><p>在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在下一个节点链路层将数据报上传给网络层。<br>链路层的分组称为<strong>帧 frame</strong>。</p><h4 id="物理层">物理层</h4><p>链路层将整个帧从一个网络元素移动到邻近的网络元素，而物理层是将帧中的一个个比特从一个节点移动到下一个节点。</p><h3 id="封装">封装</h3><p><img src="2025022640.png" alt=""><br><img src="2025022651.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>2025春-互联网计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
